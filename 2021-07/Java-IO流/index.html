<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Java IO流 | 懒人瑜恩</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '2059a4484fb666484cf5e9fba7e20ce6';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java IO流</h1><a id="logo" href="/.">懒人瑜恩</a><p class="description">sometimes code, sometimes English</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/history/"><i class="fa fa-book"> 历史</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java IO流</h1><div class="post-meta">2021-07-20<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">基础概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">2.</span> <span class="toc-text">字节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%AD%97%E8%8A%82-InputStream"><span class="toc-number">2.1.</span> <span class="toc-text">读字节 InputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2"><span class="toc-number">2.1.1.</span> <span class="toc-text">缓冲</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%AD%97%E8%8A%82-OutputStream"><span class="toc-number">2.2.</span> <span class="toc-text">写字节-OutputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-number">2.3.</span> <span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.</span> <span class="toc-text">copy文件的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Filter-%E7%BB%84%E5%90%88%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%B5%81%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">Filter 组合输入&#x2F;输出流过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">输入输出字符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-Reader"><span class="toc-number">4.1.</span> <span class="toc-text">输入-Reader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-Writer"><span class="toc-number">4.2.</span> <span class="toc-text">输出-Writer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">4.3.</span> <span class="toc-text">copy文件的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81-%E6%8F%90%E9%AB%98%E6%B5%81%E7%9A%84%E8%AF%BB%E5%8F%96%E5%86%99%E5%85%A5%E7%9A%84%E9%80%9F%E5%BA%A6"><span class="toc-number">5.</span> <span class="toc-text">缓冲流-提高流的读取写入的速度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">6.</span> <span class="toc-text">IO转换流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">标准输入输出流（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">8.</span> <span class="toc-text">数据流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-number">9.</span> <span class="toc-text">对象流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RandomAccessFile%E7%B1%BB"><span class="toc-number">10.</span> <span class="toc-text">RandomAccessFile类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NIO"><span class="toc-number"></span> <span class="toc-text">NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.</span> <span class="toc-text">通道和缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.1.</span> <span class="toc-text">缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">基本属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.3.</span> <span class="toc-text">缓冲区的数据操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.</span> <span class="toc-text">直接缓冲区和非直接缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E9%81%93-Channel"><span class="toc-number">3.</span> <span class="toc-text">通道(Channel)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%80%9A%E9%81%93"><span class="toc-number">3.1.</span> <span class="toc-text">获取通道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">3.1.1.</span> <span class="toc-text">数据传输</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%95%A3%EF%BC%88Scatter%EF%BC%89%E8%81%9A%E9%9B%86%EF%BC%88Gather"><span class="toc-number">4.</span> <span class="toc-text">分散（Scatter）聚集（Gather)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TransferTo%E2%80%94-TransferFrom"><span class="toc-number">5.</span> <span class="toc-text">TransferTo—-TransferFrom</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TransferFrom"><span class="toc-number">5.1.</span> <span class="toc-text">TransferFrom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TransferTo"><span class="toc-number">5.3.</span> <span class="toc-text">TransferTo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FileChannel%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">FileChannel常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">7.</span> <span class="toc-text">NIO非阻塞式网络通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8Selector"><span class="toc-number">7.1.</span> <span class="toc-text">选择器Selector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tcp%E6%A8%A1%E5%BC%8F%E7%9A%84Selector%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">7.2.</span> <span class="toc-text">Tcp模式的Selector非阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.1.</span> <span class="toc-text">Selector常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel"><span class="toc-number">7.2.2.</span> <span class="toc-text">SocketChannel</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-number">7.3.</span> <span class="toc-text">UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DatagramChannel"><span class="toc-number">7.3.1.</span> <span class="toc-text">DatagramChannel</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipe%EF%BC%88%E7%AE%A1%E9%81%93%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">Pipe（管道）</span></a></li></ol></div></div><div class="post-content"><h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><p>IO是指 Input  –  Output，即输入和输出，以内存为中心</p>
<p>input从外部读入数据到内存。output从内存输出到外部。</p>
<p>这些输入输出流的来源地和目的地可以是文件，也可以是网络连接，甚至是内存块。</p>
<p>其中Stream是进行处理字节的，而Reader和Writer是用来处理字符的，他们衍生的子类命名也都是以这些后缀结束的。</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201119153701157.png" alt="image-20201119153701157"></p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="读字节-InputStream"><a href="#读字节-InputStream" class="headerlink" title="读字节 InputStream"></a>读字节 InputStream</h3><p>读（IputStream） 类有一个抽象方法，read()，这个方法读入一个字节，并返回读入的字节。或者在输入源结尾时返回-1。</p>
<p>一个读取操作如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用try finally</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    InputStream is =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用try resource</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在计算机系统中，我们打开了一个资源使用完了需要进行关闭。以便让操作系统把资源释放到，否则应用程序占用的资源会越来越多。</p>
<p>InputStream,OutputStream都是通过close关闭资源的。</p>
<p>在我们第一个代码中，我们看到 InputStream is = null;  然后在try里面进行了数据的读操作。但是如果读操作失败了。程序就会跳到finally中，如果我们没有对is进行不等于null的判断，那么就是is操作还没有完成就会被关闭掉。这是不正常的关闭。</p>
<p>而第二个代码块中，我们使用的是java 7之后支持的 try(resource) 的写法，只需要编写try语句，编译器就会为我们自动关闭资源。</p>
<blockquote>
<p>实际上，编译器并不会特别地为<code>InputStream</code>加上自动关闭。编译器只看<code>try(resource = ...)</code>中的对象是否实现了<code>java.lang.AutoCloseable</code>接口，如果实现了，就自动加上<code>finally</code>语句并调用<code>close()</code>方法。<code>InputStream</code>和<code>OutputStream</code>都实现了这个接口，因此，都可以用在<code>try(resource)</code>中。</p>
</blockquote>
<h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><p>在我们读取流的时候，一个一个读取并不是最高效的。大多数流支持一次性读取多个字节到缓冲区。InputStream支持读取多个字节填充到byte数据中。</p>
<ul>
<li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li>
<li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li>
</ul>
<p>利用上述方法一次读取多个字节时，需要先定义一个<code>byte[]</code>数组作为缓冲区，<code>read()</code>方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。<code>read()</code>方法的返回值不再是字节的<code>int</code>值，而是返回实际读取了多少个字节。如果返回<code>-1</code>，表示没有更多的数据了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BufferInputStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">//三个字节读一次</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="写字节-OutputStream"><a href="#写字节-OutputStream" class="headerlink" title="写字节-OutputStream"></a>写字节-OutputStream</h3><p>OutputStream也是一个抽象类，抽象了write(int b)方法</p>
<p>要注意的是 int b虽然是int参数。但是每次写入还是只能写入一个字节。</p>
<p>OutputStream还定义了一个flush()方法，目的是将缓冲区中的内容输出到目的地。因为在写入数据的时候，处于效率的考虑，操作系统不是写入一个字节就发送一个字节。而是当缓冲区满了之后在发出去。而flush方法可以强制性的将缓冲区的内容发送到目的地。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次读入一个字节</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        os.write(<span class="number">10</span>);</span><br><span class="line">        os.write(<span class="number">108</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次读入多个字节</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        os.write(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>在InputStream和outputStream中，读写的操作是阻塞的。也就是说，这个线程在进行读取的时候，不能进行下面的操作，需要等到读写完毕之后，才能运行下面的语句。</p>
<h3 id="copy文件的实现"><a href="#copy文件的实现" class="headerlink" title="copy文件的实现"></a>copy文件的实现</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">copy</span>(<span class="params"><span class="built_in">String</span> path,<span class="built_in">String</span> copyPath</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">try</span>(<span class="params">InputStream is = <span class="keyword">new</span> FileInputStream(path)</span>)</span> &#123;</span><br><span class="line">        int len;</span><br><span class="line">        byte[] buf = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="function"><span class="title">try</span>(<span class="params">OutputStream os = <span class="keyword">new</span> FileOutputStream(copyPath)</span>)</span> &#123;</span><br><span class="line">                os.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Filter-组合输入-输出流过滤器"><a href="#Filter-组合输入-输出流过滤器" class="headerlink" title="Filter 组合输入/输出流过滤器"></a>Filter 组合输入/输出流过滤器</h2><p>DataInputStream只能读入数据类型，而FileInputStream可以提供在磁盘上读取文件的一个输入流。</p>
<p>其中DataInputStream不能进行读写磁盘，FileInputStream不能进行数值的读写。</p>
<p>但是Java使用了一种灵巧的机制可以将二者进行结合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream file = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(file);</span><br><span class="line"></span><br><span class="line">file.readInt(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这样的话FileInputStream基础智商高，可以附加额外的功能。</p>
<p>还可以使用这样的嵌套机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">    <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>我们将DataInputStream放在构造器链的最后，是希望使用DataInputStream的read方法且带有缓冲机制。</p>
<h2 id="输入输出字符"><a href="#输入输出字符" class="headerlink" title="输入输出字符"></a>输入输出字符</h2><h3 id="输入-Reader"><a href="#输入-Reader" class="headerlink" title="输入-Reader"></a>输入-Reader</h3><p>Reader是Java Io库中的另外一个输入流。和InputStream的区别是，InputStream是byte为单位进行读取。而Reader是字符流，字符单位进行读取的(char);</p>
<p>使用时需要指定编码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取单个字符</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReaderTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;test.txt&quot;</span>,StandardCharsets.UTF-<span class="number">8</span>))&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fileReader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取多个字符</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReaderTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;test.txt&quot;</span>),,StandardCharsets.UTF-<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = fileReader.read(chars))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(chars);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="输出-Writer"><a href="#输出-Writer" class="headerlink" title="输出-Writer"></a>输出-Writer</h3><p>基本原理和输入流的概念相同===直接上例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(Writer w = <span class="keyword">new</span> FileWriter(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        w.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e )&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="copy文件的实现-1"><a href="#copy文件的实现-1" class="headerlink" title="copy文件的实现"></a>copy文件的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Reader r = <span class="keyword">new</span> FileReader(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = r.read(chars))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> (Writer w = <span class="keyword">new</span> FileWriter(<span class="string">&quot;test2.txt&quot;</span>))&#123;</span><br><span class="line">                w.write(chars,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="缓冲流-提高流的读取写入的速度"><a href="#缓冲流-提高流的读取写入的速度" class="headerlink" title="缓冲流-提高流的读取写入的速度"></a>缓冲流-提高流的读取写入的速度</h2><p>内部提供了一个缓冲区。增加读写速度。</p>
<p>使用用例：copy文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BufferStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)))&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(buf)) != -<span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">try</span> (BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>)))&#123;</span><br><span class="line">                bos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符流操作基本相同，不进行演示。</p>
<h2 id="IO转换流"><a href="#IO转换流" class="headerlink" title="IO转换流"></a>IO转换流</h2><p>属于字符流</p>
<p>inputStreamReader，将一个字节的输入流转换为字符的输入流</p>
<p>OutputStreamWriter，将一个字符的输出流转换为字节的输出流</p>
<p>inputStreamReader用例，用字节流读出文件，使用转换流进行转换并输出，其中用了嵌套调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InputStreamReaderTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStreamReader is = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(cbuf))!= -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(cbuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>outputStreamWriter用例，将字符文件读取出来，用另外一种编码方式，使用转换流进行编码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputStreamWriterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStreamReader is = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)))&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(cbuf))!= -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> (OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>),<span class="string">&quot;gbk&quot;</span>))&#123;</span><br><span class="line">                osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="标准输入输出流（了解）"><a href="#标准输入输出流（了解）" class="headerlink" title="标准输入输出流（了解）"></a>标准输入输出流（了解）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStreamReader is = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(is);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        String s = br.readLine();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equals(s)||<span class="string">&quot;exit&quot;</span>.equals(s))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;------finish------&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>DataInputStream，DataOutputStream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line">    dos.writeUTF(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">    dos.writeInt(<span class="number">1</span>);</span><br><span class="line">    dos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>ObjectInputStream，ObjectOutputStream，用于存储和读取<strong>基本数据类型数据</strong>或<strong>对象</strong>的处理流。可以吧Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p>
<ul>
<li><p>序列化：用ObjectOutputStream类<strong>保存</strong>基本类型数据或对象的机制</p>
</li>
<li><p>反序列化：用ObjectInputStream类<strong>读取</strong>基本类型数据或对象的机制</p>
</li>
</ul>
<p>ObjectOutputStream和ObjectInputStream不能序列化<strong>static</strong>和<strong>transient</strong>修饰的成员变量</p>
<ul>
<li><p>对象的序列化机制：允许吧内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久的保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其他程序获得了这个二进制流，就可以恢复成原来的Java对象</p>
</li>
<li><p>序列化的好处在于可将任何实现了Serializable接口的对象转换为字节数据，使其在保存和传输时可被还原。</p>
</li>
<li><p>要想某个类能够被序列化，需要实现序列化接口。加上序列端口号（serialVersionUID)</p>
<ul>
<li>必须加上serialVersionUID，如果没加上，在实例的时候会自动给serialVersionUID赋值，但是如果类的实例变量做了修改，serialVersionUID可能发生变化。</li>
<li>而且，除了本类需要序列化，类中的属性也必须都支持序列化</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ObjectOutputStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;object.dat&quot;</span>)))&#123;</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ObjectInputStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;object.dat&quot;</span>))) &#123;</span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        String str = (String) o;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h2><ul>
<li><p>直接继承与Object，实现了DataInput，DataOutput接口，既可以作为输入流，也可以作为输出流</p>
</li>
<li><p>如果RandomAccessFile类作为一个输出流，写出的文件不存在时，则在执行过程中自动创建。如果写出的文件存在，则会对原油文件内容覆盖，从头覆盖。</p>
</li>
</ul>
<p>方法</p>
<ul>
<li>seek(int x);  seek可以将指针调整到x的位置。</li>
</ul>
<p>文件的复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RandomAccessFile r1 = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    RandomAccessFile r2 = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test1.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = r1.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        r2.write(buf,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    r1.close();</span><br><span class="line">    r2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为了看起来方便所以没用使用try-catch-finally，实际使用中需要使用try-catch-finally</p>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>Java NIO（new IO)是从java1.4版本开始引入的新io api。与原有的io有同样的作用和目的。但是会有一些区别</p>
<table>
<thead>
<tr>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向流(Stream Oriented)</td>
<td>面向缓冲区(Buffer Oriented)</td>
</tr>
<tr>
<td>阻塞IO(blocking IO)</td>
<td>非阻塞IO(Non Blocking IO)</td>
</tr>
<tr>
<td>无</td>
<td>选择器(Selectors)</td>
</tr>
</tbody></table>
<h2 id="通道和缓冲区"><a href="#通道和缓冲区" class="headerlink" title="通道和缓冲区"></a>通道和缓冲区</h2><p>通道（channel）负责传输，buffer（缓冲区）负责存储</p>
<p>核心在于，通道表示打开到IO设备的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><ul>
<li><p>缓冲区(Buffer)：一个用于<strong>特定基本类型的容器</strong>。由java.nio包定义的。所有缓冲区都是Buffer抽象类的子类。</p>
</li>
<li><p>Java Nio中的Buffer主要用于与Nio通道进行交互，数据是从<strong>通道读入缓冲区</strong>，从<strong>缓冲区写入通道中</strong>的。</p>
</li>
</ul>
<ol>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ol>
<p>都采用相似的方法进行管理数据，只是各自管理的数据类型不同。</p>
<p>通过如下方法获取一个Buffer对象</p>
<p><strong>static xxxBuffer  allocate(int capacity); 创建一个容量为capacity的xxxBuffer对象</strong></p>
<h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><ul>
<li>容量(Capacity)：表示Buffer最大数据容量，缓冲区容量不能为负，且创建后不能更改</li>
<li>限制(limit)：不应该被读取或写入的数据的索引，也就是说，位于limit后的数据不可读写，缓冲区的限制不能为负，并且不能大于其容量</li>
<li>位置(position):下一个要读写数据的索引，缓冲区的位置不能为负，并且不能大于其限制。</li>
<li>标记(mark)与重置(reset)：标记是一个索引，通过mark方法标记一个位置，通过reset可以回到这个位置。</li>
</ul>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120143549483.png" alt="image-20201120143549483"></p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120143929945.png" alt="image-20201120143929945"></p>
<h4 id="缓冲区的数据操作"><a href="#缓冲区的数据操作" class="headerlink" title="缓冲区的数据操作"></a>缓冲区的数据操作</h4><p>Buffer所有子类提供了俩个用于数据操作的方法：get()与put()方法</p>
<ul>
<li>获取Buffer中的数据<ul>
<li>get()：获取单个字节</li>
<li>get(byte[] dst): 批量读取多个字节到dst中</li>
<li>get(int index)：读取指定索引位置的字节（不会移动position)</li>
</ul>
</li>
<li>放入数据到Buffer中<ul>
<li>​    put(byte b ); 将给定单个字节写入缓冲区的当前位置</li>
<li>put(byte[] src) 将src中的字节写入缓冲区的当前位置</li>
<li>put(int index, byte b) 将指定字节写入缓冲区的索引位置（不会移动position）</li>
</ul>
</li>
</ul>
<h2 id="直接缓冲区和非直接缓冲区"><a href="#直接缓冲区和非直接缓冲区" class="headerlink" title="直接缓冲区和非直接缓冲区"></a>直接缓冲区和非直接缓冲区</h2><ul>
<li>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则java虚拟机会尽最大努力直接在此缓冲区上执行本机I/O操作。也就是说，在每次调用基础操作系统的一个本机I/O操作之前 / 之后   ，虚拟机都会尽量避免缓冲区的内容复制到中间缓冲区中。（或从中间缓冲区复制内容）</li>
<li>直接字节缓冲区可以通过调用此类的<strong>allocateDirect()工厂方法</strong>来创建。此方法返回的<strong>缓冲区进行分配和取消分配所需成本通常 高于 非直接缓冲区</strong>。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，他们对应用程序的内存需求造成的影响可能不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机I/O操作影响的大型持久的缓冲区，一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显的好处时分配他们。</li>
<li>直接字节缓冲区还可以通过<strong>FileChannel的map()方法</strong>将文件区域直接映射到内存中来创建。该方法返回<strong>MappedByteBuffer</strong>。Java平台的实现有助于通过JNI从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。</li>
<li>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其isDirect()方法来确定。提供此方法为了能够在性能关键型代码中执行显式缓冲区管理。</li>
</ul>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120192145057.png" alt="image-20201120192145057"></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120192154588.png" alt="image-20201120192154588"></p>
<h2 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h2><p>通道：由java.nio.channels包定义。表示io源与目标打开的连接。类似于传统的”流“。只不过不能直接访问数据，只能与buffer进行交互。</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120194239570.png" alt="image-20201120194239570"></p>
<ul>
<li>FileChannel：用于读取，写入，映射和操作文件的通道</li>
<li>DatagramChannel：通过UDP读写网络中的数据通道</li>
<li>SocketChannel：通过Tcp读写网络中的数据</li>
<li>ServerSocketChannel：可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel</li>
</ul>
<h3 id="获取通道"><a href="#获取通道" class="headerlink" title="获取通道"></a>获取通道</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120194520338.png" alt="image-20201120194520338"></p>
<h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120194533240.png" alt="image-20201120194533240"></p>
<h2 id="分散（Scatter）聚集（Gather"><a href="#分散（Scatter）聚集（Gather" class="headerlink" title="分散（Scatter）聚集（Gather)"></a>分散（Scatter）聚集（Gather)</h2><p>分散是指一个channel的数据，分散到多个缓冲区。</p>
<p>聚集是指多个buffer聚集到一个channel中。</p>
<p>所有操作都需要try-catch，这里只是为了看的层次感。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分散读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ScatterAndGatherTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    FileChannel fisChannel = fis.getChannel();</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">    ByteBuffer buffer2 = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    ByteBuffer[] buffers = &#123;buffer1,buffer2&#125;;</span><br><span class="line">    fisChannel.read(buffers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分散读取</span></span><br><span class="line">    <span class="keyword">for</span> (ByteBuffer buffer : buffers) &#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//聚集写入</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line">    FileChannel fosChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">    fosChannel.write(buffers);</span><br><span class="line"></span><br><span class="line">    fis.close();</span><br><span class="line">    fisChannel.close();</span><br><span class="line">    fos.close();</span><br><span class="line">    fosChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="TransferTo—-TransferFrom"><a href="#TransferTo—-TransferFrom" class="headerlink" title="TransferTo—-TransferFrom"></a>TransferTo—-TransferFrom</h2><p>将数据从源通道传输到其他Channel</p>
<h3 id="TransferFrom"><a href="#TransferFrom" class="headerlink" title="TransferFrom"></a>TransferFrom</h3><p>使用输出流的channel，from表示从哪里来，所以用输出流调用此方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransferFrom</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TransferFromTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FileChannel fisChannel = fis.getChannel();</span><br><span class="line">    FileChannel fosChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">    fosChannel.transferFrom(fisChannel,<span class="number">0</span>, fisChannel.size());</span><br><span class="line"></span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">    fisChannel.close();</span><br><span class="line">    fosChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="TransferTo"><a href="#TransferTo" class="headerlink" title="TransferTo"></a>TransferTo</h3><p>使用输入流channel调用，表示数据到哪里去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransferTo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TransferToTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FileChannel fisChannel = fis.getChannel();</span><br><span class="line">    FileChannel fosChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">    fisChannel.transferTo(<span class="number">0</span>, fisChannel.size(),fosChannel);</span><br><span class="line"></span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">    fisChannel.close();</span><br><span class="line">    fosChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="FileChannel常用方法"><a href="#FileChannel常用方法" class="headerlink" title="FileChannel常用方法"></a>FileChannel常用方法</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120205445563.png" alt="image-20201120205445563"></p>
<h2 id="NIO非阻塞式网络通信"><a href="#NIO非阻塞式网络通信" class="headerlink" title="NIO非阻塞式网络通信"></a>NIO非阻塞式网络通信</h2><p>传统的IO流都是阻塞式的。而JavaNIO是非阻塞的。当线程从某同道进行读写数据时，若没有数据可同时，该线程可以进行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行Io操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO可以让服务器端使用一个或有限几个线程来同时处理连接到服务端的所有客户端。</p>
<h3 id="选择器Selector"><a href="#选择器Selector" class="headerlink" title="选择器Selector"></a>选择器Selector</h3><p>选择器（Selector） 是 SelectableChannle 对象的多路复用器，<strong>Selector 可以同时监控多个 SelectableChannel 的 IO 状况</strong>，也就是说，利用 <strong>Selector 可使一个单独的线程管理多个 Channel</strong>。Selector 是非阻塞 IO 的核心。</p>
<p>Selector结构</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201122135131145.png" alt="image-20201122135131145"></p>
<h3 id="Tcp模式的Selector非阻塞"><a href="#Tcp模式的Selector非阻塞" class="headerlink" title="Tcp模式的Selector非阻塞"></a>Tcp模式的Selector非阻塞</h3><p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SocketChannel sChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9898</span>))) &#123;</span><br><span class="line">        <span class="comment">//设置非阻塞模式</span></span><br><span class="line">        sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">		</span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            String s = sc.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;exit&quot;</span>.equals(s))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf.put(s.getBytes());</span><br><span class="line">            buf.flip();</span><br><span class="line">            sChannel.write(buf);</span><br><span class="line">            buf.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SocketChannel sChannel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> (ServerSocketChannel ssChannel = ServerSocketChannel.open())&#123;</span><br><span class="line">		<span class="comment">//设置非阻塞模式</span></span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">//绑定端口</span></span><br><span class="line">        ssChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line">		<span class="comment">//获取选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">		<span class="comment">//向选择器注册通道</span></span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//判断是否有选择器被注册</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//获取注册器的SelectedKeys迭代器</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                SelectionKey sk = it.next();</span><br><span class="line">                <span class="comment">//是否接受就绪</span></span><br><span class="line">                <span class="keyword">if</span> (sk.isAcceptable())&#123;</span><br><span class="line">                    sChannel = ssChannel.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    sChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//是否可读就绪</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sk.isReadable())&#123;</span><br><span class="line">                    sChannel = (SocketChannel)sk.channel();</span><br><span class="line">                    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                    ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((len = sChannel.read(buf))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        buf.flip();</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(buf.array(),<span class="number">0</span>,len));</span><br><span class="line">                        buf.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定</p>
<p>可以监听的事件类型（<strong>可使用</strong> <strong>SelectionKey</strong> <strong>的四个常量表示</strong>）：</p>
<ul>
<li><p> 读 : SelectionKey.OP_READ （1） </p>
</li>
<li><p> 写 : SelectionKey.OP_WRITE （4） </p>
</li>
<li><p> 连接 : SelectionKey.OP_CONNECT （8） </p>
</li>
<li><p> 接收 : SelectionKey.OP_ACCEPT （16） </p>
</li>
</ul>
<h4 id="Selector常用方法"><a href="#Selector常用方法" class="headerlink" title="Selector常用方法"></a>Selector常用方法</h4><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201122152338158.png" alt="image-20201122152338158"></p>
<h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p>连接到Tcp网络套接字的通道</p>
<p>操作步骤</p>
<ol>
<li>打开SocketChannel</li>
<li>读写数据</li>
<li>关闭SocketChannel</li>
</ol>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h4><ul>
<li><p>能发送Udp包的通道</p>
</li>
<li><p>操作步骤</p>
<ol>
<li>打开DatagramChannel</li>
<li>接受/发送数据</li>
</ol>
</li>
</ul>
<p>UDP基本和Tcp一样</p>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramChannel dc = DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">    dc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (scan.hasNext())&#123;</span><br><span class="line">        String s = scan.nextLine();</span><br><span class="line">        buf.put(s.getBytes());</span><br><span class="line"></span><br><span class="line">        buf.flip();</span><br><span class="line">        dc.send(buf,<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9898</span>));</span><br><span class="line">        buf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    dc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramChannel dc = DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">    dc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    dc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line"></span><br><span class="line">    Selector selector= Selector.open();</span><br><span class="line"></span><br><span class="line">    dc.register(selector,SelectionKey.OP_READ);</span><br><span class="line">    <span class="keyword">while</span> (selector.select()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            SelectionKey sk = it.next();</span><br><span class="line">            <span class="keyword">if</span> (sk.isReadable())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">                ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                dc.receive(buf);</span><br><span class="line">                buf.flip();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(buf.array(),<span class="number">0</span>,buf.limit()));</span><br><span class="line">                buf.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    dc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Pipe（管道）"><a href="#Pipe（管道）" class="headerlink" title="Pipe（管道）"></a>Pipe（管道）</h2><p>管道是俩个线程之间的单向数据连接。Pipe有一个Source通道和一个Sink通道。</p>
<p>数据会被写入Sink通道，从Source通道接收读取</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201122152654073.png" alt="image-20201122152654073"></p>
<p>这里将sink和source放在一个方法中了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String s = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Pipe pipe = Pipe.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sink</span></span><br><span class="line">    Pipe.SinkChannel sink = pipe.sink();</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    buffer.put(s.getBytes());</span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">        sink.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//source</span></span><br><span class="line">    Pipe.SourceChannel source = pipe.source();</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    source.read(buffer1);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(buffer1.array(),<span class="number">0</span>,buffer1.limit()));</span><br><span class="line"></span><br><span class="line">    source.close();</span><br><span class="line">    sink.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><p><span>本文标题：</span>Java IO流</p><p><span>文章作者：</span>懒人瑜恩</p><p><span>发布时间：</span>2021-07-20</p><p><span>最后更新：</span>2021-07-20</p><p><span>原始链接：</span><a href="/2021-07/Java-IO流/">https://yvenxx.github.io/yvenxx/2021-07/Java-IO%E6%B5%81/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://yvenxx.github.io/yvenxx/2021-07/Java-IO%E6%B5%81/"></i></span></p><p><span>版权声明：</span>版权所有，转载请注明出处。</p></div><br><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://yvenxx.github.io/yvenxx/2021-07/Java-IO%E6%B5%81/" data-id="cktu6p4f9000smou3068ffwrm" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACN0lEQVR42u3ay46DMBBE0fz/T5PtSARTVW2P5PZlhSJCOCw6/fp85OO6HX8/18/vd1M+n3bAgAFjW8Y1PJRrsm/dn+HpXLkDDBgwTmA8RTD3Z8bXjEOwEqwfP4cBAwYM+dZ6YB3neDBgwIAxl+GWnVmaCAMGDBhKOap/SylolTC9pBaHAQPGhgw9RP7/+ZL5BgwYMLZiZO3+cRMta66VhhAwYMBozXBbYOOfdJGVtA8GDBjnMMLGltmAUwYJykuZPUmAAQPGTozKooMSIt0UU3+2HxkuDBgwmjLconQcCpURgvIHYPwNwIABozUjW55wk0glvGYB+qUWhwEDRmvGrDUIPaC7aaL9dmHAgLEto7IK5qaGlQWLlzYcDBgwDmC421YuSUn1SiMEGDBgtGYoBWclaOpst9EmAWDAgNGCkZWvs96WErLtnREYMGC0Y8waH2YpXba08XI9DBgw2jH0dn/2uPpbtPNW923BgAGjBcNt+s9qn7kh+PG/AgYMGE0ZbgJXada74dgdQsCAAeM0RqVN5q6R1b8FAwaMcxiVEjdLIpUWnjHmhAEDxpEMvTWfjQqUctcYkcKAAaMp4zIPvWbUH9FNE19yWxgwYLRjVKaE+uJFfakiuw8MGDA6MfSBYvbDyphBeWWlBBEGDBgtGHMfLitul9TiMGDAOJKRjTbHITVcsIABAwYMuYAMkznzBS1MDWHAgLEJY+7aVgW5vN0GAwaMDRnZmoV+niWOc1c0YMCAsS3jC0iGaph1l/F8AAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/Java/"><i class="fa fa-tag"></i>Java</a></div><div class="post-nav"><a class="pre" href="/2021-08/Android-%E9%A1%B6%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F/">Android 顶部导航栏</a><a class="next" href="/2021-01/Centos7-%E5%AE%89%E8%A3%85python3-x/">Centos7 安装python3.x</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://yvenxx.github.io/yvenxx"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021-09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E7%AC%94%E8%AE%B0/">数据结构-树-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021-08/Android-%E9%A1%B6%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F/">Android 顶部导航栏</a></li><li class="post-list-item"><a class="post-list-link" href="/2021-07/Java-IO%E6%B5%81/">Java IO流</a></li><li class="post-list-item"><a class="post-list-link" href="/2021-01/Centos7-%E5%AE%89%E8%A3%85python3-x/">Centos7 安装python3.x</a></li><li class="post-list-item"><a class="post-list-link" href="/2021-01/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E6%8C%87%E9%92%88/">C语言：指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2021-01/Meta-%E7%9A%84%E6%A0%87%E7%AD%BE%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93-Html/">Meta 的标签理解总结- Html</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://yvenxx.cn/" title="懒人瑜恩" target="_blank">懒人瑜恩</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">懒人瑜恩.</a> Powered by Hexo.</div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>