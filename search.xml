<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构-树-笔记</title>
      <link href="2021-09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E7%AC%94%E8%AE%B0/"/>
      <url>2021-09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>基本术语</p><ol><li><strong>结点的度</strong>（Degree）：结点的<strong>子树个数</strong></li><li><strong>树的度</strong>：树的所有节点中最大的度数</li><li><strong>叶结点</strong>（Leaf）：<strong>度为0</strong>的节点</li><li><strong>父结点</strong>（Parent）：若一个节点含有子结点，则这个节点称为其节点的父节点</li><li><strong>子结点</strong>（Child）：若A结点是B节点的父结点，则B节点是A节点的子结点，也称孩子节点</li><li><strong>兄弟节点</strong>（Sibling）：具有同一父结点的各结点彼此是兄弟结点</li><li><strong>路径和路径长度</strong>：从结点N1到Nk的路径为一个节点序列，节点的个数为路径的长度</li><li><strong>祖先节点</strong>（Ancestor）：沿树根到某一节点路径上所有节点都是这个节点的祖先节点</li><li><strong>子孙节点</strong>（Descendant）：某一节点的子树中的所有节点是这个节点的子孙</li><li><strong>节点的层次</strong>（Level）：规定根节点在1层</li><li><strong>树的深度</strong>（Depth）：树中所有结点中的最大层次是这棵树的深度</li></ol><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>特殊二叉树</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210902145632268.png" alt="image-20210902145632268"></p><p><strong>重要性质</strong></p><ul><li>一个二叉树第 i 层 的最大结点数为：2^(i-1) , i&gt;=1</li><li>深度为k的二叉树有最大结点总数为：2^k-1,k&gt;=1</li><li>对任何非空二叉树T，若n0表示叶结点的个数，n2是度为2的非叶结点个数，那么两者关系满足 n0=n2+1</li></ul><p><strong>遍历方法</strong></p><ol><li>先序——根，左子树，右子树</li><li>中序——左子树，根，右子树</li><li>后序—–左子树，右子树，根</li><li>层次遍历—从上到下，从左到右（一层一层的遍历，从左到右）</li></ol><h4 id="代码实现-递归-全部代码"><a href="#代码实现-递归-全部代码" class="headerlink" title="代码实现-递归-全部代码"></a>代码实现-递归-全部代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">createTree</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    Tree t;</span><br><span class="line">    <span class="comment">//分配堆栈空间</span></span><br><span class="line">    t=(Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TNode));</span><br><span class="line">    t-&gt;Data = value;</span><br><span class="line">    t-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTraversalRecursion</span><span class="params">(Tree t)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 先序遍历 递归 根 左 右</span></span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">        PreTraversalRecursion(t-&gt;Left);</span><br><span class="line">        PreTraversalRecursion(t-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiddleTraversalRecursion</span><span class="params">(Tree t)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 中序遍历 递归，左 根 右</span></span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        MiddleTraversalRecursion(t-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">        MiddleTraversalRecursion(t-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostTraversalRecursion</span><span class="params">(Tree t)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 后序遍历 递归，左 右 根</span></span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostTraversalRecursion(t-&gt;Left);</span><br><span class="line">        PostTraversalRecursion(t-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(Tree t,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 0 已有，1插入成功</span></span><br><span class="line">    <span class="keyword">if</span>(t-&gt;Data == data)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前节点数据已有&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;Data &gt; data)&#123;</span><br><span class="line">        <span class="comment">// 进左</span></span><br><span class="line">        <span class="comment">// printf(&quot;数据小于当前节点\n t.data = %d&quot;,t-&gt;Data);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;左\n&quot;);</span></span><br><span class="line">            judgeDataExistAndPosition(t-&gt;Left,data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Tree temp;</span><br><span class="line">            temp = createTree(data);</span><br><span class="line">            t-&gt;Left = temp;</span><br><span class="line">            <span class="comment">// free(temp);</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d进左\n&quot;</span>,t-&gt;Left-&gt;Data);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;Data &lt; data)&#123;</span><br><span class="line">        <span class="comment">// 进右</span></span><br><span class="line">        <span class="comment">// printf(&quot;\n数据大于当前节点\n t.data = %d&quot;,t-&gt;Data);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;右&quot;);</span></span><br><span class="line">            judgeDataExistAndPosition(t-&gt;Right,data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Tree temp;</span><br><span class="line">            temp = createTree(data);</span><br><span class="line">            t-&gt;Right = temp;</span><br><span class="line">            <span class="comment">// free(temp);</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d进右\n&quot;</span>,t-&gt;Right-&gt;Data);</span><br><span class="line">            <span class="comment">// t-&gt;Data = data;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Tree t = createTree(<span class="number">4</span>);</span><br><span class="line">    add(t,<span class="number">5</span>);</span><br><span class="line">    add(t,<span class="number">2</span>);</span><br><span class="line">    add(t,<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    PostTraversalRecursion(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码实现-非递归-全部代码"><a href="#代码实现-非递归-全部代码" class="headerlink" title="代码实现-非递归-全部代码"></a>代码实现-非递归-全部代码</h4><p>放上了堆栈的代码，所以看起来有点多。其中后序与中序先序不同。用了不一样的方法。</p><p>具体思路是。先入栈，到最左边之后判断右子树，遍历完全部右子树之后。再进行出栈。也就是说第一次回退不是出栈，只是取栈顶元素。等右子树判断之后再进行出栈操作。</p><ol><li>对当前节点判断是否存在左子树，存在压入栈中。置flag为1，表示判断过一次左子树。</li><li>当当前节点不存在，需要出栈了。分为两种情况，<ul><li>一种是flag=1时，是左子树到顶，取栈顶元素，我们设置flag为2，且进入右子树。</li><li>一种是flag=2时，右子树到顶，需要出栈。打印并出栈</li></ul></li></ol><p>即可解决后序非递归二叉树遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArrayStack</span> *<span class="title">Stack</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArrayStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Tree *data;</span><br><span class="line">    Position top;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">createStack</span><span class="params">(<span class="keyword">int</span> maxsize)</span></span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    <span class="comment">// 分配 堆栈和数据的空间</span></span><br><span class="line">    s=(Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ArrayStack));</span><br><span class="line">    s-&gt;data=(Tree *)<span class="built_in">malloc</span>(maxsize*<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    </span><br><span class="line">    s-&gt;top=<span class="number">-1</span>;</span><br><span class="line">    s-&gt;MaxSize=maxsize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isFull</span><span class="params">(Stack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s-&gt;top==s-&gt;MaxSize<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(Stack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s-&gt;top==<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">push</span><span class="params">(Stack s,Tree data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isFull(s))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s-&gt;data[++(s-&gt;top)]=data;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">pop</span><span class="params">(Stack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s-&gt;data[(s-&gt;top--)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">getNode</span><span class="params">(Stack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">createTree</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    Tree t;</span><br><span class="line">    <span class="comment">//分配堆栈空间</span></span><br><span class="line">    t=(Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TNode));</span><br><span class="line">    t-&gt;Data = value;</span><br><span class="line">    t-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(Tree bt)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;先序遍历&quot;</span>);</span><br><span class="line">    Tree t = bt;</span><br><span class="line">    Stack s = createStack(Maxsize);</span><br><span class="line">    <span class="keyword">while</span>(t || !isEmpty(s))&#123;</span><br><span class="line">        <span class="keyword">while</span>(t)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">            push(s,t);</span><br><span class="line">            t = t-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isEmpty(s))&#123;</span><br><span class="line">            t = pop(s);</span><br><span class="line">            t = t-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiddleOrderTraversal</span><span class="params">(Tree bt)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">    Tree t = bt;</span><br><span class="line">    <span class="comment">// 非递归中序遍历   使用堆栈</span></span><br><span class="line">    Stack s = createStack(Maxsize);</span><br><span class="line">    <span class="keyword">while</span>(t || !isEmpty(s))&#123;</span><br><span class="line">        <span class="keyword">while</span> (t)</span><br><span class="line">        &#123;</span><br><span class="line">            push(s,t);</span><br><span class="line">            t=t-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isEmpty(s))&#123;</span><br><span class="line">            t = pop(s);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">            t = t-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(Tree bt)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;后序遍历&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> flagTag[Maxsize];</span><br><span class="line">    Tree t = bt;</span><br><span class="line">    <span class="comment">// 非递归后序遍历   使用堆栈</span></span><br><span class="line">    Stack s = createStack(Maxsize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t || !isEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            push(s,t);</span><br><span class="line">            flagTag[s-&gt;top]=<span class="number">1</span>;</span><br><span class="line">            t=t-&gt;Left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(flagTag[s-&gt;top]==<span class="number">1</span>)&#123;</span><br><span class="line">                t = getNode(s);</span><br><span class="line">                flagTag[s-&gt;top]=<span class="number">2</span>;</span><br><span class="line">                t = t-&gt;Right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t = pop(s);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">                t = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(Tree t,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 0 已有，1插入成功</span></span><br><span class="line">    <span class="keyword">if</span>(t-&gt;Data == data)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前节点数据已有&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;Data &gt; data)&#123;</span><br><span class="line">        <span class="comment">// 进左</span></span><br><span class="line">        <span class="comment">// printf(&quot;数据小于当前节点\n t.data = %d&quot;,t-&gt;Data);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;左\n&quot;);</span></span><br><span class="line">            add(t-&gt;Left,data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Tree temp;</span><br><span class="line">            temp = createTree(data);</span><br><span class="line">            t-&gt;Left = temp;</span><br><span class="line">            <span class="comment">// free(temp);</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d进左\n&quot;</span>,t-&gt;Left-&gt;Data);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;Data &lt; data)&#123;</span><br><span class="line">        <span class="comment">// 进右</span></span><br><span class="line">        <span class="comment">// printf(&quot;\n数据大于当前节点\n t.data = %d&quot;,t-&gt;Data);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;右&quot;);</span></span><br><span class="line">            add(t-&gt;Right,data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Tree temp;</span><br><span class="line">            temp = createTree(data);</span><br><span class="line">            t-&gt;Right = temp;</span><br><span class="line">            <span class="comment">// free(temp);</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d进右\n&quot;</span>,t-&gt;Right-&gt;Data);</span><br><span class="line">            <span class="comment">// t-&gt;Data = data;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Tree t = createTree(<span class="number">10</span>);</span><br><span class="line">    add(t,<span class="number">11</span>);</span><br><span class="line">    add(t,<span class="number">4</span>);</span><br><span class="line">    add(t,<span class="number">3</span>);</span><br><span class="line">    add(t,<span class="number">5</span>);</span><br><span class="line">    add(t,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    PostOrderTraversal(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>思路：根节点入队</p><ol><li>从队列里面取出元素，访问其左右节点。</li><li>将左右节点入队。输出队列拿出来的节点。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">(Tree bt)</span></span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    Tree t;</span><br><span class="line">    <span class="keyword">if</span>(!bt)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Q = createQueue(Maxsize);</span><br><span class="line">    AddQ(q,bt);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        T = DeleteQ(Q); <span class="comment">//取出队列中的节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Left) AddQ(Q,t-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Right) AddQ(Q,t-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树（BST-Binary-Search-Tree"><a href="#二叉搜索树（BST-Binary-Search-Tree" class="headerlink" title="二叉搜索树（BST, Binary Search Tree)"></a>二叉搜索树（BST, Binary Search Tree)</h4><p>也称二叉排序树，二叉查找树。两个条件</p><ul><li>非空左子树比父结点以及根节点小</li><li>非空右子树比父结点和根节点大</li></ul><h5 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h5><p>从根节点开始，树为空返回NULL。树非空则将节点与需要查找的字段左比较。</p><ul><li>如果相等，返回此节点指针</li><li>如果小于当前节点，则进入左子树</li><li>如果大于当前节点，则进入右子树</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法</span></span><br><span class="line"><span class="function">Tree <span class="title">Find</span><span class="params">(<span class="keyword">char</span> data,Tree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>( data &gt; BST-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> Find(data,BST-&gt;Right);<span class="comment">//进入右子树查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data &lt; BST-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> Find(data,BST-&gt;Left);<span class="comment">//进入左子树查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BST;<span class="comment">//查找成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归算法</span></span><br><span class="line"><span class="function">Tree <span class="title">Find</span><span class="params">(<span class="keyword">char</span> data,Tree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(BST)&#123;</span><br><span class="line">        <span class="keyword">if</span>(data &gt; BST-&gt;data)</span><br><span class="line">            BST=BST-&gt;Right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data &lt; BST-&gt;Left)</span><br><span class="line">            BST=BST-&gt;Left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> BST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找最大元素最小元素</span></span><br><span class="line"><span class="comment">//最小-只查找左子树，向最左边查找</span></span><br><span class="line"><span class="function">Tree <span class="title">FindMin</span><span class="params">(Tree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Left)</span><br><span class="line">        <span class="keyword">return</span> BST;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> FindMin(BST-&gt;Left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最大-只查找右子树，向最右边查找</span></span><br><span class="line"><span class="function">Tree <span class="title">FindMax</span><span class="params">(Tree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST)</span><br><span class="line">        <span class="keyword">while</span>(BST-&gt;Right) BST=BST-&gt;Right;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二叉搜索树插入与删除"><a href="#二叉搜索树插入与删除" class="headerlink" title="二叉搜索树插入与删除"></a>二叉搜索树插入与删除</h5><p>插入操作在上面二叉树的代码中，add就已经实现了。这里不进行实现</p><p>删除分多种情况</p><ol><li>删除叶结点，直接进行删除。将其父结点指针变成NULL</li><li>删除有一个孩子节点，将其父结点指向孩子节点</li><li>删除的节点有两个孩子节点，用左子树的最大元素，或者右子树的最小元素。代替此节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function">Tree <span class="title">Delete</span><span class="params">(<span class="keyword">char</span> data,Tree BST)</span></span>&#123;</span><br><span class="line">    Position Tmp;</span><br><span class="line">    <span class="keyword">if</span>(BST==<span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;要删除的元素未找到&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data &lt; BST-&gt;data)</span><br><span class="line">        BST-&gt;Left = Delete(data,BST-&gt;Left);<span class="comment">//左子树递归</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data &gt; BST-&gt;data)</span><br><span class="line">        BST-&gt;Right = Delete(data,BST-&gt;Right);<span class="comment">//右子树递归</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//找到删除的节点</span></span><br><span class="line">    <span class="keyword">if</span>(BST-&gt;Left &amp;&amp; BST-&gt;Right)&#123;</span><br><span class="line">            <span class="comment">//有一个节点或没有节点</span></span><br><span class="line">            Tmp = FindMin(BST-&gt;Right);</span><br><span class="line">            BST-&gt;data = Tmp-&gt;data;</span><br><span class="line">            BST-&gt;Right = Delete(BST-&gt;data,BST-&gt;Right);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//有两个节点</span></span><br><span class="line">            Tmp=BST;</span><br><span class="line">            <span class="keyword">if</span>(!BST-&gt;Left)</span><br><span class="line">                BST =BST-&gt;Right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Right)</span><br><span class="line">                BST=BST-&gt;Right;</span><br><span class="line">            <span class="built_in">free</span>(Tmp);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树-AVL树"></a>平衡二叉树-AVL树</h4><p><strong>平衡因子（BalanceFactor，BF)</strong>: BF(T) = h(l)-h(r)</p><p>平衡二叉树：空树，或者任一结点左，右子树的高度差绝对值不超过1，|BF(T)|&lt;=1。</p><p><strong>RR旋转</strong></p><p>因为是破坏了右子树的右子树，所以是RR。LL类似</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210921113634245.png" alt="image-20210921113634245"></p><p><strong>LR-RL</strong></p><p>其中 Jan破坏的是先左，后右。用红线标出来了。所以应该是将Mar，Aug，May取中间数，当做其根节点。进行旋转。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210921113904653.png" alt="image-20210921113904653"></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><blockquote><p><strong>优先队列</strong>（Priority Queue)：特殊的“队列”，取出元素的顺序是依照元素的<strong>优先权（关键字）</strong>大小，而不是元素进入队列的先后顺序</p></blockquote><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210921131806349.png" alt="image-20210921131806349"></p><p>两个特性</p><p>结构性：用数组表示的完全二叉树</p><p>有序性：任意借点的关键字是其子树节点的最大值或最小值。</p><ul><li>最大堆，也称大顶堆，最大值</li><li>最小堆，小顶堆，最小值</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210921132003686.png" alt="image-20210921132003686"></p><h4 id="最大堆创建"><a href="#最大堆创建" class="headerlink" title="最大堆创建"></a>最大堆创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大堆创建</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">MaxHeap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>&#123;</span></span><br><span class="line">    ElementType *Elements;<span class="comment">//存储的堆元素</span></span><br><span class="line">    <span class="keyword">int</span> size;<span class="comment">//当前堆大小</span></span><br><span class="line">    <span class="keyword">int</span> Capacity;<span class="comment">//堆的总大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MaxHeap <span class="title">Create</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>&#123;</span><br><span class="line">    MaxHeap H = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*struct HeapStruct));</span><br><span class="line">    H-&gt;Elements = <span class="built_in">malloc</span>((Maxsize+<span class="number">1</span>) * <span class="keyword">sizeof</span>(ElementType));<span class="comment">//这里+1是因为数组是从1开始的下标，0位置是存的哨兵</span></span><br><span class="line">    H-&gt;size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;Capacity = Maxsize;</span><br><span class="line">    H-&gt;Elements[<span class="number">0</span>] = MaxData;<span class="comment">//这里MaxData是自己设置的哨兵，定为所有元素中可能最大的值</span></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处哨兵的作用是，定义一个可能最大的值，防止后面调整位置的时候，会判断0位置，少做一次判断。</p><h4 id="最大堆插入"><a href="#最大堆插入" class="headerlink" title="最大堆插入"></a>最大堆插入</h4><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210921132625064.png" alt="image-20210921132625064"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(MaxHeap H,ElementType item)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将元素item存进H堆中。Elements[0]为哨兵</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(IsFull(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大堆已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;Size;<span class="comment">//i 指向堆在插入元素后的最后一个位置</span></span><br><span class="line">    <span class="keyword">for</span>( ; H-&gt;Elements[<span class="number">1</span>/<span class="number">2</span>] &lt; item; i/=<span class="number">2</span>)</span><br><span class="line">        B-&gt;Elements[i] = H-&gt;Elements[<span class="number">1</span>/<span class="number">2</span>];<span class="comment">//如果插入的元素比上面的元素大，就要交换其位置</span></span><br><span class="line">    H-&gt;Elements[i] = item;<span class="comment">//插入item</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里哨兵发挥了作用，因为他不小于任何堆里的元素。所以在i=1时，不用去判断是不是到1了。直接 i/2 就会与哨兵判断就可以少一次判断</p><h4 id="最大堆删除"><a href="#最大堆删除" class="headerlink" title="最大堆删除"></a>最大堆删除</h4><p>将44删除，将最下面的节点放到根节点。然后进行判断是否为最大堆，如果不是就进行排序。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210921133212514.png" alt="image-20210921133212514"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">DeleteMax</span><span class="params">(MaxHeap H)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从最大堆取出最大的元素，并删除一个节点</span></span><br><span class="line">    <span class="keyword">int</span> parent,child;</span><br><span class="line">    ElementType MaxItem,temp;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大堆已空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MaxItem = H-&gt;Elements[<span class="number">1</span>];<span class="comment">//取出根节点最大值</span></span><br><span class="line"> temp = H-&gt;Elements[H-&gt;Size--];<span class="comment">//获取下面的节点</span></span><br><span class="line">    <span class="comment">//parent*2就是左子树的下标。+1就是右子树</span></span><br><span class="line">    <span class="keyword">for</span>(parent=<span class="number">1</span>;parent*<span class="number">2</span>&lt;=H-&gt;Size; parent=child)&#123;</span><br><span class="line">        child = parent*<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//这里判断有没有左子树，并且判断左右子树谁大。</span></span><br><span class="line">        <span class="keyword">if</span>((child!=H-&gt;size) &amp;&amp; (H-&gt;Elements[child]&lt; H-&gt;Elements[child+<span class="number">1</span>]))</span><br><span class="line">            child++;</span><br><span class="line">        <span class="comment">//判断节点的大小。如果大于就不动，如果小了就进行换位</span></span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= H-&gt;Elements[child]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            H-&gt;Elements[parent] = H-&gt;Elements[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> Maxitem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 顶部导航栏</title>
      <link href="2021-08/Android-%E9%A1%B6%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F/"/>
      <url>2021-08/Android-%E9%A1%B6%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F/</url>
      
        <content type="html"><![CDATA[<p>顶部应用栏，有两种可以实现的方法，一种是用5.0之后的Toolbar，一种是我们自己写导航。</p><h2 id="自定义ActionBar"><a href="#自定义ActionBar" class="headerlink" title="自定义ActionBar"></a>自定义ActionBar</h2><ol><li><p>取消系统自带的主题，在values/theme中，改为NoActionBar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.LazyBookkeeping&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在layout中创建导航栏的布局</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/navigationbar_title&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;</span><br><span class="line">        android:textColor=&quot;@color/white&quot;</span><br><span class="line">        android:textSize=&quot;20sp&quot;</span><br><span class="line">        app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/monthly_expenditure&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_marginEnd=&quot;300dp&quot;</span><br><span class="line">        android:layout_marginRight=&quot;300dp&quot;</span><br><span class="line">        android:textColor=&quot;@color/white&quot;</span><br><span class="line">        android:textSize=&quot;20sp&quot;</span><br><span class="line">        app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toBottomOf=&quot;@+id/navigationbar_title&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在activity_main.xml中定义导航栏</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;cn.yvenxx.lazybookkeeping.topGlobalNavigationBar</span><br><span class="line">                android:id=&quot;@+id/topNavigation_bar&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;</span><br><span class="line">                android:fitsSystemWindows=&quot;true&quot;</span><br><span class="line">                app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">                app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">                app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义导航栏相对的Java类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">topGlobalNavigationBar</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TextView tvTitle;</span><br><span class="line">    <span class="keyword">private</span> View view;</span><br><span class="line">    <span class="keyword">private</span> TextView monthly_expenditure;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">topGlobalNavigationBar</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">topGlobalNavigationBar</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">topGlobalNavigationBar</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        view = inflate(context, R.layout.topnavigationbar, <span class="keyword">this</span>);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span></span>&#123;</span><br><span class="line">        tvTitle = view.findViewById(R.id.navigationbar_title);</span><br><span class="line">        monthly_expenditure = view.findViewById(R.id.monthly_expenditure);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTvTitle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String date = Utils.getDate();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        tvTitle.setText(date);</span><br><span class="line"></span><br><span class="line">        monthly_expenditure.setGravity(Gravity.START);</span><br><span class="line">        monthly_expenditure.setText(<span class="string">&quot;月支出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在MainActivity类中实现ActionBar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//        顶部自定义栏</span></span><br><span class="line">    topGlobalNavigationBar topGlobalNavigationBar = findViewById(R.id.topNavigation_bar);</span><br><span class="line">    topGlobalNavigationBar.setTvTitle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);<span class="comment">//设置透明导航栏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这就可以实现基本的导航栏。可以自行更改界面配置。</p></li></ol><h2 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h2><p>Toolbar在应用窗口的顶部提供的是一个固定的位置，可以随着页面改变而改变。</p><ol><li><p>先取消主题，在res/value/theme 中，改为NoActionBar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.LazyBookkeeping&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在active_main.xml中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;Toolbar</span><br><span class="line">         android:id=&quot;@+id/tool_bar&quot;</span><br><span class="line">         android:layout_width=&quot;match_parent&quot;</span><br><span class="line">         android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">         android:minHeight=&quot;?attr/actionBarSize&quot;</span><br><span class="line">         android:background=&quot;#FFFFFF&quot;</span><br><span class="line">         app:popupTheme=&quot;@menu/topbar&quot;</span><br><span class="line">         android:fitsSystemWindows=&quot;true&quot;&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/tool_bar_title&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:layout_gravity=&quot;center&quot;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">Toolbar</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在res/menu 创建menu文件。没有menu文件夹可以创建。这里没添加内容，可以自行添加。</p><p>[文档]: <a href="https://developer.android.com/guide/topics/ui/menus">https://developer.android.com/guide/topics/ui/menus</a>    “”文档””</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>MainActivity.java，记得调用init()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        toolbar = (Toolbar) findViewById(R.id.tool_bar);</span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line"></span><br><span class="line">        setTitle();</span><br><span class="line"></span><br><span class="line">        toolbar.inflateMenu(R.menu.topbar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO流</title>
      <link href="2021-07/Java-IO%E6%B5%81/"/>
      <url>2021-07/Java-IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><p>IO是指 Input  –  Output，即输入和输出，以内存为中心</p><p>input从外部读入数据到内存。output从内存输出到外部。</p><p>这些输入输出流的来源地和目的地可以是文件，也可以是网络连接，甚至是内存块。</p><p>其中Stream是进行处理字节的，而Reader和Writer是用来处理字符的，他们衍生的子类命名也都是以这些后缀结束的。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201119153701157.png" alt="image-20201119153701157"></p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="读字节-InputStream"><a href="#读字节-InputStream" class="headerlink" title="读字节 InputStream"></a>读字节 InputStream</h3><p>读（IputStream） 类有一个抽象方法，read()，这个方法读入一个字节，并返回读入的字节。或者在输入源结尾时返回-1。</p><p>一个读取操作如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用try finally</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    InputStream is =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用try resource</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算机系统中，我们打开了一个资源使用完了需要进行关闭。以便让操作系统把资源释放到，否则应用程序占用的资源会越来越多。</p><p>InputStream,OutputStream都是通过close关闭资源的。</p><p>在我们第一个代码中，我们看到 InputStream is = null;  然后在try里面进行了数据的读操作。但是如果读操作失败了。程序就会跳到finally中，如果我们没有对is进行不等于null的判断，那么就是is操作还没有完成就会被关闭掉。这是不正常的关闭。</p><p>而第二个代码块中，我们使用的是java 7之后支持的 try(resource) 的写法，只需要编写try语句，编译器就会为我们自动关闭资源。</p><blockquote><p>实际上，编译器并不会特别地为<code>InputStream</code>加上自动关闭。编译器只看<code>try(resource = ...)</code>中的对象是否实现了<code>java.lang.AutoCloseable</code>接口，如果实现了，就自动加上<code>finally</code>语句并调用<code>close()</code>方法。<code>InputStream</code>和<code>OutputStream</code>都实现了这个接口，因此，都可以用在<code>try(resource)</code>中。</p></blockquote><h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><p>在我们读取流的时候，一个一个读取并不是最高效的。大多数流支持一次性读取多个字节到缓冲区。InputStream支持读取多个字节填充到byte数据中。</p><ul><li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li><li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li></ul><p>利用上述方法一次读取多个字节时，需要先定义一个<code>byte[]</code>数组作为缓冲区，<code>read()</code>方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。<code>read()</code>方法的返回值不再是字节的<code>int</code>值，而是返回实际读取了多少个字节。如果返回<code>-1</code>，表示没有更多的数据了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BufferInputStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">//三个字节读一次</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写字节-OutputStream"><a href="#写字节-OutputStream" class="headerlink" title="写字节-OutputStream"></a>写字节-OutputStream</h3><p>OutputStream也是一个抽象类，抽象了write(int b)方法</p><p>要注意的是 int b虽然是int参数。但是每次写入还是只能写入一个字节。</p><p>OutputStream还定义了一个flush()方法，目的是将缓冲区中的内容输出到目的地。因为在写入数据的时候，处于效率的考虑，操作系统不是写入一个字节就发送一个字节。而是当缓冲区满了之后在发出去。而flush方法可以强制性的将缓冲区的内容发送到目的地。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次读入一个字节</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        os.write(<span class="number">10</span>);</span><br><span class="line">        os.write(<span class="number">108</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次读入多个字节</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        os.write(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>在InputStream和outputStream中，读写的操作是阻塞的。也就是说，这个线程在进行读取的时候，不能进行下面的操作，需要等到读写完毕之后，才能运行下面的语句。</p><h3 id="copy文件的实现"><a href="#copy文件的实现" class="headerlink" title="copy文件的实现"></a>copy文件的实现</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">copy</span>(<span class="params"><span class="built_in">String</span> path,<span class="built_in">String</span> copyPath</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">try</span>(<span class="params">InputStream is = <span class="keyword">new</span> FileInputStream(path)</span>)</span> &#123;</span><br><span class="line">        int len;</span><br><span class="line">        byte[] buf = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="function"><span class="title">try</span>(<span class="params">OutputStream os = <span class="keyword">new</span> FileOutputStream(copyPath)</span>)</span> &#123;</span><br><span class="line">                os.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Filter-组合输入-输出流过滤器"><a href="#Filter-组合输入-输出流过滤器" class="headerlink" title="Filter 组合输入/输出流过滤器"></a>Filter 组合输入/输出流过滤器</h2><p>DataInputStream只能读入数据类型，而FileInputStream可以提供在磁盘上读取文件的一个输入流。</p><p>其中DataInputStream不能进行读写磁盘，FileInputStream不能进行数值的读写。</p><p>但是Java使用了一种灵巧的机制可以将二者进行结合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream file = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(file);</span><br><span class="line"></span><br><span class="line">file.readInt(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这样的话FileInputStream基础智商高，可以附加额外的功能。</p><p>还可以使用这样的嵌套机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">    <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)));</span><br></pre></td></tr></table></figure><p>我们将DataInputStream放在构造器链的最后，是希望使用DataInputStream的read方法且带有缓冲机制。</p><h2 id="输入输出字符"><a href="#输入输出字符" class="headerlink" title="输入输出字符"></a>输入输出字符</h2><h3 id="输入-Reader"><a href="#输入-Reader" class="headerlink" title="输入-Reader"></a>输入-Reader</h3><p>Reader是Java Io库中的另外一个输入流。和InputStream的区别是，InputStream是byte为单位进行读取。而Reader是字符流，字符单位进行读取的(char);</p><p>使用时需要指定编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取单个字符</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReaderTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;test.txt&quot;</span>,StandardCharsets.UTF-<span class="number">8</span>))&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fileReader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取多个字符</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReaderTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;test.txt&quot;</span>),,StandardCharsets.UTF-<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = fileReader.read(chars))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(chars);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-Writer"><a href="#输出-Writer" class="headerlink" title="输出-Writer"></a>输出-Writer</h3><p>基本原理和输入流的概念相同===直接上例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(Writer w = <span class="keyword">new</span> FileWriter(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        w.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e )&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="copy文件的实现-1"><a href="#copy文件的实现-1" class="headerlink" title="copy文件的实现"></a>copy文件的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Reader r = <span class="keyword">new</span> FileReader(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = r.read(chars))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> (Writer w = <span class="keyword">new</span> FileWriter(<span class="string">&quot;test2.txt&quot;</span>))&#123;</span><br><span class="line">                w.write(chars,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓冲流-提高流的读取写入的速度"><a href="#缓冲流-提高流的读取写入的速度" class="headerlink" title="缓冲流-提高流的读取写入的速度"></a>缓冲流-提高流的读取写入的速度</h2><p>内部提供了一个缓冲区。增加读写速度。</p><p>使用用例：copy文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BufferStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)))&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(buf)) != -<span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">try</span> (BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>)))&#123;</span><br><span class="line">                bos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符流操作基本相同，不进行演示。</p><h2 id="IO转换流"><a href="#IO转换流" class="headerlink" title="IO转换流"></a>IO转换流</h2><p>属于字符流</p><p>inputStreamReader，将一个字节的输入流转换为字符的输入流</p><p>OutputStreamWriter，将一个字符的输出流转换为字节的输出流</p><p>inputStreamReader用例，用字节流读出文件，使用转换流进行转换并输出，其中用了嵌套调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InputStreamReaderTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStreamReader is = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(cbuf))!= -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(cbuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>outputStreamWriter用例，将字符文件读取出来，用另外一种编码方式，使用转换流进行编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputStreamWriterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStreamReader is = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)))&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(cbuf))!= -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> (OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>),<span class="string">&quot;gbk&quot;</span>))&#123;</span><br><span class="line">                osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标准输入输出流（了解）"><a href="#标准输入输出流（了解）" class="headerlink" title="标准输入输出流（了解）"></a>标准输入输出流（了解）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStreamReader is = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(is);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        String s = br.readLine();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equals(s)||<span class="string">&quot;exit&quot;</span>.equals(s))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;------finish------&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>DataInputStream，DataOutputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line">    dos.writeUTF(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">    dos.writeInt(<span class="number">1</span>);</span><br><span class="line">    dos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>ObjectInputStream，ObjectOutputStream，用于存储和读取<strong>基本数据类型数据</strong>或<strong>对象</strong>的处理流。可以吧Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p><ul><li><p>序列化：用ObjectOutputStream类<strong>保存</strong>基本类型数据或对象的机制</p></li><li><p>反序列化：用ObjectInputStream类<strong>读取</strong>基本类型数据或对象的机制</p></li></ul><p>ObjectOutputStream和ObjectInputStream不能序列化<strong>static</strong>和<strong>transient</strong>修饰的成员变量</p><ul><li><p>对象的序列化机制：允许吧内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久的保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其他程序获得了这个二进制流，就可以恢复成原来的Java对象</p></li><li><p>序列化的好处在于可将任何实现了Serializable接口的对象转换为字节数据，使其在保存和传输时可被还原。</p></li><li><p>要想某个类能够被序列化，需要实现序列化接口。加上序列端口号（serialVersionUID)</p><ul><li>必须加上serialVersionUID，如果没加上，在实例的时候会自动给serialVersionUID赋值，但是如果类的实例变量做了修改，serialVersionUID可能发生变化。</li><li>而且，除了本类需要序列化，类中的属性也必须都支持序列化</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ObjectOutputStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;object.dat&quot;</span>)))&#123;</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ObjectInputStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;object.dat&quot;</span>))) &#123;</span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        String str = (String) o;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h2><ul><li><p>直接继承与Object，实现了DataInput，DataOutput接口，既可以作为输入流，也可以作为输出流</p></li><li><p>如果RandomAccessFile类作为一个输出流，写出的文件不存在时，则在执行过程中自动创建。如果写出的文件存在，则会对原油文件内容覆盖，从头覆盖。</p></li></ul><p>方法</p><ul><li>seek(int x);  seek可以将指针调整到x的位置。</li></ul><p>文件的复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RandomAccessFile r1 = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    RandomAccessFile r2 = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test1.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = r1.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        r2.write(buf,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    r1.close();</span><br><span class="line">    r2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为了看起来方便所以没用使用try-catch-finally，实际使用中需要使用try-catch-finally</p><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>Java NIO（new IO)是从java1.4版本开始引入的新io api。与原有的io有同样的作用和目的。但是会有一些区别</p><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流(Stream Oriented)</td><td>面向缓冲区(Buffer Oriented)</td></tr><tr><td>阻塞IO(blocking IO)</td><td>非阻塞IO(Non Blocking IO)</td></tr><tr><td>无</td><td>选择器(Selectors)</td></tr></tbody></table><h2 id="通道和缓冲区"><a href="#通道和缓冲区" class="headerlink" title="通道和缓冲区"></a>通道和缓冲区</h2><p>通道（channel）负责传输，buffer（缓冲区）负责存储</p><p>核心在于，通道表示打开到IO设备的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。</p><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><ul><li><p>缓冲区(Buffer)：一个用于<strong>特定基本类型的容器</strong>。由java.nio包定义的。所有缓冲区都是Buffer抽象类的子类。</p></li><li><p>Java Nio中的Buffer主要用于与Nio通道进行交互，数据是从<strong>通道读入缓冲区</strong>，从<strong>缓冲区写入通道中</strong>的。</p></li></ul><ol><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ol><p>都采用相似的方法进行管理数据，只是各自管理的数据类型不同。</p><p>通过如下方法获取一个Buffer对象</p><p><strong>static xxxBuffer  allocate(int capacity); 创建一个容量为capacity的xxxBuffer对象</strong></p><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><ul><li>容量(Capacity)：表示Buffer最大数据容量，缓冲区容量不能为负，且创建后不能更改</li><li>限制(limit)：不应该被读取或写入的数据的索引，也就是说，位于limit后的数据不可读写，缓冲区的限制不能为负，并且不能大于其容量</li><li>位置(position):下一个要读写数据的索引，缓冲区的位置不能为负，并且不能大于其限制。</li><li>标记(mark)与重置(reset)：标记是一个索引，通过mark方法标记一个位置，通过reset可以回到这个位置。</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120143549483.png" alt="image-20201120143549483"></p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120143929945.png" alt="image-20201120143929945"></p><h4 id="缓冲区的数据操作"><a href="#缓冲区的数据操作" class="headerlink" title="缓冲区的数据操作"></a>缓冲区的数据操作</h4><p>Buffer所有子类提供了俩个用于数据操作的方法：get()与put()方法</p><ul><li>获取Buffer中的数据<ul><li>get()：获取单个字节</li><li>get(byte[] dst): 批量读取多个字节到dst中</li><li>get(int index)：读取指定索引位置的字节（不会移动position)</li></ul></li><li>放入数据到Buffer中<ul><li>​    put(byte b ); 将给定单个字节写入缓冲区的当前位置</li><li>put(byte[] src) 将src中的字节写入缓冲区的当前位置</li><li>put(int index, byte b) 将指定字节写入缓冲区的索引位置（不会移动position）</li></ul></li></ul><h2 id="直接缓冲区和非直接缓冲区"><a href="#直接缓冲区和非直接缓冲区" class="headerlink" title="直接缓冲区和非直接缓冲区"></a>直接缓冲区和非直接缓冲区</h2><ul><li>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则java虚拟机会尽最大努力直接在此缓冲区上执行本机I/O操作。也就是说，在每次调用基础操作系统的一个本机I/O操作之前 / 之后   ，虚拟机都会尽量避免缓冲区的内容复制到中间缓冲区中。（或从中间缓冲区复制内容）</li><li>直接字节缓冲区可以通过调用此类的<strong>allocateDirect()工厂方法</strong>来创建。此方法返回的<strong>缓冲区进行分配和取消分配所需成本通常 高于 非直接缓冲区</strong>。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，他们对应用程序的内存需求造成的影响可能不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机I/O操作影响的大型持久的缓冲区，一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显的好处时分配他们。</li><li>直接字节缓冲区还可以通过<strong>FileChannel的map()方法</strong>将文件区域直接映射到内存中来创建。该方法返回<strong>MappedByteBuffer</strong>。Java平台的实现有助于通过JNI从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。</li><li>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其isDirect()方法来确定。提供此方法为了能够在性能关键型代码中执行显式缓冲区管理。</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120192145057.png" alt="image-20201120192145057"></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120192154588.png" alt="image-20201120192154588"></p><h2 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h2><p>通道：由java.nio.channels包定义。表示io源与目标打开的连接。类似于传统的”流“。只不过不能直接访问数据，只能与buffer进行交互。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120194239570.png" alt="image-20201120194239570"></p><ul><li>FileChannel：用于读取，写入，映射和操作文件的通道</li><li>DatagramChannel：通过UDP读写网络中的数据通道</li><li>SocketChannel：通过Tcp读写网络中的数据</li><li>ServerSocketChannel：可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel</li></ul><h3 id="获取通道"><a href="#获取通道" class="headerlink" title="获取通道"></a>获取通道</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120194520338.png" alt="image-20201120194520338"></p><h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120194533240.png" alt="image-20201120194533240"></p><h2 id="分散（Scatter）聚集（Gather"><a href="#分散（Scatter）聚集（Gather" class="headerlink" title="分散（Scatter）聚集（Gather)"></a>分散（Scatter）聚集（Gather)</h2><p>分散是指一个channel的数据，分散到多个缓冲区。</p><p>聚集是指多个buffer聚集到一个channel中。</p><p>所有操作都需要try-catch，这里只是为了看的层次感。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分散读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ScatterAndGatherTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    FileChannel fisChannel = fis.getChannel();</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">    ByteBuffer buffer2 = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    ByteBuffer[] buffers = &#123;buffer1,buffer2&#125;;</span><br><span class="line">    fisChannel.read(buffers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分散读取</span></span><br><span class="line">    <span class="keyword">for</span> (ByteBuffer buffer : buffers) &#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//聚集写入</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line">    FileChannel fosChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">    fosChannel.write(buffers);</span><br><span class="line"></span><br><span class="line">    fis.close();</span><br><span class="line">    fisChannel.close();</span><br><span class="line">    fos.close();</span><br><span class="line">    fosChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TransferTo—-TransferFrom"><a href="#TransferTo—-TransferFrom" class="headerlink" title="TransferTo—-TransferFrom"></a>TransferTo—-TransferFrom</h2><p>将数据从源通道传输到其他Channel</p><h3 id="TransferFrom"><a href="#TransferFrom" class="headerlink" title="TransferFrom"></a>TransferFrom</h3><p>使用输出流的channel，from表示从哪里来，所以用输出流调用此方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransferFrom</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TransferFromTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FileChannel fisChannel = fis.getChannel();</span><br><span class="line">    FileChannel fosChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">    fosChannel.transferFrom(fisChannel,<span class="number">0</span>, fisChannel.size());</span><br><span class="line"></span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">    fisChannel.close();</span><br><span class="line">    fosChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="TransferTo"><a href="#TransferTo" class="headerlink" title="TransferTo"></a>TransferTo</h3><p>使用输入流channel调用，表示数据到哪里去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransferTo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TransferToTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FileChannel fisChannel = fis.getChannel();</span><br><span class="line">    FileChannel fosChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">    fisChannel.transferTo(<span class="number">0</span>, fisChannel.size(),fosChannel);</span><br><span class="line"></span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">    fisChannel.close();</span><br><span class="line">    fosChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FileChannel常用方法"><a href="#FileChannel常用方法" class="headerlink" title="FileChannel常用方法"></a>FileChannel常用方法</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120205445563.png" alt="image-20201120205445563"></p><h2 id="NIO非阻塞式网络通信"><a href="#NIO非阻塞式网络通信" class="headerlink" title="NIO非阻塞式网络通信"></a>NIO非阻塞式网络通信</h2><p>传统的IO流都是阻塞式的。而JavaNIO是非阻塞的。当线程从某同道进行读写数据时，若没有数据可同时，该线程可以进行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行Io操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO可以让服务器端使用一个或有限几个线程来同时处理连接到服务端的所有客户端。</p><h3 id="选择器Selector"><a href="#选择器Selector" class="headerlink" title="选择器Selector"></a>选择器Selector</h3><p>选择器（Selector） 是 SelectableChannle 对象的多路复用器，<strong>Selector 可以同时监控多个 SelectableChannel 的 IO 状况</strong>，也就是说，利用 <strong>Selector 可使一个单独的线程管理多个 Channel</strong>。Selector 是非阻塞 IO 的核心。</p><p>Selector结构</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201122135131145.png" alt="image-20201122135131145"></p><h3 id="Tcp模式的Selector非阻塞"><a href="#Tcp模式的Selector非阻塞" class="headerlink" title="Tcp模式的Selector非阻塞"></a>Tcp模式的Selector非阻塞</h3><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SocketChannel sChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9898</span>))) &#123;</span><br><span class="line">        <span class="comment">//设置非阻塞模式</span></span><br><span class="line">        sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            String s = sc.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;exit&quot;</span>.equals(s))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf.put(s.getBytes());</span><br><span class="line">            buf.flip();</span><br><span class="line">            sChannel.write(buf);</span><br><span class="line">            buf.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SocketChannel sChannel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> (ServerSocketChannel ssChannel = ServerSocketChannel.open())&#123;</span><br><span class="line"><span class="comment">//设置非阻塞模式</span></span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//绑定端口</span></span><br><span class="line">        ssChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line"><span class="comment">//获取选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"><span class="comment">//向选择器注册通道</span></span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否有选择器被注册</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select()&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//获取注册器的SelectedKeys迭代器</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                SelectionKey sk = it.next();</span><br><span class="line">                <span class="comment">//是否接受就绪</span></span><br><span class="line">                <span class="keyword">if</span> (sk.isAcceptable())&#123;</span><br><span class="line">                    sChannel = ssChannel.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    sChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//是否可读就绪</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sk.isReadable())&#123;</span><br><span class="line">                    sChannel = (SocketChannel)sk.channel();</span><br><span class="line">                    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                    ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((len = sChannel.read(buf))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        buf.flip();</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(buf.array(),<span class="number">0</span>,len));</span><br><span class="line">                        buf.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定</p><p>可以监听的事件类型（<strong>可使用</strong> <strong>SelectionKey</strong> <strong>的四个常量表示</strong>）：</p><ul><li><p> 读 : SelectionKey.OP_READ （1） </p></li><li><p> 写 : SelectionKey.OP_WRITE （4） </p></li><li><p> 连接 : SelectionKey.OP_CONNECT （8） </p></li><li><p> 接收 : SelectionKey.OP_ACCEPT （16） </p></li></ul><h4 id="Selector常用方法"><a href="#Selector常用方法" class="headerlink" title="Selector常用方法"></a>Selector常用方法</h4><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201122152338158.png" alt="image-20201122152338158"></p><h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p>连接到Tcp网络套接字的通道</p><p>操作步骤</p><ol><li>打开SocketChannel</li><li>读写数据</li><li>关闭SocketChannel</li></ol><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h4><ul><li><p>能发送Udp包的通道</p></li><li><p>操作步骤</p><ol><li>打开DatagramChannel</li><li>接受/发送数据</li></ol></li></ul><p>UDP基本和Tcp一样</p><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramChannel dc = DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">    dc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (scan.hasNext())&#123;</span><br><span class="line">        String s = scan.nextLine();</span><br><span class="line">        buf.put(s.getBytes());</span><br><span class="line"></span><br><span class="line">        buf.flip();</span><br><span class="line">        dc.send(buf,<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9898</span>));</span><br><span class="line">        buf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    dc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramChannel dc = DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">    dc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    dc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line"></span><br><span class="line">    Selector selector= Selector.open();</span><br><span class="line"></span><br><span class="line">    dc.register(selector,SelectionKey.OP_READ);</span><br><span class="line">    <span class="keyword">while</span> (selector.select()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            SelectionKey sk = it.next();</span><br><span class="line">            <span class="keyword">if</span> (sk.isReadable())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">                ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                dc.receive(buf);</span><br><span class="line">                buf.flip();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(buf.array(),<span class="number">0</span>,buf.limit()));</span><br><span class="line">                buf.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    dc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pipe（管道）"><a href="#Pipe（管道）" class="headerlink" title="Pipe（管道）"></a>Pipe（管道）</h2><p>管道是俩个线程之间的单向数据连接。Pipe有一个Source通道和一个Sink通道。</p><p>数据会被写入Sink通道，从Source通道接收读取</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201122152654073.png" alt="image-20201122152654073"></p><p>这里将sink和source放在一个方法中了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String s = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Pipe pipe = Pipe.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sink</span></span><br><span class="line">    Pipe.SinkChannel sink = pipe.sink();</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    buffer.put(s.getBytes());</span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">        sink.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//source</span></span><br><span class="line">    Pipe.SourceChannel source = pipe.source();</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    source.read(buffer1);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(buffer1.array(),<span class="number">0</span>,buffer1.limit()));</span><br><span class="line"></span><br><span class="line">    source.close();</span><br><span class="line">    sink.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7 安装python3.x</title>
      <link href="2021-01/Centos7-%E5%AE%89%E8%A3%85python3-x/"/>
      <url>2021-01/Centos7-%E5%AE%89%E8%A3%85python3-x/</url>
      
        <content type="html"><![CDATA[<p>Centos自带的是2.x的python，升级到3.x的版本</p><hr><p>下载python 官网地址:<a href="https://www.python.org/">https://www.python.org/</a></p><p>这里使用3.7版本的python</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#在Linux中运行</span><br><span class="line">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.7.3&#x2F;Python-3.7.3.tgz</span><br><span class="line"></span><br><span class="line">#解压 x.x.x是你的版本</span><br><span class="line">tar -xzvf Python-x.x.x.tgz </span><br><span class="line"></span><br><span class="line">#安装 其他python需要的包</span><br><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc  libffi-devel</span><br><span class="line"></span><br><span class="line">#编译安装 进入解压之后的python目录中</span><br><span class="line"># --prefix 指定安装位置</span><br><span class="line"># --enable-shared 共享库</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3.7 --enable-shared</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>make install之后 使用命令  echo $?</p><p>终端输出0就是没错。如果不是0就是有报错</p><p>没有报错的话。在/usr/local/ 中会有python3.7目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#安装完成之后</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><p><strong>备份系统自带的python2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv &#x2F;usr&#x2F;bin&#x2F;python &#x2F;usr&#x2F;bin&#x2F;python.bak</span><br></pre></td></tr></table></figure><p><strong>创建python3的软连接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python3.7&#x2F;bin&#x2F;python3.7 &#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"></span><br><span class="line">#检验一下 --如果是3.7版本就是成功了</span><br><span class="line">python -v</span><br></pre></td></tr></table></figure><p><strong>如果有报共享库错误，或者找不到xxx.lib文件</strong></p><h3 id="使用ldconfig命令"><a href="#使用ldconfig命令" class="headerlink" title="使用ldconfig命令"></a>使用ldconfig命令</h3><p>​    ldconfig /usr/local/python3.7/lib<br>​    即可</p><h3 id="因为python升级了，yum也需要改一下配置"><a href="#因为python升级了，yum也需要改一下配置" class="headerlink" title="因为python升级了，yum也需要改一下配置"></a>因为python升级了，yum也需要改一下配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;bin&#x2F;yum</span><br><span class="line">vim &#x2F;usr&#x2F;libexec&#x2F;urlgrabber-ext-down</span><br></pre></td></tr></table></figure><p>将开头的#/usr/bin/python 改为/usr/bin/python2</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言：指针</title>
      <link href="2021-01/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E6%8C%87%E9%92%88/"/>
      <url>2021-01/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习数据结构顺带记下。</p></blockquote><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针也可以理解为一个数据类型。指针类型，他不是一个具体的值，他保存的是一个地址。这个地址保存了其他的数据。（有点抽象）</p><p>可以这么理解。一个数组的下标就是地址。数组里面的值，才是保存的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *b = &amp;a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%d\n&quot;</span>,*b);</span><br><span class="line"></span><br><span class="line">    *b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%d\n&quot;</span>,*b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------输出结果——--------------</span><br><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="number">10</span></span><br><span class="line">a=<span class="number">20</span></span><br><span class="line">b=<span class="number">20</span></span><br></pre></td></tr></table></figure><p>可以看到，<em>b赋值20的时候，a也变为20了。\</em>b指向了a的地址。当改变b的值时，改变的是*b指向的地址那里的值。</p><ul><li><strong>“ &amp;（取址运算符）”:  取出变量的地址</strong></li><li>*<em>“ <em>+变量名 “ :  指针</em></em></li></ul><h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> temp)</span></span>&#123;</span><br><span class="line">    temp=<span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> *temp)</span></span>&#123;</span><br><span class="line">    temp=<span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    test1(a);</span><br><span class="line">    test2(&amp;b);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d&quot;</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line">--------------输出-------------</span><br><span class="line">a=<span class="number">10</span> b=<span class="number">999</span></span><br></pre></td></tr></table></figure><p>test1函数，并没有改变a的值。因为test1的temp是一个临时变量，改变的只是temp的值。</p><p>test2函数，是用指针来接收b的地址，修改了值之后，修改的是b位置的值。</p><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ary_set</span><span class="params">(<span class="keyword">int</span> v[],<span class="keyword">int</span> n ,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v[i]=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = a;</span><br><span class="line">    ary_set(&amp;a[<span class="number">2</span>],<span class="number">5</span>,<span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\na[%d] = %d  *(p+i)=%d&quot;</span>,i,a[i],*(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=========输出-=================</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>  *(p+i)=<span class="number">1</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span>  *(p+i)=<span class="number">2</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">99</span>  *(p+i)=<span class="number">99</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">99</span>  *(p+i)=<span class="number">99</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">99</span>  *(p+i)=<span class="number">99</span></span><br><span class="line">a[<span class="number">5</span>] = <span class="number">99</span>  *(p+i)=<span class="number">99</span></span><br><span class="line">a[<span class="number">6</span>] = <span class="number">99</span>  *(p+i)=<span class="number">99</span></span><br><span class="line">a[<span class="number">7</span>] = <span class="number">0</span>  *(p+i)=<span class="number">0</span></span><br></pre></td></tr></table></figure><ol><li>*p = a，指向 a[0]的地址  相当于  *p = &amp;a[0]。</li><li>p+1 = a[0+1]</li><li>思考：可以看到 数组只有5位，但是我们是从下标2开始赋值99，后面下标为6的值也为99。6已经超过了我们的数组长度。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Meta 的标签理解总结- Html</title>
      <link href="2021-01/Meta-%E7%9A%84%E6%A0%87%E7%AD%BE%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93-Html/"/>
      <url>2021-01/Meta-%E7%9A%84%E6%A0%87%E7%AD%BE%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93-Html/</url>
      
        <content type="html"><![CDATA[<p>这俩天在搜索自己博客的时候，发现只有自己网页显示的内容。但是看了一下别人网页的首页和我一样没什么信息。但是在搜索引擎搜索的时候却有很多没看到的信息显示在上面。于是看了一下网页的源代码。发现搜索引擎出来的数据都是在meta标签中。于是重新去看了一下html的meta标签。</p><p>在之前的理解中，meta只有这个作用</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attribute">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="MDN中"><a href="#MDN中" class="headerlink" title="MDN中"></a>MDN中</h2><blockquote><p><strong>HTML meta 元素</strong>表示那些不能由其它HTML元相关元素 (style, base, link, script, title)之一表示的任何元数据信息。</p></blockquote><p>其中 meta 中文名 也叫 元数据（Metadata)</p><hr><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><p>meta 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。</p><hr><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="必要属性"><a href="#必要属性" class="headerlink" title="必要属性"></a>必要属性</h3><p><a href="https://imgchr.com/i/dEPgun"><img src="https://s1.ax1x.com/2020/08/16/dEPgun.md.png" alt="dEPgun.md.png"></a></p><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p><a href="https://imgchr.com/i/dEP2Bq"><img src="https://s1.ax1x.com/2020/08/16/dEP2Bq.md.png" alt="dEP2Bq.md.png"></a></p><hr><h4 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h4><ol><li><p>application-name，定义运行在该网页上的网络应用名称</p><p>这个没试过，就不写例子了。防止耽误人。</p></li></ol><ol start="2"><li><p>author，这个网页的作者。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yvenxx&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>description，包含网页中的精简的描述，网站的主要内容是什么，其中Firefox和Opera，将其用作书签的描述。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yven的个人博客，写一写技术总结，存放一些个人作品&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>keywords，搜索引擎所提取网页关键字。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yven，博客，后端，java&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>rebots，定义搜索引擎蜘蛛的的索引方式。告诉它哪些要索引哪些不要索引（值有很多）</p><p>值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.index----允许蜘蛛索引页面,也就是索引此页面。</span><br><span class="line">2.noindex----防止蜘蛛索引该页面</span><br><span class="line">3.follow----允许蜘蛛通过此页面的链接。索引其他页面。</span><br><span class="line">4.nofollow----防止蜘蛛索引此页面上的链接。</span><br><span class="line">5.noodp----禁止将Open Directory Project的描述，用作搜索引擎结果页面中页面的描述</span><br><span class="line">6.noarchive----防止搜索引擎缓存页面的内容</span><br><span class="line">7.nocache----与noarchive相同。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;rebots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>viewport，提供有关视图的初始大小，但仅对移动设备生效。</p><p>值</p><p><a href="https://imgchr.com/i/dEPRH0"><img src="https://s1.ax1x.com/2020/08/16/dEPRH0.md.png" alt="dEPRH0.md.png"></a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>copyright，版权信息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;copyright&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yvenxx&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><p>revisit-after，设置蜘蛛重新访问的时间</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;revisit-after&quot;</span> <span class="attr">content</span>=<span class="string">&quot;2 days&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="http-equiv属性–特定的Http头部"><a href="#http-equiv属性–特定的Http头部" class="headerlink" title="http-equiv属性–特定的Http头部"></a>http-equiv属性–特定的Http头部</h4><ol><li><p>content-type ,使用这个属性，值必须是”<code>text/html; charset=utf-8</code>“。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span></span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>x-ua-compatible，如果指定内容属性值必须为 IE=edge</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x-ua-compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span>&gt;</span>//指定ie和chrome渲染当前页</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>refresh，指定网页自动载入页面的时间间隔。有俩种用法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1，如果content只包含一个正整数，就是重新载入网页的时间。</span><br><span class="line">2，如果content包含了一个正整数，外加 ;url=xxxxx 则是重定向到那个网页的间隔时间。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;2;url=http://yvenxx.cn&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中还有部分的属性没有提到，还没有完全的了解。把常用的一些属性总结在了里面。</p><p>如果文章有错误的地方，希望各位指正。感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
