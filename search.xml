<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构-时间复杂度的计算</title>
      <link href="2022/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
      <url>2022/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><strong>如果一个算法的执行次数是 T(n)，只保留最高次项，系数可以忽略，得到函数 f(n)。时间复杂度为 T(n)=O(f(n))</strong></p><ol><li><p>线性 O(n)阶</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    j=i;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>平方阶 O(n^2)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="comment">//xxxxxx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为每一次都要做n个循环，所以要n^2个循环  O(n^2)</p></li><li><p>对数阶O(logN)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">    i=i*<span class="number">2</span>;  <span class="comment">//重点是这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i=i*2，则有 2^i&lt;n，  可以得到执行次数  i=log2(n)。时间复杂度就为 log2(n)</p></li><li><p>nlog2(n)阶</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;n)&#123;</span><br><span class="line">        j=j*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意内层循环是  log2(n)，外存还有一层n阶，则复杂度是  n*log2(n)阶</p></li><li><p>O(2^n) </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> test(n<span class="number">-1</span>)+test(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个要先懂这个递归程序。读不懂的自行去看基础。</p><p>T(n) = T(n-1)+T(n-2)= T(n-2)+T(n-3)+T(n-3)+T(n-4)= T(n-2)+2T(n-3)+T(n-4)…，实际是一个二叉树，则复杂度是   2^n</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快排优化</title>
      <link href="2022/%E5%BF%AB%E6%8E%92%E4%BC%98%E5%8C%96/"/>
      <url>2022/%E5%BF%AB%E6%8E%92%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="快排优化"><a href="#快排优化" class="headerlink" title="快排优化"></a>快排优化</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/202205311035625.png" alt="img"></p><p>利用三数取中法找到枢纽值，并将枢纽值放置在左边第二个位置，然后将low指针指向这个位置，即图中第三列的8。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>程序的机器级代码表示</title>
      <link href="2022/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA/"/>
      <url>2022/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="程序的机器级代码表示"><a href="#程序的机器级代码表示" class="headerlink" title="程序的机器级代码表示"></a>程序的机器级代码表示</h1><p>22 408考纲新增内容</p><h3 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a><strong>相关寄存器</strong></h3><p>这里高低两位 0-7，8-15，分别还可以作为两个8位寄存器，具体看表</p><table><thead><tr><th>16bit(高15-8，低7-0)</th><th>32bit</th><th>说明</th></tr></thead><tbody><tr><td>AX (AH,AL)</td><td>EAX</td><td>累加器（Accumulator）</td></tr><tr><td>BX (BH,BL)</td><td>EBX</td><td>基地址寄存器（Base Register）</td></tr><tr><td>CX (CH,CL)</td><td>ECX</td><td>计数寄存器（Count Register）</td></tr><tr><td>DX (DH,DL)</td><td>EDX</td><td>数据寄存器（Data Register）</td></tr><tr><td></td><td>ESI</td><td>变址寄存器（Index Register）</td></tr><tr><td></td><td>EDI</td><td>变址寄存器</td></tr><tr><td></td><td>EBP</td><td>堆栈 基 指针 （Base Pointer）</td></tr><tr><td></td><td>ESP</td><td>堆栈 顶 指针（Stack Pointer）</td></tr></tbody></table><h3 id="汇编指令格式"><a href="#汇编指令格式" class="headerlink" title="汇编指令格式"></a>汇编指令格式</h3><table><thead><tr><th>AT&amp;T</th><th>Intel</th></tr></thead><tbody><tr><td>只能小写字母</td><td>大小写不敏感</td></tr><tr><td><strong>第一个为源操作数，第二个目的操作数</strong></td><td><strong>目的操作数，源操作数</strong></td></tr><tr><td>寄存器前缀 %，立即数前缀 $</td><td>都不需要前缀</td></tr><tr><td>内存寻址格式 ()</td><td>[ ]</td></tr><tr><td>复杂寻址 disp(base,index,scale) 分别 偏移量，基址寄存器，变址寄存器 比例因子。例 8(%edx , %eax, 2)</td><td>[edx+eax*2+8]</td></tr><tr><td>数据长度  操作码的后面紧跟一个字符表明操作数大小 b(byte) w(word) l(long)</td><td>byte ptr, word ptr ,dword ptr</td></tr><tr><td>举例 mov $100, %eax</td><td>mov eax,100</td></tr></tbody></table><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ul><li>&lt;reg&gt;：表示寄存器 , &lt;reg32&gt;表示32位的寄存器(eax,ebx…..)</li><li>&lt;mem&gt;：表示内存地址（[eax], [var+4], dword ptr [eax+ebx]）</li><li>&lt;con&gt;：表示8，16，32位常数 ,  &lt;con32&gt;表示32位常数</li></ul><p><strong>数据传送指令</strong></p><p>这里用intel格式来表示指令</p><ul><li>mov x1,x2。将x2复制到x1。源(x2)可以取内存，寄存器，常数值。放到x1的 内存或寄存器（不能直接内存到内存）</li><li>push x1,将x1压入内存的栈，ESP栈顶减4</li><li>pop x1 ，出栈，ESP+4</li></ul><p><strong>算数和逻辑运算指令</strong></p><ul><li>add/sub x1,x2，将x2和x1加减，数据放到x1中。</li><li>inc/dec x1 ，分别表示自加，自减</li><li>imul x1,x2，带符号乘法，将结果保存在第一个操作数，且第一个操作数必须是寄存器。若是三个操作数x1,x2,x3就将x3,x2相乘放到x1</li><li>idiv x1，只有一个除数，被除数放在 edx:eax(64位整数)，操作结果两部分，商送到eax，余数送到edx</li><li>and/or/xor x1,x2，与，或，异或，操作结果放在x1</li><li>not x1, 取非</li><li>neg x1 ，取负 neg eax= -eax</li><li>shl/shr x1,x2 , 逻辑左移和右移，x1是被操作的数，x2(&lt;con&gt; , &lt;cl&gt;) 是常数，表示被移的位数</li></ul><p><strong>控制流指令</strong></p><ul><li>jmp &lt;labe&gt; ：程序跳转指令</li><li>jcondition 条件转移指令<ul><li>je &lt;label&gt;   jump when equal</li><li>jne &lt;label&gt;   jump when not equal</li><li>jz &lt;label&gt; jump when last result was zero</li><li>jg &lt;label&gt; jump when greater than</li><li>jge &lt;label&gt; jump when greater than or equal to</li><li>jl &lt;label&gt; jump when less than</li><li>jle &lt;label&gt; jump when less than or equal to</li></ul></li><li>cmp/test ： cmp用于比较两个操作数的值，test指令对两个操作数进行逐位相与     <ul><li>cmo &lt;reg&gt;,&lt;mem&gt;      test &lt;reg&gt;,&lt;con&gt;</li></ul></li><li>call/ret：实现子程序的调用及返回<ul><li>call &lt;label&gt;</li><li>ret</li></ul></li></ul><h3 id="过程调用的机器级表示"><a href="#过程调用的机器级表示" class="headerlink" title="过程调用的机器级表示"></a>过程调用的机器级表示</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/202205092134875.png" alt="image-20220509213447726"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/202205092135010.png" alt="image-20220509213501947"></p><p>对应汇编代码为</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/202205092135994.png" alt="image-20220509213518864"></p><h3 id="选择语句的机器级表示"><a href="#选择语句的机器级表示" class="headerlink" title="选择语句的机器级表示"></a>选择语句的机器级表示</h3><p><strong>条件码</strong></p><p>CF：进（借）位标志。最近的无符号整数加减的进位结果。有进位1，无进位0</p><p>ZF：零标志。最近的操作是否为0，若为0。则为1</p><p>SF：符号标志。最近的带符号运算结果的符号</p><p>OF：溢出标志。最近的带符号运算结果是否溢出。溢出OF=1</p><p><strong>IF语句</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_cont</span><span class="params">(<span class="keyword">int</span> *p1,<span class="keyword">int</span> *p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p1&gt;p2)</span><br><span class="line">        <span class="keyword">return</span> *p2;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> *p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应汇编</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/202205092140791.png" alt="image-20220509214025696"></p><p><strong>switch语句</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/202205092140073.png" alt="image-20220509214057960"></p><h3 id="循环语句的机器级表示"><a href="#循环语句的机器级表示" class="headerlink" title="循环语句的机器级表示"></a>循环语句的机器级表示</h3><p><strong>do-while</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    body_statement;</span><br><span class="line">    <span class="keyword">while</span>(test_expr);</span><br></pre></td></tr></table></figure><p>goto语句形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">body_statement;</span><br><span class="line">t=test_expr;</span><br><span class="line"><span class="keyword">if</span>(t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure><p><strong>while</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(test_expr)</span><br><span class="line">    body_statement;</span><br></pre></td></tr></table></figure><p>goto形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t=test_expr;</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        body_statement</span><br><span class="line">        <span class="keyword">while</span>(test_expr);</span><br><span class="line">done;</span><br></pre></td></tr></table></figure><p><strong>for</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(init_expr; test_expr; update_expr)</span><br><span class="line">    body_statement;</span><br><span class="line"><span class="comment">//与下面while一样</span></span><br><span class="line">init_expr;</span><br><span class="line"><span class="keyword">while</span>(test_expr)&#123;</span><br><span class="line">    body_statement;</span><br><span class="line">    update_expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>goto形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">init_expr;</span><br><span class="line">t=test_expr;</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loop:</span><br><span class="line">body_statement;</span><br><span class="line">update_expr;</span><br><span class="line">t=test_expr;</span><br><span class="line"><span class="keyword">if</span>(t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><p>for循环求和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nsum_for</span><span class="params">(<span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">result+=i;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/202205092149262.png" alt="image-20220509214911113"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML+CSS</title>
      <link href="2022/HTML-CSS/"/>
      <url>2022/HTML-CSS/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>笔记注意事项：</p><p>所有的可选值不一定都写了，需要查文档</p></blockquote><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="Meta"><a href="#Meta" class="headerlink" title="Meta"></a>Meta</h3><h4 id="在MDN中"><a href="#在MDN中" class="headerlink" title="在MDN中"></a>在MDN中</h4><blockquote><p><strong>HTML meta 元素</strong>表示那些不能由其它HTML元相关元素 (style, base, link, script, title)之一表示的任何元数据信息。</p></blockquote><p>其中 meta 中文名 也叫 元数据（Metadata)</p><hr><h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><p>meta 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。</p><hr><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><h5 id="必要属性"><a href="#必要属性" class="headerlink" title="必要属性"></a>必要属性</h5><p><a href="https://imgchr.com/i/dEPgun"><img src="https://s1.ax1x.com/2020/08/16/dEPgun.md.png" alt="dEPgun.md.png"></a></p><h5 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h5><p><a href="https://imgchr.com/i/dEP2Bq"><img src="https://s1.ax1x.com/2020/08/16/dEP2Bq.md.png" alt="dEP2Bq.md.png"></a></p><hr><h5 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h5><ol><li><p>application-name，定义运行在该网页上的网络应用名称</p><p>这个没试过，就不写例子了。防止耽误人。</p></li></ol><ol start="2"><li><p>author，这个网页的作者。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yvenxx&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>description，包含网页中的精简的描述，网站的主要内容是什么，其中Firefox和Opera，将其用作书签的描述。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yven的个人博客，写一写技术总结，存放一些个人作品&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>keywords，搜索引擎所提取网页关键字。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yven，博客，后端，java&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>rebots，定义搜索引擎蜘蛛的的索引方式。告诉它哪些要索引哪些不要索引（值有很多）</p><p>值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.index----允许蜘蛛索引页面,也就是索引此页面。</span><br><span class="line">2.noindex----防止蜘蛛索引该页面</span><br><span class="line">3.follow----允许蜘蛛通过此页面的链接。索引其他页面。</span><br><span class="line">4.nofollow----防止蜘蛛索引此页面上的链接。</span><br><span class="line">5.noodp----禁止将Open Directory Project的描述，用作搜索引擎结果页面中页面的描述</span><br><span class="line">6.noarchive----防止搜索引擎缓存页面的内容</span><br><span class="line">7.nocache----与noarchive相同。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;rebots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>viewport，提供有关视图的初始大小，但仅对移动设备生效。</p><p>值</p><p><a href="https://imgchr.com/i/dEPRH0"><img src="https://s1.ax1x.com/2020/08/16/dEPRH0.md.png" alt="dEPRH0.md.png"></a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>copyright，版权信息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;copyright&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yvenxx&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>revisit-after，设置蜘蛛重新访问的时间</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;revisit-after&quot;</span> <span class="attr">content</span>=<span class="string">&quot;2 days&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="http-equiv属性–特定的Http头部"><a href="#http-equiv属性–特定的Http头部" class="headerlink" title="http-equiv属性–特定的Http头部"></a>http-equiv属性–特定的Http头部</h5><ol><li><p>content-type ,使用这个属性，值必须是”<code>text/html; charset=utf-8</code>“。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span></span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>x-ua-compatible，如果指定内容属性值必须为 IE=edge</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x-ua-compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span>&gt;</span>//指定ie和chrome渲染当前页</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>refresh，指定网页自动载入页面的时间间隔。有俩种用法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1，如果content只包含一个正整数，就是重新载入网页的时间。</span><br><span class="line">2，如果content包含了一个正整数，外加 ;url=xxxxx 则是重定向到那个网页的间隔时间。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;2;url=http://yvenxx.cn&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中还有部分的属性没有提到，还没有完全的了解。把常用的一些属性总结在了里面。</p><h3 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h3><p>_blank：创建一个新的标签页跳转</p><p>_self：当前页跳转</p><p>跳转特定位置，利用id属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>跳转p2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p2&quot;</span>&gt;</span></span><br><span class="line">    1231231232</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h3><p><strong>音频(audio)</strong></p><p>controls ：允许用户控制组件，如果没有这个，网页里面没有显示</p><p>autoplay：自动播放，大部分浏览器不会对其自动播放</p><p>loop：循环播放</p><p>更多的属性查文档</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;.....&quot;</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line">//浏览器不支持时可以用下面的方法</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    如果浏览器不支持这里会显示文字</span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;.....&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>视频(video)</strong>    用法一样</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>table</p><ul><li>tr表示表格中的一行</li><li>td 在tr中表示一个单元格</li></ul><p>属性 td</p><ul><li>colspan，横向合并</li><li>rowspan，纵向合并</li></ul><p>th表示头部的单元格</p><p>可以将一个表格分成三个部分，里面还是tr td</p><ul><li>头部thead</li><li>主体tbody</li><li>底部tfoot</li></ul><h4 id="css设置"><a href="#css设置" class="headerlink" title="css设置"></a>css设置</h4><p>border-collapse : collapse  设置边框的合并 </p><p>border-spacing: 1px 设置边框之间的距离</p><p>特殊的 td 可以用 vertical-aligh直接设置内部元素的位置</p><p>利用这个可以做到其他的box进行垂直居中，然后子元素设置一个水平居中就可以实现垂直水平居中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box1</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line">        // 将元素设置为单元格 td</span><br><span class="line"><span class="css">        <span class="selector-tag">display</span><span class="selector-pseudo">:table-cell</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">vertical-align</span><span class="selector-pseudo">:middle</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.box2</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span><span class="selector-pseudo">:yellow</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">margin</span><span class="selector-pseudo">:0</span> <span class="selector-tag">auto</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>form属性</p><ul><li>action: 表单要提交的服务器地址</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>&quot;<span class="attr">xx</span>&quot;&gt;</span></span><br><span class="line">    文本框<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码框<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    单选按钮 checked 默认值</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span>男</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span> <span class="attr">checked</span>&gt;</span>女</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    多选框</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    下拉列表  selected默认</span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;xxxx&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">selected</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p><strong>基本</strong></p><p>外部样式表引用 style.css</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;路径/style.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><h5 id="元素–关系-选择器"><a href="#元素–关系-选择器" class="headerlink" title="元素–关系 选择器"></a>元素–关系 选择器</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">p&#123;</span><br><span class="line">    color:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// id只能一个标签使用 </span><br><span class="line">#id&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">// class可以多个元素使用 </span><br><span class="line">.class&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 所有元素都选中</span><br><span class="line">*&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 交集选择器：必须同时满足这些条件，才会被选中 </span><br><span class="line">.class1.class2 &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;class1 class2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 中间有个逗号，并集选择器 满足其中一个就可以用</span><br><span class="line">.a,.b&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//父子元素---祖先元素可能有多个，父元素只有一个。同样子元素和后代元素差不多的概念，兄弟元素就是在一个父元素下面的同等级的</span><br><span class="line"></span><br><span class="line">// 只要是div的子元素span都使用</span><br><span class="line">div &gt; span&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//div class为box 的子元素 span 才被选中</span><br><span class="line">div.box &gt; span &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 后代不需要 &gt; 号  直接空格即可</span><br><span class="line"></span><br><span class="line">div span&#123;</span><br><span class="line">&#125;</span><br><span class="line">div.box span&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//兄弟元素</span><br><span class="line">//找p元素紧挨着的下一个兄弟span</span><br><span class="line">P+span&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//选择下边所有的兄弟span</span><br><span class="line">p~span&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// [属性名]  选择含有指定属性的元素</span><br><span class="line">// [属性名=属性值]  选择含有指定属性和属性值的元素</span><br><span class="line">// [属性名^=属性值]  选择属性值以指定值开头的元素</span><br><span class="line">// [属性名$=属性值]  选择属性值以指定值结尾的元素</span><br><span class="line">// [属性名*=属性值]  选择属性值含有某值的元素</span><br><span class="line"></span><br><span class="line">p[title]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h5><p>一般使用 :  开头</p><p>不存在的类，特殊的类。描述元素的特殊状态。</p><p>Ex : 第一个元素，被点击的元素，鼠标碰到的元素…..</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//第一个子元素，所有元素的第一个才可以，如果li前面有其他元素，则不生效。first-of-type找同类型里的第一个元素。</span><br><span class="line">ul&gt;li:first-child&#123;</span><br><span class="line">&#125;</span><br><span class="line">//最后</span><br><span class="line">ul&gt;li:last-child&#123;</span><br><span class="line">&#125;</span><br><span class="line">// 选中第 x 个子元素，若写n则是选全部，2n则是选偶数</span><br><span class="line">ul&gt;li:nth-child(  3  )&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//a 类专属 , link标识正常的链接，visited表示访问过的链接（只能改颜色）</span><br><span class="line">a:link&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//hover 表示鼠标移入的状态</span><br><span class="line">//active 表示鼠标点击状态</span><br><span class="line">a:hover&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><p>表示页面中特殊的并不真实存在的元素（特殊的位置）</p><p>使用 ::  开头</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 第一个字母的样式</span><br><span class="line">p::first-letter&#123;</span><br><span class="line">&#125;</span><br><span class="line">//给选中的内容设置样式</span><br><span class="line">p::selection&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// before，after，在前面后面通过css content加内容</span><br><span class="line">p::berfore</span><br><span class="line">content: &#x27;abc&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承和权重"><a href="#继承和权重" class="headerlink" title="继承和权重"></a>继承和权重</h4><p>继承：祖先类的一些属性 ，后代元素可以继承。但是子元素有自己的属性的时候会覆盖。也就是下面的权重问题</p><p>权重 ： 内联 &gt; id &gt; class &gt; 通配符 &gt; 继承</p><h4 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h4><ul><li><p>像素( px )</p></li><li><p>百分比( % )</p></li><li><p>em：相对于元素的字体大小来计算</p><p>1em = 1 font-size，根据自己里面的字体大小</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//这里 1em = 1.6px</span><br><span class="line">.box2&#123;</span><br><span class="line">font-size:16px;</span><br><span class="line">width:10em;</span><br><span class="line">height:10em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>rem 相对于根元素的字体大小来计算</p></li></ul><h4 id="RGB—HSL"><a href="#RGB—HSL" class="headerlink" title="RGB—HSL"></a>RGB—HSL</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//RGB</span><br><span class="line">//前面三个是rgb的颜色值，第四个 1 表示完全不透明，0表示透明，0-1可以自己设置值</span><br><span class="line">p&#123;</span><br><span class="line">color:rgb(255,255,255,0);</span><br><span class="line">//或者16进制</span><br><span class="line">color:#aaffbb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//<span class="selector-tag">HSL</span>,<span class="selector-tag">H</span>色相(0<span class="selector-tag">-360</span>)，<span class="selector-tag">S</span>饱和度(0<span class="selector-tag">-100</span>%)，<span class="selector-tag">L</span>亮度(0<span class="selector-tag">-100</span>%)</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:<span class="built_in">HSL</span>(<span class="number">0</span>,<span class="number">100%</span>,<span class="number">34%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><h4 id="文档流-normal-flow"><a href="#文档流-normal-flow" class="headerlink" title="文档流(normal flow)"></a>文档流(normal flow)</h4><p>网页是一个多层结构，一层叠着一层。作为用户只能看到最顶上一层。</p><p>最底下一层称为文档流，文档流是网页的基础，我们所创建的元素默认都是在文档流中进行排列</p><p>元素分为  在文档流，不在文档流</p><p><strong>文档流特点</strong></p><ul><li>块元素<ul><li>块元素会在页面中独占一行</li><li>默认宽度是父元素的全部</li><li>默认高度被内容撑开</li></ul></li><li>行内元素<ul><li>不会独占一行，只占自身大小</li></ul></li></ul><h4 id="盒子模型-box-model"><a href="#盒子模型-box-model" class="headerlink" title="盒子模型(box model)"></a>盒子模型(box model)</h4><p>任何有方向的顺序都是：上右下左</p><p>一个盒子的可见框大小，由内容区，内边距和边框共同决定</p><p>border，padding差不多用法，还有outline和border差不多</p><p>但是online不影响元素大小，outline不会影响元素布局（不会改变box大小）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//<span class="selector-tag">border-width</span>,<span class="selector-tag">border-style</span>,<span class="selector-tag">border-color</span>,</span><br><span class="line">//或者直接使用<span class="selector-tag">border</span><span class="selector-pseudo">:x</span> <span class="selector-tag">x</span> <span class="selector-tag">x</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="盒子的尺寸"><a href="#盒子的尺寸" class="headerlink" title="盒子的尺寸"></a>盒子的尺寸</h5><p>box-sizing：用来设置盒子尺寸的计算方式（设置w和h的作用）</p><p>content-box：默认值，h和w用来设置内容区大小</p><p>border-box：w和h用来设置整个盒子可见区大小：padding+border+content</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h5><p>margin 不会影响盒子可见框大小，会影响盒子的位置</p><ul><li>可以设置负值，向相反方向移动</li><li>top,left移动自己，right,bottom挤其他盒子。</li><li>默认情况下margin right不会产生任何效果</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>box-shadow</p><p>用来设置元素的阴影效果，阴影不会影响页面布局</p><p>三个参数</p><ul><li>左侧偏移量：设置阴影的水平位置，正值向右移动，负值向左移动</li><li>垂直偏移量：设置阴影的垂直位置，正值向下，负值向上</li><li>阴影模糊半径（虚化）</li><li>阴影颜色</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>border-radius,还可以设置单个的 </p><p>border-top-left-radius , border-top-right-radius…..</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//两个半径 前面水平，后面垂直</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">border-top-left-radius</span>:<span class="number">50px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line">//四个值  左上  右上  右下  左下</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span> <span class="number">20px</span> <span class="number">30px</span> <span class="number">40px</span>;</span><br><span class="line">    border-radius:10px / 20px;   //水平，垂直，中间 / 隔开</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="水平方向布局"><a href="#水平方向布局" class="headerlink" title="水平方向布局"></a>水平方向布局</h4><p><strong>重要</strong></p><p>一个盒子水平方向是由</p><p>padding-left,right，margin-left,right，border-left,right，width组成</p><p>且要满足他们相加等于父元素的内容区水平大小，如果比父元素内容区小，则会利用auto的属性补起来。如果都没有auto属性，则用margin-right来进行补齐。<strong>称为过度约束</strong></p><p>如果超过了大小则margin-right取负值</p><blockquote><p>默认情况下width不设置就为auto。</p></blockquote><h4 id="垂直方向布局"><a href="#垂直方向布局" class="headerlink" title="垂直方向布局"></a>垂直方向布局</h4><p>垂直方向没有水平布局的补齐，则该为多少就是多少。</p><blockquote><p>同样会有溢出的问题，子元素比父元素高，则会有溢出</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line"> heitht100px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line"> <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h5 id="overflow解决"><a href="#overflow解决" class="headerlink" title="overflow解决"></a>overflow解决</h5><p>放在父元素中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">overflow</span>:auto</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">auto</span>：根据需要生成滚动条</span><br><span class="line"><span class="selector-tag">visible</span>:默认</span><br><span class="line"><span class="selector-tag">scroll</span>:生成两个滚动条</span><br><span class="line"><span class="selector-tag">hidden</span>：溢出内容会被裁剪，不显示</span><br><span class="line">具体查看文档</span><br></pre></td></tr></table></figure><h4 id="垂直外边距的折叠"><a href="#垂直外边距的折叠" class="headerlink" title="垂直外边距的折叠"></a>垂直外边距的折叠</h4><p>相邻的垂直方向外边距会发生重叠现象</p><ul><li><p>兄弟元素</p><ul><li><p>兄弟元素间的相邻垂直外边距会取两者之间较大的值（正值的情况）</p></li><li><p>特殊情况</p><p>如果相邻的外边距一正一负，则取两者的和</p><p>如果相邻的外边距都是负值，则取两者的绝对值最大值</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span>&#123;</span><br><span class="line">    margin-top:200px;//会取200的这个</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>父子元素</p><p>解决重叠问题，和高度塌陷问题</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,<span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>:table;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="行内元素的盒模型"><a href="#行内元素的盒模型" class="headerlink" title="行内元素的盒模型"></a>行内元素的盒模型</h4><p>行内元素不能设置宽度高度。其他的可以设置，且不会影响布局</p><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><p>设置元素显示的类型</p><ul><li><p>inline将元素设置为行内元素</p></li><li><p>block 将元素设置为块元素</p></li><li><p>inline-block 将元素设置为行内块元素</p></li><li><p>table 将元素设置为一个表格</p></li><li><p>none 元素不在页面中显示</p><p>none和visibility的属性有区别，区别在于none就是直接没了，不占据位置，visibility设置为hidden，位置会占据位置。</p></li></ul><h4 id="浏览器默认样式"><a href="#浏览器默认样式" class="headerlink" title="浏览器默认样式"></a>浏览器默认样式</h4><p>清除—清不干净，可以找一个清除默认样式齐全的，链接即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span>&#123;</span><br><span class="line">    <span class="attribute">list-style</span>:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p>通过浮动使一个元素向其父元素的左侧或右侧移动</p><ul><li>none</li><li>left</li><li>right</li></ul><p>设置float之后，强制元素补齐就失效</p><p>特点</p><ul><li>浮动元素会脱离文档流，不再占据文档流中的位置</li><li>设置浮动以后，元素会向父元素的左侧或右侧移动</li><li>浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围</li></ul><p>脱离文档流的特点</p><ul><li><p>块元素</p><ul><li>块元素不再独占页面的一行</li><li>块元素宽度和高度默认都被内容撑开</li></ul></li><li><p>行内元素</p><p>行内元素脱离文档流以后会变成块元素，特点和块元素一样</p></li></ul><h4 id="高度塌陷问题"><a href="#高度塌陷问题" class="headerlink" title="高度塌陷问题"></a>高度塌陷问题</h4><p>在浮动布局中，父元素的高度默认（auto）是被子元素撑开的。当子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离。就无法撑起父元素的高度，导致父元素的高度丢失。</p><p>如果父元素直接固定高度不会出这个问题，但常常不会这么做。</p><h4 id="BFC解决"><a href="#BFC解决" class="headerlink" title="BFC解决"></a>BFC解决</h4><p>Block Formatting Context  块级格式化环境</p><p>BFC是一个CSS中的一个隐含的属性，可以为一个元素开启BFC。开启BFC后，该元素会变成一个独立的布局区域。</p><p>元素开启BFC后的特点</p><ol><li>开启BFC的元素不会被浮动元素所覆盖</li><li>开启BFC的元素，子元素和父元素外边距不会重叠</li><li>开启BFC的元素可以包含浮动的子元素</li></ol><p>开启BFC有很多方式，这里只写其中一种影响最小的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span>&#123;</span><br><span class="line">    <span class="attribute">overflow</span>:hidden/auto</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="clear解决"><a href="#clear解决" class="headerlink" title="clear解决"></a>clear解决</h4><ul><li>left</li><li>right</li><li>both：清除两侧中最大影响的元素</li></ul><p>原理设置清除浮动以后，浏览器会自动为元素添加一个上外边距，以使其位置不受其元素的影响</p><h4 id="after"><a href="#after" class="headerlink" title="::after"></a>::after</h4><p>利用 ::after来解决（无副作用）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.father</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="attribute">display</span>:block;</span><br><span class="line"><span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line"><span class="attribute">float</span>:left;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最终解决"><a href="#最终解决" class="headerlink" title="最终解决"></a>最终解决</h4><p><strong>解决高度塌陷和垂直重叠问题</strong>—–所有问题用这个解决</p><p>把这个类放到父元素中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,<span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>:table;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><ul><li><p>static：默认，不开启定位</p></li><li><p><strong>relative</strong>：开启元素的相对定位</p><ul><li><p>元素开启相对定位之后，如果不设置偏移量(offset)，元素不会发生变化。</p></li><li><p>相对定位的参考点，是元素没有进行偏移时，左上角的点</p></li><li><p>相对定位会提升元素的层级</p></li><li><p>相对定位不会使元素脱离文档流</p></li><li><p>相对定位不会改变元素的性质。块和行内不变</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//<span class="selector-tag">top</span> <span class="selector-tag">right</span> <span class="selector-tag">left</span> <span class="selector-tag">bottom</span></span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;   </span><br><span class="line">    <span class="attribute">right</span>:<span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>absolute</strong>：开启元素的绝对定位</p><ul><li><p>如果不设置偏移量，位置不变</p></li><li><p>开启绝对定位后，元素会从文档流中脱离</p></li><li><p>绝对定位会改变元素的性质，行内变成块，块的宽高被内容撑开</p></li><li><p>会使元素提升一个层级</p></li><li><p>绝对定位元素是相对于其包含块元素进行定位</p><ul><li><p>包含块</p><p>正常情况下，包含块就是当前元素最近的祖先块元素</p><p><strong>绝对定位的情况下，包含块就是离他最近的，开启了定位的，祖先块元素</strong>。如果所有祖先元素都没有开启定位，则根元素就是他的包含块。定位点在其左上角</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//<span class="selector-tag">top</span> <span class="selector-tag">right</span> <span class="selector-tag">left</span> <span class="selector-tag">bottom</span></span><br><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line"> <span class="attribute">position</span>:absolute;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>fixed</strong>：开启元素的固定定位</p><p>也是一种绝对定位，固定定位的大部分特点都和绝对定位一样</p><ul><li><p><strong>唯一不同的是，固定定位永远参照于浏览器的视口进行定位。</strong>浏览器的可视窗口（左上角）。</p></li><li><p>固定定位的元素不会随网页的滚动而改变。永远在那个地方不动。</p></li></ul></li><li><p><strong>sticky</strong>：开启元素的粘滞定位</p><p>和相对定位的特点基本一致</p><ul><li><p>不同的是粘滞定位可以在元素到一定的位置时，将其固定。</p><p>例如导航条，在我们滚动时，到最顶上不会滚动，而会一直显示在上方</p></li></ul></li></ul><h4 id="绝对定位的补充"><a href="#绝对定位的补充" class="headerlink" title="绝对定位的补充"></a>绝对定位的补充</h4><p>left + margin,padding,border-left + width + margin,padding,border-right  + right = 包含区的宽度</p><p>过度约束：添加了left 和right 其余还是和之前的相同。</p><p>left和right默认有auto，如果不设置的话，想要居中必须left和right设为0</p><p>有了绝对定位后，垂直方向也布局必须满足等式</p><p>top+margin,padding,border-top+ height + m,p,b-bottom + bottom=包含区的高度。</p><p>可以利用这个效果实现垂直水平居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="元素的层级"><a href="#元素的层级" class="headerlink" title="元素的层级"></a>元素的层级</h4><p>假设这样的情况，三个块都开启绝对定位，他们的层级都会发生改变，那么如果他们覆盖在一起，他们的优先级不同，优先显示的块也不同。</p><p>利用z-index来设置优先级（整数），越大优先级越高。如果优先级一样，先显示按照代码排列下面一点的元素。</p><p>祖先元素的层级再高，也不会盖住后代元素。</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><h3 id="字体族"><a href="#字体族" class="headerlink" title="字体族"></a>字体族</h3><p>font-family</p><p>字体分类—-字体大类，serif里面很多字体类别，这是一个大类别</p><ul><li>serif：衬线字体</li><li>sans-serif：非衬线字体</li><li>monospace：等宽字体</li><li>cursive：草书</li><li>fantasy：虚幻字体</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//可以同时使用多个字体，多个字体按前后排序，前面有就用前面的，前面没有就用后面的</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;微软雅黑&#x27;</span>,<span class="string">&#x27;Courier New&#x27;</span>,monospace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户没有时，可以服务器远程使用字体</p><p>font-face可以将服务器中的字体直接提供给用户使用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line">    font-family:&#x27;myfont&#x27;;  //随便起的名字</span><br><span class="line">    <span class="selector-tag">src</span><span class="selector-pseudo">:url(http</span>://<span class="selector-tag">xxxx</span>/<span class="selector-tag">xxx</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>:myfont;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图标字体"><a href="#图标字体" class="headerlink" title="图标字体"></a>图标字体</h3><p>一些图标可以不用图片，用字体来实现。</p><p>例如使用 font awesome网站下载字体库</p><p>使用步骤</p><ol><li><p>将css和webfonts移动到项目中（且必须在一起）</p></li><li><p>引入all.css到网页</p></li><li><p>使用图标字体</p><ul><li><p>直接使用类名类使用图标字体，文档看样式填进去</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-bell-slash&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>或者另外的方式，例如要给 列表 li 每个前面都设置。</p><p>通过伪元素。编码在文档中找</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">    content:&#x27;\f1bo&#x27;;  //这里设置字体图标的编号</span><br><span class="line">    font-family:&#x27;Font Awesome 5 Free&#x27;; //这里设置他的字体族</span><br><span class="line">    <span class="selector-tag">font-weight</span><span class="selector-pseudo">:900</span>; //<span class="selector-tag">fas</span> 必须设置  <span class="selector-tag">fab</span>只需要设置字体族即可</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还可以使用实体的方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;fas&quot;</span>&gt;</span></span><br><span class="line">    <span class="symbol">&amp;#xf0f3;</span> //f0f3是编码   &amp;#x+字体编号</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="字体框-行高"><a href="#字体框-行高" class="headerlink" title="字体框-行高"></a>字体框-行高</h3><p>行高指的是文字占有的实际高度</p><p><strong>line height: px,em</strong></p><p>如果设置为一个整数，行高将会是字体的指定的倍数</p><p><strong>font-size</strong>设置字体框的大小，字体框是字体存在的格子</p><h3 id="字体的简写属性"><a href="#字体的简写属性" class="headerlink" title="字体的简写属性"></a>字体的简写属性</h3><p>font可以设置字体相关的所有属性</p><blockquote><p>字体大小，字体族必须写</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">50<span class="selector-tag">px</span>是字体框大小 / 后面的是行高</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">font</span>: <span class="number">50px</span>/<span class="number">1.333</span> <span class="string">&#x27;微软雅黑&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文本水平和垂直对其"><a href="#文本水平和垂直对其" class="headerlink" title="文本水平和垂直对其"></a>文本水平和垂直对其</h3><p>text-aligh : 文本的水平对齐</p><ul><li>left</li><li>right</li><li>center</li><li>justify两端对齐</li></ul><p>vertical-aligh：垂直对齐</p><ul><li>baseline：默认值，基线对齐</li><li>top：顶部对齐</li><li>bottom：底部对齐</li><li>middle：居中对齐</li><li>值</li></ul><blockquote><p>图片在p标签这种中，如果是基线对齐可能会出现有空行，把图片的基线对齐改掉即可</p></blockquote><h3 id="其他文本样式"><a href="#其他文本样式" class="headerlink" title="其他文本样式"></a>其他文本样式</h3><p>text-decoration：下划线</p><ul><li>none</li><li>underline</li><li>line-through</li><li>overline</li></ul><p>white-space 设置网页中如何处理空白</p><ul><li>normal：默认</li><li>不换行</li><li>pre保留空白</li></ul><p>实现多余的文本后面显示省略号</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//缺一不可</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">white-space</span>:nowrap;</span><br><span class="line">    <span class="attribute">overflow</span>:hidden;</span><br><span class="line">    <span class="attribute">text-overflow</span>:ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背景图"><a href="#背景图" class="headerlink" title="背景图"></a>背景图</h2><p>background-image:url(‘xxxxxx’)</p><p>background-repeat设置背景的重复方式，如果图片比内容区小的情况</p><ul><li>repeat，默认值，xy重复</li><li>repeat-x：背景沿着x轴重复</li><li>repeat-y：背景沿着y轴重复</li><li>no-repeat：不重复</li></ul><p>background-position，设置图片的位置</p><ul><li>top</li><li>left</li><li>right</li><li>bottom</li><li>center</li><li>x,y值来设置</li></ul><p>background-clip：设置背景的范围</p><ul><li>border-box:默认值，背景h会出现在边框下面</li><li>padding-box：背景不会出现在边框，只出现在内容区和内边距</li><li>content-box：背景只会出现在内容区</li></ul><p>background-origin：背景图片的偏移量计算的原点</p><ul><li>padding-box：默认值，background-position从内边距开始计算</li><li>content-box：从内容区处计算</li><li>border-box：从边界开始计算</li></ul><p>background-size：设置背景图片的大小</p><ul><li>cover：图片的比例不变，将元素铺满</li><li>contain：图片比例不变，将图片在元素中完整显示</li><li>值：第一个值表示宽度，第二个表示高度，如果只设置一个，后面高度就为auto</li></ul><p>background-attachement：背景图片是否会跟随元素移动（滚轮移动）</p><ul><li>scroll 默认值：会跟着动</li><li>fixed 背景图片会固定在页面中</li></ul><p>background可以设置所有背景相关的属性。具体看文档   </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;&#x27;</span>) red center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="雪碧图"><a href="#雪碧图" class="headerlink" title="雪碧图"></a>雪碧图</h3><p>同一张图片，细微的区别，用的时候想要显示哪个，直接用偏移量解决</p><p>特点：一次性将多个图片放在一个图片里面，降低请求的次数，加快访问速度，提升用户的体验</p><p>使用步骤</p><ol><li>先确定要使用的图标</li><li>测量图标的大小</li><li>根据测量结果创建一个元素</li><li>将雪碧图设置为元素的背景图片</li></ol><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p>background-image: <strong>linear-gradient</strong>，线性渐变，颜色沿着一条直线发生变化</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    //红色到黄色过度 to right 向右渐变，to xxx</span><br><span class="line">    //或者 45<span class="selector-tag">deg</span> 45度的方向渐变  180为默认</span><br><span class="line">    //<span class="selector-tag">turn</span> 表示圈 1<span class="selector-tag">turn</span> 0.5<span class="selector-tag">turn</span></span><br><span class="line">    <span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>,<span class="selector-tag">red</span>,<span class="selector-tag">yellow</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以指定多种颜色，默认情况下平均分布。四个颜色平均分成4份。</p><p>还可以指定颜色渐变的起始位置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    //red 从50开始   100结束</span><br><span class="line">    <span class="selector-tag">background-image</span><span class="selector-pseudo">:linear-gradient(red</span> 50<span class="selector-tag">px</span>, <span class="selector-tag">yellow</span> 100<span class="selector-tag">px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>background-image: <strong>repeating-linear-gradient ( )</strong></p><p>可以平铺的线性渐变</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attribute">background-image</span>:<span class="built_in">repeating-linear-gradient</span>(red <span class="number">50px</span> ,yellow100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>background-image: <strong>radial-gradient</strong>  径向渐变（放射性的效果）</p><p>默认情况下，径向渐变的形状是根据元素的形状来计算的。</p><p>正方形—》圆形   长方形–》椭圆形</p><p>也可以手动指定径向渐变的大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//其他设置差不多,<span class="selector-tag">circle</span>正圆，<span class="selector-tag">ellipse</span>椭圆，</span><br><span class="line">//<span class="selector-tag">at</span> 0 0表示位置在什么地方开始</span><br><span class="line">//<span class="selector-tag">closest-side</span>近边    <span class="selector-tag">closest-corner</span>近角   <span class="selector-tag">farthest-side</span>远边....</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"> <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(<span class="number">100px</span>,<span class="number">100px</span> at <span class="number">0</span> <span class="number">0</span>,red,yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目补充"><a href="#项目补充" class="headerlink" title="项目补充"></a>项目补充</h2><p>min-width：设置元素的最小宽度</p><p>实现小三角，利用border实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:0px</span>;</span></span><br><span class="line">        height: 0px;</span><br><span class="line">        border: 10px red solid;</span><br><span class="line">        border-color: red black green yellow;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>transition</strong></p><p>为样式设置过渡效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span><span class="selector-pseudo">:height</span> 3<span class="selector-tag">s</span>;//高度发生变化的时候3<span class="selector-tag">s</span>才显示出来</span><br></pre></td></tr></table></figure><p><strong>text-indent</strong></p><p>设置字体偏移量</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>徐涛-基础班-思修法基</title>
      <link href="2022/%E5%BE%90%E6%B6%9B-%E5%9F%BA%E7%A1%80%E7%8F%AD-%E6%80%9D%E4%BF%AE%E6%B3%95%E5%9F%BA/"/>
      <url>2022/%E5%BE%90%E6%B6%9B-%E5%9F%BA%E7%A1%80%E7%8F%AD-%E6%80%9D%E4%BF%AE%E6%B3%95%E5%9F%BA/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20220210114717451.png" alt="image-20220210114717451"></p><h2 id="思想修养"><a href="#思想修养" class="headerlink" title="思想修养"></a>思想修养</h2><h3 id="人生观"><a href="#人生观" class="headerlink" title="人生观"></a>人生观</h3><p>人生目的(核心)决定 —&gt;人生态度 决定—&gt;<strong>人生价值</strong></p><h3 id="理想信念"><a href="#理想信念" class="headerlink" title="理想信念"></a>理想信念</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20220210115245233.png" alt="image-20220210115245233"></p><h3 id="中国精神"><a href="#中国精神" class="headerlink" title="中国精神"></a>中国精神</h3><ul><li>民族精神(爱国主义)</li><li>时代精神(改革创新)</li></ul><h2 id="道德修养"><a href="#道德修养" class="headerlink" title="道德修养"></a>道德修养</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20220210115654335.png" alt="image-20220210115654335"></p><p>性质:上层建筑</p><p>功能:认识,规范,调节</p><p>横向,不同时期</p><p>纵向:不同领域</p><h2 id="法律基础"><a href="#法律基础" class="headerlink" title="法律基础"></a>法律基础</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20220210115815288.png" alt="image-20220210115815288"></p><p>法律运行: 立法,执法,司法,守法</p><p>法律体系: 实体法律,秩序部门</p><p>法治体系: 法律, 实施, 监督</p>]]></content>
      
      
      <categories>
          
          <category> 政治 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>徐涛-基础班-史纲</title>
      <link href="2022/%E5%BE%90%E6%B6%9B-%E5%9F%BA%E7%A1%80%E7%8F%AD-%E5%8F%B2%E7%BA%B2/"/>
      <url>2022/%E5%BE%90%E6%B6%9B-%E5%9F%BA%E7%A1%80%E7%8F%AD-%E5%8F%B2%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20220210121210497.png" alt="image-20220210121210497"></p><h3 id="国情"><a href="#国情" class="headerlink" title="国情"></a>国情</h3><p>半殖民地半封建 1840-1949</p><h3 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h3><p>帝国主义—–中华民族</p><p>封建主义—–人民大众</p><h3 id="任何和对象"><a href="#任何和对象" class="headerlink" title="任何和对象"></a>任何和对象</h3><p>反帝反封建</p><h3 id="革命的性质"><a href="#革命的性质" class="headerlink" title="革命的性质"></a>革命的性质</h3><p>资产阶级民主革命</p><p>近代中国，反帝反封建理应由资产阶级来做，因为是资产阶级的历史使命，但由于资产阶级弱小，没有实力完成这个历史使命。因此变为由 无产阶级来完成本该由资产阶级完成的历史使命。变为由无产阶级领导的，资产阶级性质的，反帝反封建的新式的民族主义革命</p><p>简单来说就是，跟革命性质有关，跟领导者无关</p><h2 id="旧民主主义革命"><a href="#旧民主主义革命" class="headerlink" title="旧民主主义革命"></a>旧民主主义革命</h2><p>资产阶级旧民主主义革命</p><p><strong>完整意义的资产阶级旧民主主义革命：辛亥革命</strong></p><ul><li>纲领：三民主义</li><li>精英革命 ： 没有群众路线</li><li>民族资产阶级的软弱性： 没有坚强的领导核心</li></ul><h2 id="新民主主义革命"><a href="#新民主主义革命" class="headerlink" title="新民主主义革命"></a>新民主主义革命</h2><p><strong>五四运动</strong>：</p><p>马克思主义广泛传播于中国</p><p>中国共产党的成立：坚强的领导核心</p><p><strong>大革命</strong>：第一次国共合作，北伐战争</p><p><strong>土地革命：</strong>农村包围城市，武装夺取政权</p><p><strong>全面抗战：</strong>第二次国共合作</p><p><strong>解放战争：</strong>解放新中国</p><h2 id="新中国时期"><a href="#新中国时期" class="headerlink" title="新中国时期"></a>新中国时期</h2><p>1949新民主主义革命</p><p><strong>过渡时期</strong>：1949-1950 三大改造</p><p><strong>探索时期：</strong>1956-1976 奠定基础，做了准备，创造条件</p><p><strong>改革开放：</strong>1978-今 中国特色社会主义道路</p><p><strong>新时代：</strong>2012-今 全面小康，全面脱贫，全面社会主义现代化强国，民族复习</p>]]></content>
      
      
      <categories>
          
          <category> 政治 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>徐涛-基础班-毛中特</title>
      <link href="2022/%E5%BE%90%E6%B6%9B-%E5%9F%BA%E7%A1%80%E7%8F%AD-%E6%AF%9B%E4%B8%AD%E7%89%B9/"/>
      <url>2022/%E5%BE%90%E6%B6%9B-%E5%9F%BA%E7%A1%80%E7%8F%AD-%E6%AF%9B%E4%B8%AD%E7%89%B9/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20220210124658401.png" alt="image-20220210124658401"></p><h2 id="马克思主义中国化"><a href="#马克思主义中国化" class="headerlink" title="马克思主义中国化"></a>马克思主义中国化</h2><p><strong>新文化运动 : 技术(洋务运动)—&gt;制度—-&gt;思想文化</strong></p><p><strong>十月革命：马克思列宁主义</strong></p><p><strong>五四运动：广泛传播</strong></p><p><strong>中共一大：以无产阶级革命推翻资产阶级</strong></p><p><strong>六届六中全会《论新阶段》：首次提出马克思主义中国化命题</strong></p><p><strong>中共七大：实现第一次飞跃，毛泽东思想</strong></p><p><strong>《论十大关系》：第二次马克思主义中国话开始</strong></p><p><strong>改革开放：实现第二次飞跃，中国特色社会理论体系</strong></p><h2 id="毛泽东思想"><a href="#毛泽东思想" class="headerlink" title="毛泽东思想"></a>毛泽东思想</h2><h3 id="新民主主义革命理论"><a href="#新民主主义革命理论" class="headerlink" title="新民主主义革命理论"></a>新民主主义革命理论</h3><ul><li><p>革命路线：无产阶级领导的，人民大众的，反帝反封反官僚资本主义</p></li><li><p>革命纲领</p><ul><li>政治：各革命阶级联合专政</li><li>经济：<ul><li>官僚资本主义，地主：没收</li><li>民族资产阶级：保护</li></ul></li><li>文化：民族的，科学的，大众的</li></ul></li><li><p>革命道路：农村包围城市，武装夺取政权</p></li><li><p>革命经验：统一战线，武装斗争，党的建设</p></li></ul><h3 id="社会主义改造理论"><a href="#社会主义改造理论" class="headerlink" title="社会主义改造理论"></a>社会主义改造理论</h3><ul><li>农业：合作化，集体经济（公有制）</li><li>手工业：合作化，集体经济（公有制）</li><li>资本主义工商业：和平赎买，改造资本家</li></ul><h3 id="社会主义建设初步探索理论"><a href="#社会主义建设初步探索理论" class="headerlink" title="社会主义建设初步探索理论"></a>社会主义建设初步探索理论</h3><ul><li>《论十大关系》：<ul><li>马克思主义中国化第二次的开始</li><li>方针：调动一切积极因素</li><li>指导思想：独立自主探索，符合中国特点的社会主义道路</li></ul></li><li>《关于正确处理人民内部矛盾的问题》<ul><li>基本矛盾：生产力和生产关系的矛盾，经济基础和上层建筑的矛盾</li><li>主要矛盾：落后的农业国与先进的工业国的矛盾，日益增长的物质文化需要同当前的发展不能满足人民需要状况的矛盾</li><li>两类矛盾：敌我矛盾，人民内部矛盾</li></ul></li><li>中国工业化道路：农轻重</li></ul><h2 id="中国特色社会主义理论体系"><a href="#中国特色社会主义理论体系" class="headerlink" title="中国特色社会主义理论体系"></a>中国特色社会主义理论体系</h2><ul><li><p><strong>邓小平理论：什么是社会主义？怎样建设社会主义</strong></p></li><li><p><strong>三个代表重要思想：建设什么样的党？怎样建设党？</strong></p></li><li><p><strong>科学发展观：实现什么样的发展？怎样发展？</strong></p></li></ul><h3 id="习近平新时代中国特色社会主义思想"><a href="#习近平新时代中国特色社会主义思想" class="headerlink" title="习近平新时代中国特色社会主义思想"></a>习近平新时代中国特色社会主义思想</h3><ol><li>全面小康社会，全面脱贫  建党一百年</li><li>基本实现社会主义现代化  2035</li><li>建成社会主义现代化强国，实现中华民族伟大复兴</li></ol>]]></content>
      
      
      <categories>
          
          <category> 政治 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>徐涛-基础班-马原</title>
      <link href="2022/%E5%BE%90%E6%B6%9B-%E5%9F%BA%E7%A1%80%E7%8F%AD-%E9%A9%AC%E5%8E%9F/"/>
      <url>2022/%E5%BE%90%E6%B6%9B-%E5%9F%BA%E7%A1%80%E7%8F%AD-%E9%A9%AC%E5%8E%9F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="马原"><a href="#马原" class="headerlink" title="马原"></a>马原</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/%E9%A9%AC%E5%8E%9F.png" alt="马原"></p><p>马原分为三部分，是恩格斯，在《反社林论》文章中分的。</p><p>马原的三部分的关系。哲学是<strong>方法</strong>，政经是<strong>主体</strong>（《资本论》），社科是<strong>目的和归宿</strong></p><h3 id="理解三个词"><a href="#理解三个词" class="headerlink" title="理解三个词"></a>理解三个词</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20220209122509006.png" alt="image-20220209122509006"></p><ol><li><p>第一层：世界观，方法论</p><p>世界观：我们对于世界的总体看法，和整体观点。每一个成年人都有自己的世界观</p><p>方法论：与世界观对应，有个 世界观后 应该怎么做？</p></li><li><p>第二层：哲学</p><p>系统化，理论化的世界观和方法论</p><p>世界观不稳定，变化的过程会产生痛苦</p></li><li><p>第三层：马克思主义哲学</p><p>科学的，系统化，理论化的世界观和方法论</p><p>考研中 只有“废黜百家、独尊马术”正确</p></li></ol><h4 id="唯物论"><a href="#唯物论" class="headerlink" title="唯物论"></a>唯物论</h4><p><strong>世界的本原是什么？</strong></p><p>主观唯心主义：认为世界的本原在人的心理。 王阳明</p><p>客观唯心主义：佛教中的 “缘”，道教的“道”</p><p>唯物主义：一切客观实在（物质）</p><p><strong>物质如何起决定性作用？</strong></p><p>物质决定意识，意识是对物质的反应，被物质派生出来的。</p><h4 id="辩证法"><a href="#辩证法" class="headerlink" title="辩证法"></a>辩证法</h4><p><strong>物质世界是怎样存在的？</strong></p><p>两大总特征：普遍联系，永恒发展</p><p><strong>事物是怎样联系的？</strong></p><p>一对一对联系。构成交织的大网。</p><p>一对一对，既对立又统一，为矛盾。</p><p><strong>事物为什么会发展？</strong></p><p>对立统一</p><p><strong>怎样发展？</strong></p><p>量变，质变</p><p><strong>往哪里发展？</strong></p><p>否定之否定，呈波浪式前进、螺旋式上升</p><p>辩证法三大规律：对立统一，量变质变，否定之否定</p><h4 id="认识论"><a href="#认识论" class="headerlink" title="认识论"></a>认识论</h4><p><strong>认识的本质是什么？</strong></p><p>人脑和人心只是一面镜子么？</p><p>不只是，因为意识有能动性。丢掉能动，会变成机械</p><p><strong>认识的过程是怎样的？</strong></p><p>第一步源于感性认识，加工整理后得到 理性认识</p><p>感性认识和理性认识是浅和深的关系，不是对和错的关系</p><p><strong>认识的结果有什么特点？</strong></p><ul><li><p>真理，即使绝对，也是相对</p><ul><li>绝对性</li><li>相对性</li></ul></li><li><p>谬误</p></li></ul><h4 id="唯物史观"><a href="#唯物史观" class="headerlink" title="唯物史观"></a>唯物史观</h4><p>研究人类历史</p><p><strong>历史进程中的决定性力量是什么？</strong></p><p>精神力量，唯心史观</p><p>物质力量，唯物史观（社会生产劳动，及其生产力水平）</p><p><strong>历史是什么人创造的？</strong></p><p>英雄人物-唯心史观</p><p>人民群众-唯物史观</p><p><strong>历史向前发展有什么特点</strong></p><p>规律（决定性作用）—统一性</p><p>人的主观能动性，对其选择—多样性</p><h3 id="政治经济学"><a href="#政治经济学" class="headerlink" title="政治经济学"></a>政治经济学</h3><p><strong>商品价值的本质是什么？</strong></p><p>劳动+交换</p><p><strong>资本主义社会有什么不同？</strong></p><p>不是资本主义，劳动成果归劳动者所有。</p><p>是资本主义，劳动成果归资本家所有。</p><p><strong>为什么说资本主义社会存在着剥削？</strong></p><p>剩余价值理论。</p><p>例如，劳动者创造100的价值，但是劳动者只有50的收益，另外的被没有劳动的资本家拿走了</p><h3 id="科学社会主义理论"><a href="#科学社会主义理论" class="headerlink" title="科学社会主义理论"></a>科学社会主义理论</h3><p><strong>社会主义的发展进程</strong></p><p>空想—-科学</p><p>理论—-实践</p><p><strong>共产主义的基本特征</strong></p><p>物质财富极大丰富</p><p>精神境界极大提高</p><p>每个人自由全面的发展</p>]]></content>
      
      
      <categories>
          
          <category> 政治 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 马原 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理</title>
      <link href="2021/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"/>
      <url>2021/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><strong>1、DB的概念与特点：</strong></p><ul><li>数据库（DB）是存储在计算机系统内的有结构的数据集合，是相关数据的集合，数据由数据库管理系统统一管理和维护。</li><li>数据（Data）指的是可观察的客观事实，并且有隐含的含义。</li><li>在数据库中，数据与数据的含义（数据名称及说明）同时存储。</li><li>数据的最小存取单位是构成记录的、有名称的、有含义的最小数据单位——数据项</li><li>定义数据库时，必须定义数据项的逻辑结构。</li><li>在使用数据库时，以数据项名存储数据、更新数据以及查询和使用数据。</li><li>在数据库中，不仅包含数据本身，还包含了数据结构和约束的完整性定义或者描述。这些定义存储在DBMS的目录中，称为数据库的<strong>元数据</strong>或者<strong>数据字典</strong>。</li><li>任何合法用户都可以在元数据的帮助下，利用数据项名方面的访问数据库中的数据以及他们的逻辑定义，并使用这些数据，亦即数据可高度共享。</li><li>数据库是存储在计算机系统内的有结构的数据的集合，数据是由数据库管理系统管理的。</li></ul><p><strong>2、DBS特点与组成要素：</strong></p><ul><li><p>DBS是指在计算机系统中引入数据库后的数据构成，由计算机硬件、操作系统、DBMS、DB、应用程序和用户以及数据库开发和管理人员等组成。</p></li><li><p>数据库系统区别于传统文件处理系统的最重要特征是引入了数据库这个概念，以及产生数据库管理系统。</p></li><li><p>与文件系统相比，DBS有如下四个主要特点：</p></li><li><ul><li><strong>整体数据结构化</strong>：数据库中的任何数据都是公开的，不属于任何应用，结构是全面的。</li><li><strong>数据的共享度高</strong>：在显示数据的同时可以显示数据的逻辑结构；整个组织的整体数据被综合考虑，整体数据结构化。可以方面的使用数据和扩充新的应用。</li><li><strong>数据的独立性高</strong>：数据与数据的结构存储在数据库中，应用程序既不存储数据也不存储数据的逻辑结构。数据与程序相对独立。</li><li><strong>高度的数据控制能力</strong>：具有较高的数据安全性；较好的数据完整性；较强的并发控制能力；较强的数据恢复能力。</li></ul></li></ul><p><strong>3、DBMS的功能：</strong></p><ul><li><p>数据库管理系统是专门用来实现和维护数据库而建立的通用软件。</p></li><li><p>DBMS是操作系统支持下工作的数据管理软件，是支持用户创建和维护数据库的一组程序包。对内负责管理数据库，对外向用户提供一整套命令。用户可以通过命令来创建数据库，定义数据，对数据库中的数据进行各种合法的操作。</p></li><li><p>DBMS有如下六种基本功能：</p></li><li><ul><li><strong>数据定义</strong>：用户可以利用数据定义语言（DDL）来方便地定义数据库中数据的逻辑结构。</li><li><strong>数据操纵</strong>：用户可以利用数据操纵语言（DML）来实现对数据库对数据库中数据的插入、查找、修改或者删除操作。</li><li><strong>完整性约束检查</strong>：检查数据时候符合一定的规定。</li><li><strong>访问控制</strong>：通过数据控制语言（DCL）来实现对不同级别用户的访问控制功能。</li><li><strong>并发控制</strong>：通过只用并发控制功能，可以确保试图更新同一数据的多个用户能够以一种受控的方式完成各自的工作，即避免并发操作时可能带来的数据不一致性。</li><li><strong>数据恢复</strong>：恢复数据库。</li></ul></li></ul><p><strong>4、DBA的职责</strong></p><ul><li><p>数据库管理员的主要职责有：</p></li><li><ul><li>在用户与数据库开发人员之间进行沟通和协调。</li><li>参与数据库设计工作。</li><li>决定数据的完整性约束和不同用户的存取权限。</li><li>保证数据库的正常运行，进行数据库的维护工作。</li><li>提出数据库的重构计划。</li></ul></li></ul><h2 id="概念数据模型"><a href="#概念数据模型" class="headerlink" title="概念数据模型"></a>概念数据模型</h2><p><strong>数据模型</strong>：数据模型是描述现实世界实体、实体之间的联系以及语义约束的模型。</p><p>数据模型的形式化定义</p><ul><li>数据结构：指数据模型中用来表示现实世界实体以及实体间联系的数据结构。数据结构的定义规定了数据库数据的逻辑结构</li><li>数据操作：指数据模型中包含的用于操作数据结构的操作集合。数据操作的定义规定了将来数据库中的数据存取方式，如查询，更新等</li><li>数据约束：指数据模型中数据结构建立和执行数据操作时必须遵循的约束条件</li></ul><p>现实世界（认识抽象）—-&gt;概念数据模型（信息时间）—-&gt;结构数据模型（机器世界）</p><h3 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h3><p>ER模型的核心要素就是实体和联系。还有实体的属性</p><ul><li><strong>实体（entity）</strong>：现实世界中可标识的对象。例如学生，老师，书</li><li><strong>联系（relationship）</strong>：实体之间的联系。联系也有相应的联系名，例如学生与老师，是授课。<ul><li>1:1关系</li><li>1:N（一对多）关系</li><li>N:M（多对多）关系</li></ul></li><li><strong>属性（attribute）</strong>：描述实体自身的属性。通常有多个属性。关键要看应用环境，学生年龄的属性……，而有时需要建立联系之后会有额外的属性，例如学生与课程建立联系，就有成绩的属性，但成绩不属于这两个的任意一个实体</li></ul><p><strong>ER模型的符号</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211205182125052.png" alt="image-20211205182125052"></p><p><strong>ER模型设计</strong></p><ol><li>分 E-R模型，设计系统的子系统</li><li>E-R模型集成，将子系统的ER模型集成为一个整体。<ul><li>属性冲突 ： 如一个表性别属性是sex一个是gender</li><li>结构冲突：实体属性集不同，联系类型不同，同一对象在不同应用中的抽象不同</li><li>命名冲突：同名异义，异名同义两种情况</li></ul></li><li>E-R模型的优化<ul><li>合并实体</li><li>消除冗余属性</li><li>消除冗余联系</li></ul></li></ol><p><strong>E-R模型扩展</strong></p><p>例如：这样一种情况，会员有注册会员，正式会员，高级会员。只有一个会员实体没法表达。因为他们的属性不一样</p><p>子类，超类：超类可以理解为 一个类，子类继承超类。（JAVA中的类）</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211205183343723.png" alt="image-20211205183343723"></p><p><strong>弱实体</strong></p><p>弱实体是强实体的依赖。</p><p>例如一个公司中，员工需要填子女的名字，给子女福利。那么子女就是弱实体。相应的员工为强实体。之间是依赖关系。</p><h2 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h2><p>这里我们和 SQL语言结合进行理解更为简单。所以后面一部分SQL内容会在这里写出。</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><strong>关系数据模型：</strong>以规范化的二维表格结构表示实体集，以外码表示实体间联系，以三类完整性表示语义约束的数据模型</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211208210415420.png" alt="image-20211208210415420"></p><ul><li><p><strong>元组（tuple）</strong>：每一行一个为一个元组</p></li><li><p><strong>属性（attribute）：</strong>一列为一个属性</p></li><li><p><strong>关系（relation）：</strong>关系是元组的集合，关系代表了一个实体的集合，也就是多个元组为一个关系。</p></li><li><p><strong>关系模式（relational schema）</strong>：数据和语义是不可分的，关系的语义需要用关系模式来定义。</p></li><li><p><strong>关系数据库模式（relational database schema）：</strong>描述了整个关系数据库的逻辑结构和特征。由若干关系模式构成的集合。每个关系模式都描述了某一类实体的逻辑结构和特征。</p></li><li><p><strong>关系数据库（relational database）：</strong>关系数据库模式的一个实例称为关系数据库，所以关系数据库对应的是数据的概念，是关系的集合</p></li><li><p><strong>码（key）：</strong></p><ul><li><p>超码（super key）：唯一区分每个元组的属性<strong>集合</strong></p></li><li><p>候选码（candidate key）：不含多余属性的超码称为候选码，所以候选码是唯一区分元组的最小属性集</p><p>一个关系模式中可能存在多个候选码，例如学生可以有学号和身份证号区分</p></li><li><p>主属性（primary attribute）：包含在某个候选码中的属性称为主属性</p></li><li><p>非主属性（nonprime attribute）：主属性之外的属性</p></li><li><p>主码（primary key）：实际的数据库设计中，用户选定的作为元组标识的候选码称为主码（其实就是主键）</p></li><li><p>替换码（alternate key）实际应用中很少使用，</p></li></ul></li></ul><blockquote><p>例子,Student表</p><p>Student(id,name,age,gender)，其中id是学号，（id，name）就是超码（集合）。sno作为关系模式的主码，这里没有替换码，如果有个身份证，那身份证就是替换码。</p></blockquote><h4 id="关系基本性质"><a href="#关系基本性质" class="headerlink" title="关系基本性质"></a><strong>关系基本性质</strong></h4><ul><li>属性值不可分解</li><li>元组不可重复（超码不可重复）</li><li>关系没有行序，列序</li></ul><h3 id="关系模式的定义"><a href="#关系模式的定义" class="headerlink" title="关系模式的定义"></a>关系模式的定义</h3><p><strong>关系模式</strong>：可以形式化定义为一个四元组 R(U, D, dom, F)</p><ul><li><p>R：关系名</p></li><li><p>U：组成该关系的属性集合</p></li><li><p>D：属性组 U 中属性所来自的域</p><p>一个属性值可能取的所有属性值的范围，称为该属性的域。不同的属性可以有相同的域。</p></li><li><p>dom：属性向域的映像的集合</p><p>属性的类型和长度，例如 name char(5)</p></li><li><p>F：属性间数据的依赖关系集合</p><p>关系的属性与属性之间的一种约束关系</p></li></ul><h3 id="关系的完整性约束"><a href="#关系的完整性约束" class="headerlink" title="关系的完整性约束"></a>关系的完整性约束</h3><ul><li><p><strong>实体完整性（intity integrity）</strong></p><p>指关系模式的任一关系的主属性值不可为空</p></li><li><p><strong>参照完整性</strong></p><p>若学生表属性 class_id 与 班级表属性 class_id组成外键，则学生的班级id必须参照班级表的class_id属性</p></li><li><p><strong>用户定义完整性</strong>：</p><p>关系模式针对某一具体数据的要求而制定的约束条件，反映某一具体应用所涉及的数据必须满足的特殊语义</p><p>例如 年龄必须 0&lt; 年龄 &lt;200</p></li></ul><h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p><strong>代数表达式会省略</strong>，用SQL语句来方便理解含义。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211208205938517.png" alt="image-20211208205938517"></p><ul><li><p>并(union) ： 将A，B的数据放在一块，消除重复的元组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> B;</span><br></pre></td></tr></table></figure></li><li><p>交(intersection) ：<strong>找出同时存在于关系R和S中的所有相同的元组</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">UNION</span> <span class="keyword">ALL</span>  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students_2) <span class="keyword">GROUP</span> <span class="keyword">BY</span> sid <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>差（difference）：从关系元组A中去掉他与关系B相同的那些元组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> (id,name,dept,birthday) <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> B);</span><br></pre></td></tr></table></figure></li><li><p>笛卡尔积：就是将两个表进行笛卡尔排列。</p></li><li><p>投影</p><p>取出一个查询结果中的<strong>某几列</strong>，消除重复的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,dept <span class="keyword">from</span> A;</span><br></pre></td></tr></table></figure></li><li><p>选择：选出特定值的元组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>连接：把两个表按照给定的条件拼接和形成的新表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">inner</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.dept_id <span class="operator">=</span> B.dept_id;</span><br></pre></td></tr></table></figure></li><li><p>除</p><p>引用书上的例子（数据库原理与应用）</p><p>找到选修了 001 学号同学 所选修课程的所有同学的学号，利用除操作，过程如下。先找到001同学的选课，在用选课来找学号</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211208211553856.png" alt="image-20211208211553856"></p></li></ul><h2 id="关系数据库查询语言"><a href="#关系数据库查询语言" class="headerlink" title="关系数据库查询语言"></a>关系数据库查询语言</h2><p>注意：关系型数据库有很多，下面不语句不唯一，但是具体用法差不多。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211219155811477.png" alt="image-20211219155811477"></p><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p><strong>Create table</strong></p><ul><li>主键约束  primary key</li><li>唯一性约束   unique，用法和主键一致</li><li>外键约束  foreign key  如下</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>(列名<span class="number">1</span> 列类型<span class="number">1</span> [列约束<span class="number">1</span>], 列名<span class="number">2.</span>...);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(id <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">primary</span> <span class="keyword">key</span>, name <span class="type">varchar</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">外键</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">primary</span> <span class="keyword">key</span></span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">    cid <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">foreign</span> <span class="keyword">key</span>(cid) <span class="keyword">references</span> class(cid);</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>Alter table</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">add</span> <span class="operator">&lt;</span>列定义<span class="operator">&gt;</span>] <span class="operator">|</span> </span><br><span class="line">[<span class="keyword">alter</span> <span class="keyword">column</span> <span class="operator">&lt;</span>列定义<span class="operator">&gt;</span>] <span class="operator">|</span></span><br><span class="line">[<span class="keyword">drop</span> <span class="keyword">column</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span>] <span class="operator">|</span></span><br><span class="line">[<span class="keyword">add</span> <span class="operator">&lt;</span>表约束<span class="operator">&gt;</span>] <span class="operator">|</span></span><br><span class="line">[<span class="keyword">drop</span> <span class="keyword">constraint</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure><p><strong>Drop table</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p><strong>Insert</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(id,name,cid);<span class="operator">/</span><span class="operator">/</span>没有设定要插入的列，那么按照从前面到后面的顺序插入，如果cid后面还有列，且设置了<span class="keyword">not</span> <span class="keyword">null</span>就会报错，如果没设置，默认为空</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id) <span class="keyword">values</span>(id); <span class="operator">/</span><span class="operator">/</span>指定插入的列</span><br></pre></td></tr></table></figure><p><strong>update</strong></p><p>用法跟insert基本一致</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> name<span class="operator">=</span>xxx,age<span class="operator">=</span>xx;</span><br></pre></td></tr></table></figure><p><strong>Delete</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [<span class="keyword">where</span> <span class="operator">=</span> 条件];</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> age <span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a><strong>查询</strong></h4><p>基本结构如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">where</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">Group</span> <span class="keyword">by</span> <span class="operator">&lt;</span>分组列名<span class="operator">&gt;</span>]   <span class="operator">/</span><span class="operator">/</span>指定要分组的列</span><br><span class="line">[<span class="keyword">Having</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>]  <span class="operator">/</span><span class="operator">/</span>指定分组的条件</span><br><span class="line">[<span class="keyword">Order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>排序列<span class="operator">&gt;</span> ] 指定如何排序</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>简单使用<span class="comment">---查询整张表</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>特定列</span><br><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>加上条件</span><br><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">10</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>排序  按照年龄排序</span><br><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">order</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure><p><strong>Group by</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>分男女组，然后进行计男女的数量</span><br><span class="line"><span class="keyword">select</span> sex <span class="keyword">as</span> 性别,<span class="built_in">count</span>(id) <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>按照男女 和 年龄分组</span><br><span class="line"><span class="keyword">select</span> age,sex,<span class="built_in">count</span>(id) <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> age,sex;</span><br></pre></td></tr></table></figure><p><strong>Having</strong></p><p>设置条件，如果不设置Having的话，group by 会返回所有的数据，Having可以指定条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>按照年龄分组，只返回这个年龄人数大于<span class="number">5</span>个的</span><br><span class="line"><span class="keyword">select</span> age,<span class="built_in">count</span>(id) <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> age <span class="keyword">Having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h5 id="连接查询"><a href="#连接查询" class="headerlink" title="-连接查询"></a>-连接查询</h5><p>假如有两张表 </p><p>student(id,name,age,cid);</p><p>class(cid,cname);</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询 <span class="number">1</span>班的学生的名字,这里用了左连接 <span class="keyword">on</span>后面是条件。</span><br><span class="line"><span class="keyword">select</span> student.name </span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">left</span> <span class="keyword">join</span> class <span class="keyword">on</span> student.cid <span class="operator">=</span> class.cid;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>左连接</li><li>右连接</li><li>内连接</li><li>外连接</li><li>笛卡尔积</li></ul><p><strong>这里暂时没写</strong></p><h5 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="-嵌套查询"></a>-嵌套查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询不在class表中的cid</span><br><span class="line"><span class="keyword">select</span> cid <span class="keyword">from</span> student </span><br><span class="line"><span class="keyword">where</span> cid <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> cid <span class="keyword">from</span> class);</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询 已经查询出来的数据  <span class="comment">---当然这里可以写成一个，只是为了方便理解</span></span><br><span class="line"><span class="keyword">select</span> id </span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> id <span class="keyword">from</span> student <span class="keyword">where</span> age <span class="operator">&gt;</span><span class="number">20</span>);</span><br></pre></td></tr></table></figure><h5 id="Union"><a href="#Union" class="headerlink" title="-Union"></a>-Union</h5><p>要求：</p><ul><li>列数必须想相同</li><li>相对的列类型需要一致</li><li>order by 只能在最后使用，且只有一次</li><li>union all 包含重复行的集合运算，没有all会去除重复行</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>例如有两张学生表</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询 两张表学生的id</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> student1</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> student2;</span><br></pre></td></tr></table></figure><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>从一个表或多个基本表中导出的虚拟表。有和表一样的逻辑结构，但没有实际的数据存储。数据还是基本表的数据。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211219170829688.png" alt="image-20211219170829688"></p><p>优点</p><ol><li>无需保存数据，因此可以节省存储设备的容量。</li><li>将频繁使用的select语句，保存成视图，这样不用每次都重新写。只需要在select语句中进行调用</li></ol><p><strong>创建视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span>[(列名<span class="number">1</span>,列名<span class="number">2.</span>...)] <span class="keyword">as</span> <span class="operator">&lt;</span>查询<span class="operator">&gt;</span> [<span class="keyword">with</span> <span class="keyword">check</span> option];</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>创建一个学生视图，包含id,name,age,条件是软件工程的学生</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> stu_view(id,name,age)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> id,name,age <span class="keyword">from</span> student <span class="keyword">where</span> dept <span class="operator">=</span> &quot;软件工程&quot;;</span><br></pre></td></tr></table></figure><p><strong>视图查询</strong></p><p>和查表类似，写视图名即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,age <span class="keyword">from</span> stu_view <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><strong>视图更新</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> stu_view <span class="keyword">set</span> name <span class="operator">=</span> &quot;123&quot; <span class="keyword">where</span> name <span class="operator">=</span>&quot;321&quot;;</span><br></pre></td></tr></table></figure><p><strong>视图删除</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> stu_view;</span><br></pre></td></tr></table></figure><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p><strong>Grant</strong></p><p>grant进行授权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>把对象上的权限，授予给用户</span><br><span class="line">grant &#123;all | [&lt;权限1&gt;,.....]&#125; on &lt;对象&gt; to [&lt;用户1&gt;,...];</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>把 Authors表的<span class="keyword">insert</span> <span class="keyword">delete</span> 权限 给yven</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">insert</span>,<span class="keyword">delete</span> <span class="keyword">on</span> authors <span class="keyword">to</span> yven;</span><br></pre></td></tr></table></figure><p><strong>Revoke</strong></p><p>删除权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>废除所有表的 权限 对于 用户</span><br><span class="line">revoke &#123;all | [&lt;权限1&gt;,.....]&#125; from [&lt;用户1&gt;,...];</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>废除对象表的权限</span><br><span class="line">revoke &#123;all | [&lt;权限1&gt;,.....]&#125; on &lt;对象&gt; from [&lt;用户1&gt;,...];</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除yven拥有的<span class="keyword">create</span> <span class="keyword">table</span>权限</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">from</span> yven;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除yven 在author表的<span class="keyword">create</span>权限</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">create</span> <span class="keyword">on</span> author <span class="keyword">from</span> yven;</span><br></pre></td></tr></table></figure><p><strong>deny</strong></p><p>因为sql中也有组的机制，revoke不能完全解决权限问题。例如如果yven是没有create权限的，但是他所在的组又有create权限。则他会继承此权限</p><p>deny可以解决这个问题。</p><p>停止语句权限</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deny &#123;all | [&lt;语句1&gt;,....]&#125; to [&lt;用户1&gt;....];</span><br></pre></td></tr></table></figure><p>停止对象权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deny &#123;all | [权限1,....]&#125; on &lt;对象&gt; [&lt;用户1&gt;,.....];</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>去除<span class="keyword">select</span> <span class="keyword">update</span>，student表。对于yven</span><br><span class="line">deny <span class="keyword">select</span>,<span class="keyword">update</span> <span class="keyword">on</span> student <span class="keyword">to</span> yven;</span><br></pre></td></tr></table></figure><h2 id="过程化SQL简介"><a href="#过程化SQL简介" class="headerlink" title="过程化SQL简介"></a>过程化SQL简介</h2><p>这里按 Microsoft SQL Server的T-SQL来介绍。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><strong>T-SQL的变量定义与赋值</strong></p><p>赋值可以是 常量，算数表达式，函数表达式，字符串表达式，表中的字段，或者是sql语句…..</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>定义</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@temp</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>赋值<span class="comment">---set只能单个赋值</span></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@temp</span><span class="operator">=</span><span class="keyword">select</span> id <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>多个赋值</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@v1</span><span class="operator">=</span>xxx,<span class="variable">@v2</span><span class="operator">=</span>xxx;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>如果返回多个数据时，返回多个数据。set会报错，select会取最后一个值</p><p>select @v1 = select age from student;  //这里多个age，取最后一个值</p></li><li><p>表达式没有返回值时，set将变量置为null，用select则保持变量值</p></li><li><p>使用sql语句赋值时，如果无返回值，使用set和select都置为null</p></li></ul></blockquote><p><strong>T-SQL的语句</strong></p><p>其实和函数差不多，这里只说说使用事项</p><ul><li><p>BEGIN…END：定义语句块</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if <span class="keyword">Exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> dept<span class="operator">=</span>&quot;软件工程&quot;)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">delete</span> student <span class="keyword">where</span> dept<span class="operator">=</span>&quot;软件工程&quot;</span><br><span class="line">print <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">print <span class="string">&#x27;xxxxx&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>IF…..ELSE…：条件选择语句</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 布尔表达式</span><br><span class="line">&#123;sql语句/语句块&#125;</span><br><span class="line">[<span class="keyword">else</span></span><br><span class="line">&#123;sql语句|语句块&#125;]</span><br></pre></td></tr></table></figure></li><li><p>GOTO：无条件转移语句</p><p>Goto &lt;语句标号&gt; 理解为函数名即可，例如   temp函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">temp:</span><br><span class="line">select....</span><br><span class="line"></span><br><span class="line">goto temp</span><br></pre></td></tr></table></figure></li><li><p>WHILE：循环语句</p></li><li><p>BREAK：退出循环</p></li><li><p>CONTINUE：重新启动循环语句</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while 布尔表达式</span><br><span class="line">&#123;SQL语句或语句块&#125;</span><br><span class="line">[BREAK <span class="operator">|</span> continue]</span><br><span class="line">&#123;SQL语句或语句块&#125;..........</span><br></pre></td></tr></table></figure></li><li><p>WAITFOR：设置语句执行的延期时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">waitfor delay 间隔</span><br><span class="line">waitfor <span class="type">time</span> 时间点</span><br></pre></td></tr></table></figure></li><li><p>RETURN：无条件返回语句</p><p>retuan xxxx</p></li></ul><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>可以理解为定义一个函数，放在服务器，然后用户的一系列操作可以不用在客户端运行，而只要传值到服务器允许即可。</p><h4 id="存储过程的创建和删除"><a href="#存储过程的创建和删除" class="headerlink" title="存储过程的创建和删除"></a>存储过程的创建和删除</h4><p>注意的是存储过程名不能超过128个字符，每个存储过程最多1024参数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>创建存储过程名</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名[(参数类型[<span class="operator">=</span>默认值][OUTPUT])];</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">T<span class="operator">-</span><span class="keyword">SQL</span>语句块</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除存储过程名</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> stu_count;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>统计软件工程的学生人数</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> stu_count[<span class="variable">@deptid</span> <span class="type">int</span>,<span class="variable">@stucount</span> <span class="type">int</span> OUTPUT]</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@stucount</span> <span class="operator">=</span> <span class="built_in">count</span>(id) <span class="keyword">from</span> student <span class="keyword">where</span> <span class="variable">@deptid</span><span class="operator">=</span>&quot;软件工程&quot;;</span><br></pre></td></tr></table></figure><h4 id="存储过程的调用"><a href="#存储过程的调用" class="headerlink" title="存储过程的调用"></a>存储过程的调用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Execute 接收返回值的变量=过程名(&#123;参数[OUTPUT]&#125;);</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>执行</span><br><span class="line"><span class="keyword">declare</span> <span class="variable">@deptid</span> <span class="type">int</span>,<span class="variable">@stucount</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable">@ret</span> <span class="type">int</span> <span class="comment">-----返回值，且定为数字</span></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@deptid</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">execute</span> <span class="variable">@ret</span><span class="operator">=</span>stu_count(<span class="variable">@deptid</span>,<span class="variable">@stucount</span> OUTPUT)</span><br></pre></td></tr></table></figure><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>当insert，update，delete等操作时，sql会自动执行触发器定义的语句，确保对数据的处理必须符合这些语句定义的规则</p><ul><li><p>后触发AFTER：触发操作完成后触发，如果触发操作自身出错，则回滚；如果正确，触发器执行时也可以控制操作是否回滚</p></li><li><p>替代触发INSTEAD OF</p><p>触发操作发生时触发，用触发器内的操作代替正常的操作</p></li></ul><p>作用</p><ul><li>强化约束：触发器能够实现比CHECK语句更为复杂的约束</li><li>跟踪变化：触发器可以侦测数据库内的操作，从而不允许数据库中未经许可的指定更新和变化</li><li>级联运行：触发器可以侦测数据库内的操作，并自动地级联影响整个数据库的各项内容</li><li>存储过程的调用：为了响应数据库更新，触发器可以调用一个或多个存储过程，还可以将操作放到其他语言进行调用。</li></ul><h4 id="触发器创建和删除"><a href="#触发器创建和删除" class="headerlink" title="触发器创建和删除"></a>触发器创建和删除</h4><p>其中FOR和ALTER表示 后触发，INSTEAD OF表示 替代触发。</p><p>INSERT，UPDATE，DELETE可以自己定制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>创建</span><br><span class="line">CREATE TRIGGER 触发器名称 ON &#123;表名 | 视图名&#125;</span><br><span class="line">&#123;</span><br><span class="line">&#123;&#123;FOR|AFTER|INSTEAD OF&#125;&#123;[INSERT][,][UPDATE][,][DELETE]&#125;&#125;</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">T<span class="operator">-</span><span class="keyword">SQL</span>语句</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span></span><br></pre></td></tr></table></figure><h4 id="触发器的使用"><a href="#触发器的使用" class="headerlink" title="触发器的使用"></a>触发器的使用</h4><p>触发器相关的，还有两个临时表,Inserted表和Deleted表。是sql触发器执行时创建的临时表。其中Inserted表保存了新插入表的记录，Deleted表保存了新删除的表记录。</p><table><thead><tr><th>表名</th><th>Insert</th><th>Delete</th><th>Update</th></tr></thead><tbody><tr><td>Inserted表</td><td>新纪录</td><td>空</td><td>新记录</td></tr><tr><td>Deleted表</td><td>空</td><td>原记录</td><td>原记录</td></tr></tbody></table><p>使用示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>要求<span class="comment">---class里面的cid更改，student里面的cid也跟着更改</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> check_classid <span class="keyword">on</span> class</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable">@old</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable">@new</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@old</span><span class="operator">=</span>(<span class="keyword">select</span> cid <span class="keyword">from</span> deleted)</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@new</span><span class="operator">=</span>(<span class="keyword">select</span> cid <span class="keyword">from</span> Inserted)</span><br><span class="line">IF <span class="keyword">Update</span>(cid) <span class="keyword">and</span> @<span class="variable">@rowcount</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> cid<span class="operator">=</span><span class="variable">@new</span> <span class="keyword">where</span> cid<span class="operator">=</span><span class="variable">@old</span></span><br></pre></td></tr></table></figure><h2 id="关系数据库模式设计"><a href="#关系数据库模式设计" class="headerlink" title="关系数据库模式设计"></a>关系数据库模式设计</h2><p>模式设计的四个问题</p><ul><li><p>数据冗余</p><p>有teacher表(name,address,course)，其中course为主键，如果这个老师教了多门课程，则会有多个数据，会造成冗余</p></li><li><p>更新异常</p><p>上面的例子，如果这个老师地址改了，我们有多条数据，但是没有都更新地址信息。这就是更新异常</p></li><li><p>插入异常</p><p>course为主键，如果有一个新老师来，但是暂时没教课程，我们应该将课程置为空，但是course是主键，不允许为空</p></li><li><p>删除异常</p><p>如果老师不教这门课，应该是删除course的值，但是course的值不能删</p></li></ul><p>解决，我们应该让数据之间的依赖放到不同表，这样可以得到小的数据冗余。但是如果多个表，我们又需要连接查询，对性能消耗大。这些模式就是需要解决的问题。下面进行讨论</p><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><blockquote><p>Ex:student(name,course_id,score);</p><p>这个表中，任意的name和course，只有一个score与之对应。称存在{name,course}属性集到属性集{score}的依赖。下面给出定义</p></blockquote><p><strong>函数依赖：</strong>设关系模式R(A1,A2,…An)，简记为R(U)。X和Y是U的子集。r是R的任意一个实例（关系）。若r的任意两个元组 t1、t2，由t1[X]=t2[X]可导出t1[Y]=t2[Y]，即如果X相等，Y也相等。则称Y函数依赖于X 或 X函数决定Y。记X-&gt;Y</p><p><strong>平凡函数依赖：</strong>对于函数依赖X-&gt;Y，如果Y不包含X，则称为平凡函数依赖集，否则为不平凡函数依赖</p><h4 id="函数依赖集"><a href="#函数依赖集" class="headerlink" title="函数依赖集"></a>函数依赖集</h4><p><strong>函数依赖集的逻辑蕴含</strong>：设F是关系模式R的一个函数依赖集，X和Y是R的属性子集，若从F的函数依赖中能推出 X-&gt;Y，则称F逻辑蕴含X-&gt;Y，记作 F|=X-&gt;Y（|和=连在一起，这里写不出来）</p><p><strong>函数依赖集的闭包</strong> : </p><p>定义：设F是关系模式R的一个函数依赖集，被函数依赖集F全体逻辑蕴含的函数依赖构成的集合称为F的闭包，记作F+。下面是理解</p><p>F : FD的集合称为函数依赖集，则F中的所有FD可推导出所有FD的集合记为F+</p><p>下面是一些Armstrong，因为每本书说法都不一样，就用英文写出名字</p><ul><li>reflexity：B包含A , A-&gt;B成立</li><li>augmentation：若A-&gt;B则，AC-&gt;BC (AC表示A并C，并非交)</li><li>transitivity：若A-&gt;B，则B-&gt;C，则A-&gt;C</li><li>self-determination：A-&gt;A</li><li>decomposition：若A-&gt;BC，则A-&gt;B，且A-&gt;C</li><li>union：若A-&gt;C，A-&gt;B，则A-&gt;BC</li><li>composition：若A-&gt;B，C-&gt;D，则AC-&gt;BD</li></ul><blockquote><p>例 给定关系 R(A,B,C,D,E,F)和R上的一个函数依赖集F=(A-&gt;BC,B-&gt;E,CD-&gt;EF)。AD-&gt;F是否成立</p><ol><li>A-&gt;BC(已知)</li><li>A-&gt;C 分解律</li><li>AD-&gt;CD 增广律</li><li>CD-&gt;EF 已知</li><li>AD-&gt;EF 传递律</li><li>AD-&gt;F 分解律</li></ol></blockquote><p><strong>属性集的闭包：（定义写的太傻逼，这里直接写例子）</strong>对F，F+中所有 X-&gt;A中 A的集合称为X的关于F的闭包，记为X+。可以理解为X+表示所有X可以决定的属性。</p><p><strong>函数依赖集的覆盖</strong>：设S1和S2是两个函数依赖集，若S1+ 包含 S2+，则称S2是S1的覆盖（或称S2覆盖S1）</p><p><strong>函数依赖集的等价：</strong>设S1和S2是两个函数依赖集，若S1+包含S2+，S2+也包含S1+，则S1与S2等价</p><p><strong>最小函数依赖集：</strong>当且仅当函数依赖集F满足如下条件，F是最小函数依赖集：</p><ol><li>F的每个函数依赖的右边只有一个属性</li><li>F不可约，指F中的每个X-&gt;Y不可删除，即F-{X-&gt;Y}与F不等价</li><li>F的每个函数依赖的左部不可约，即删除任何一个函数依赖左边的任何一个属性都会使F转变为一个不等价于原来F的集合</li></ol><blockquote><p>例 给定学生关系模式 Student(S#,Sname,age,sex)</p><ol><li><strong>F1={S#-&gt;Sname,S#-&gt;age,S#-&gt;sex} 是Student的最小函数依赖集</strong></li><li>F2={S#-&gt;{S#,Sname}}，S#-&gt;age，S#-&gt;sex} <strong>不是</strong>最小函数依赖集，因为函数依赖S#-&gt;{S#,Sname}的右边不是单属性</li><li>F3={S#-&gt;Sname，{S#,Sname} -&gt; age , S#-&gt;sex} <strong>不是</strong>最小函数依赖集，因为{S#,Sname} -&gt; age左部可约，Sname是可删除的。而且删除后的函数依赖集与F3等价</li><li>F4={S#-&gt;S# , S#-&gt;Sname , S# -&gt; age , S#-&gt;sex} <strong>不是</strong>最小函数依赖集，S#-&gt;S#是平凡函数依赖，是可删除的，且删除之后函数依赖集与F4等价</li></ol></blockquote><p>有了最小函数依赖集，如果能找到与F等价的一个最小函数依赖集，则DBMS只要实现最小函数依赖集就可保证F的有效性。而又可以保证DBMS负担最轻。</p><blockquote><p>求最小函数依赖集，例 给定关系 R(A,B,C,D) 以及R上的一个函数依赖 F={A-&gt;BC, B-&gt;C , A-&gt;B, AB-&gt;C , AC-&gt;D}，求与F等价的函数依赖集</p><ol><li><p>去除重复函数依赖</p><p>F(A-&gt;B , A-&gt;C , B-&gt;C , AB-&gt;C , AC-&gt;D)</p></li><li><p>消去左部冗余属性</p><p>AB-&gt;C，有A-&gt;C===&gt; AB-&gt;BC ===&gt; AB-&gt;C，所以AB-&gt;C是冗余属性</p><p>AC-&gt;D,  有 A-&gt;C ===&gt; A-&gt;AC====&gt; 得到 A-&gt;D</p><p>最后为 F={A-&gt;B , A-&gt;C , B-&gt;C , A-&gt;D}</p></li><li><p>消除冗余函数依赖</p><p>A-&gt;B,B-&gt;C 可以推出 A-&gt;C，去掉A-&gt;C</p><p>F={A-&gt;B,B-&gt;C , A-&gt;D}</p></li></ol></blockquote><h4 id="码的形式化定义"><a href="#码的形式化定义" class="headerlink" title="码的形式化定义"></a>码的形式化定义</h4><p><strong>关系模式的码：</strong>给定关系模式R(U)，以及R的一个函数依赖集F。设X是U的一个子集，IF</p><ol><li>X-&gt;U 属于F+，则X是R的一个超码</li><li>同时，如果不存在X的真子集Y，使得Y-&gt;U成立，则X是R的一个候选码。</li></ol><blockquote><p>例 F={Tname-&gt;Addr , C#-&gt;Cname , C# -&gt; Tname}，则有 C#-&gt;{Tname,Addr,C#,Tname}，C#是R的候选码。</p></blockquote><blockquote><p>若 C# - &gt; Tname 不成立，则候选码 为 {Tname, C# }</p></blockquote><h3 id="模式的分解"><a href="#模式的分解" class="headerlink" title="模式的分解"></a>模式的分解</h3><p><strong>模式分解：</strong>设有关系模式R(U)和R1(U1)，R2(U2)……Rk(Uk)，其中U=U1并U2并…..Uk，设α={R1,R2,….Rk}，则称α为R的一个模式分解。</p><ol><li>模式分解是属性集的分解，即R的属性集U被划分为U1,U2….。注意模式分解中允许这些属性子集之间有重复属性，但是U的每个属性都需要投影出去</li><li>模式分解是函数依赖集的分解。</li></ol><p>模式分解的标准（但有时无法同时满足，满足其中之一也可）</p><ul><li>无损连接：分解之前的信息应能通过分解后的模式无损恢复，没有信息丢失。</li><li>保持函数依赖：分解之前的所有函数依赖在分解后应全部保持下来，避免破坏其语义完整性。</li></ul><h4 id="无损连接"><a href="#无损连接" class="headerlink" title="无损连接"></a>无损连接</h4><p>设R是关系模式，α是R的一个模式分解：α={R1,R2…..Rk}，F是R上的一个函数依赖集。若对R中满足F的每个关系r都有 </p><p>R=R1(r)⧓R2(r)⧓…….Rk(r)。则称这个分解α相对于F是无损连接分解。</p><p><strong>-无损连接测试</strong></p><ol><li><p>Chase方法：适用于一个关系模式分解成三个以上模式时的测试</p><p>执行过程如下（后面有例题）</p><ol><li>构造一个k行n列的表格，每行对应一个模式Ri(1&lt;= i &lt;=k)，每列对应一个属性Aj (1&lt;= j &lt;= n)，若Aj在Ri中，则表格的第i行第j列处填上aj，否则填上符号bij</li><li>检查F中的每个函数依赖，并修改表格中的元素。对于F中的函数依赖X-&gt;Y，若表格中有两行在X分量上相等，在Y分量上不想等，则修改Y。修改规则：若Y的分量中有一个aj，则另一个也修改为aj；如果没有aj，则用其中一个bij替换另一个符号（i是所有符b中最小的行数）</li><li>若修改后，表格中有一行全是a，即a1,a2…..an，则a相对于F是无损连接的分解，过程结束。否则再执行第二步，知道表格不能修改位置，即重复执行2后表格元素保持不变，说明 α 相对于F不是无损连接的分解</li></ol></li><li><p>另一种只适合一个关系模式一分为二的测试</p></li></ol><blockquote><p>chase例题</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/8249F0AC8974C4BE11ED2BD8F0E22C11.jpg" alt="img"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/92C9A16AD1D7F773D0E9D6000A3C36F8.jpg" alt="img"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/0D41B7CB10DEBA63D80AF661E5920383.jpg" alt="img"></p></blockquote><p>第二种的做法</p><p>给定关系关系模式α={R1,R2}，当且仅当以下两个函数依赖中至少有一个成立时，α是无损连接的分解：(R1∩R2)-&gt;(R1-R2)          (R1∩R2)-&gt;(R2-R1)</p><h4 id="保护函数依赖"><a href="#保护函数依赖" class="headerlink" title="保护函数依赖"></a>保护函数依赖</h4><p>模式分解的另一个标准：保持函数依赖要求关系模式R的每一个不平凡函数依赖在分解过程中都保留下来</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211220210736945.png" alt="image-20211220210736945"></p><blockquote><p>给定关系R(city , street , zip)，以及R上的一个函数依赖集 F={(city , street)-&gt;zip , zip-&gt;city}</p><p>1，判断无损连接（省略）</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/6F241CEAE74F31613196B9261F598B47.jpg" alt="img"></p></blockquote><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><p><strong>范式：</strong>是满足特定要求的关系模式。从低到高有，第一范式(1NF) , 2NF , 3NF , BCNF范式 , 4NF , 5NF</p><p><strong>函数依赖图</strong>如下</p><p>假设关系模式R的一个函数依赖集F={S#-&gt;Sname , S#-&gt;City , City-&gt;Status}</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211222184419963.png" alt="image-20211222184419963"></p><ul><li><strong>1NF</strong>：对于关系模式R的任一实例，其元组的每一个属性值都只含有一个值</li><li><strong>2NF：</strong>当且仅当R属于1NF，且R的每一个非主属性都完全函数依赖于主码时，则R属于2NF<ul><li><strong>完全函数依赖：</strong>对于函数依赖 W-&gt;A，若不存在 W⊃X，并且X-&gt;A成立，则称W-&gt;A为完全函数依赖，否则为局部函数依赖</li></ul></li><li><strong>3NF：</strong>当且仅当R属于2NF，且R的每一个非主属性都不传递依赖于主码时，则R属于3NF<ul><li>传递依赖：若Y-&gt;X , X-&gt;A，并且X-&gt;Y不成立，A不是X的子集，则称A传递依赖于Y</li></ul></li><li><strong>BCNF：</strong>如果关系模式R的所有不平凡的、完全的函数依赖的决定因素都是候选码，则R属于BCNF</li></ul><p><strong>规范化算法</strong></p><p>无损连接并且保持函数依赖的分解到3NF算法</p><p><strong>1算法：保持函数依赖的分解到3NF</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/C770EDCD610844D715FFBB4EF6823F3F.jpg" alt="img"></p><p><strong>2算法：无损连接并且保持函数依赖的分解到3NF</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/6F7F9E27227DDDB04A819704A5CA0857.jpg" alt="img"></p><p><strong>3算法 无损连接的分解到BCNF算法</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/732C5E260F2C8A557044FD7D30A20B0C.jpg" alt="img"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/C0F696A482EC7F661DF4CECD60D03ADF.jpg" alt="img"></p><h4 id="规范化过程总结"><a href="#规范化过程总结" class="headerlink" title="规范化过程总结"></a>规范化过程总结</h4><ol><li>对1NF模式投影，消除非主属性对主码的局部函数依赖，可将关系模式规范化到2NF</li><li>对2NF模式投影，消除非主属性对主码的传递函数依赖，可将关系模式规范化到3NF</li><li>对3NF模式投影，消除左边不是候选码的函数依赖，可将关系模式规范化到BCNF</li><li>若要求保持函数依赖，则总可以分解到满足3NF，但不一定满足BCNF，即BCNF可以达到无损连接，但不一定保持函数依赖</li><li>若要求保持函数依赖和无损连接，则总可以达到3NF，但不一定满足BCNF</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="2021/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>2021/Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>单线程 + 多路 IO 复用</p><h2 id="1-redis安装"><a href="#1-redis安装" class="headerlink" title="1.redis安装"></a>1.redis安装</h2><p>Centos系统</p><h3 id="1-安装C语言的编译环境"><a href="#1-安装C语言的编译环境" class="headerlink" title="1.安装C语言的编译环境"></a>1.安装C语言的编译环境</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install </span>centos-release-<span class="keyword">scl </span><span class="keyword">scl-utils-build</span></span><br><span class="line"><span class="keyword">yum </span><span class="keyword">install </span>-y devtoolset<span class="number">-8</span>-toolchain</span><br><span class="line"><span class="keyword">scl </span>enable devtoolset<span class="number">-8</span> <span class="keyword">bash</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">安装gcc</span></span><br><span class="line"><span class="keyword">yum </span><span class="keyword">install </span>gcc</span><br></pre></td></tr></table></figure><h3 id="2-安装redis"><a href="#2-安装redis" class="headerlink" title="2.安装redis"></a>2.安装redis</h3><ul><li><p>下载redis的tar包，解压</p></li><li><p>在redis目录中执行make命令</p></li><li><p>make install</p></li><li><p>安装目录为/usr/local/bin</p></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</span><br><span class="line"></span><br><span class="line">redis-<span class="keyword">check</span>-aof：修复有问题的AOF文件</span><br><span class="line"></span><br><span class="line">redis-<span class="keyword">check</span>-dump：修复有问题的dump.rdb文件</span><br><span class="line"></span><br><span class="line">redis-sentinel：Redis集群使用</span><br><span class="line"></span><br><span class="line">redis-<span class="keyword">server</span>：Redis服务器启动命令</span><br><span class="line"></span><br><span class="line">redis-cli：客户端，操作入口</span><br></pre></td></tr></table></figure><h3 id="3-前台启动（不推荐）"><a href="#3-前台启动（不推荐）" class="headerlink" title="3.前台启动（不推荐）"></a>3.前台启动（不推荐）</h3><p>直接用 redis-server</p><p>命令行窗口不能关闭</p><h3 id="4-后台启动（推荐）"><a href="#4-后台启动（推荐）" class="headerlink" title="4.后台启动（推荐）"></a>4.后台启动（推荐）</h3><ol><li><p>先进行配置，/opt/redis/redis.conf</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">daemonize</span> <span class="literal">no</span></span><br><span class="line">改为<span class="literal">yes</span></span><br></pre></td></tr></table></figure></li><li><p>后台启动redis，redis-server /opt/redis/redis.conf</p></li><li><p>```<br>[root@localhost redis]# /usr/local/bin/redis-server /opt/redis/redis.conf </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">4</span>. ![image-<span class="number">20210615175718115</span>](http<span class="variable">s:</span>//blog-<span class="number">1257997408</span>.<span class="built_in">cos</span>.ap-guangzhou.myqcloud.<span class="keyword">com</span>/images/image-<span class="number">20210615175849529</span>.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis-cli 可以进入redis命令行，输入ping，如果输出pong表示正常状态</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20210615175849529</span>](http<span class="variable">s:</span>//blog-<span class="number">1257997408</span>.<span class="built_in">cos</span>.ap-guangzhou.myqcloud.<span class="keyword">com</span>/images/image-<span class="number">20210615175718115</span>.png)</span><br><span class="line"></span><br><span class="line">### redis关闭</span><br><span class="line"></span><br><span class="line">redis-cli shutdown或 redis-cli 进入命令行 再shutdown</span><br><span class="line"></span><br><span class="line">多实例关闭，指定端口关闭：redis-cli -<span class="keyword">p</span> <span class="number">6379</span> shutdown</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 基本操作</span><br><span class="line"></span><br><span class="line">默认<span class="number">16</span>个数据库，类似数组下标从<span class="number">0</span>开始，初始**默认使用<span class="number">0</span>号库**</span><br><span class="line"></span><br><span class="line">使用命令 **select  \<span class="symbol">&lt;dbid&gt;</span>**来切换数据库。如: select <span class="number">8</span> </span><br><span class="line"></span><br><span class="line">统一密码管理，所有库同样密码。</span><br><span class="line"></span><br><span class="line">**dbsize**查看当前数据库的key的数量</span><br><span class="line"></span><br><span class="line">**flushdb**清空当前库</span><br><span class="line"></span><br><span class="line">**flushall**通杀全部库</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## <span class="number">2</span>.常用五大数据结构</span><br><span class="line"></span><br><span class="line">### 键(key)</span><br><span class="line"></span><br><span class="line">- <span class="built_in">keys</span> *查看当前库所有key   (匹配：<span class="built_in">keys</span> *<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">- <span class="keyword">set</span> k1  v1 插入键值对</span><br><span class="line"></span><br><span class="line">- <span class="built_in">exists</span> key 判断某个key是否存在</span><br><span class="line"></span><br><span class="line">- <span class="built_in">type</span> key 查看你的key是什么类型</span><br><span class="line"></span><br><span class="line">- del key    删除指定的key数据</span><br><span class="line"></span><br><span class="line">- unlink key  根据value选择非阻塞删除(**异步删除**)</span><br><span class="line"></span><br><span class="line">​仅将<span class="built_in">keys</span>从keyspace元数据中删除，真正的删除会在后续异步操作。</span><br><span class="line"></span><br><span class="line">- expire key <span class="number">10</span>  <span class="number">10</span>秒钟：为给定的key设置过期时间</span><br><span class="line"></span><br><span class="line">- ttl key 查看还有多少秒过期，-<span class="number">1</span>表示永不过期，-<span class="number">2</span>表示已过期</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">- select 命令切换数据库</span><br><span class="line"></span><br><span class="line">- dbsize 查看当前数据库的key的数量</span><br><span class="line"></span><br><span class="line">- flushdb 清空当前库</span><br><span class="line"></span><br><span class="line">- flushall 清空全部库</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### <span class="number">2.1</span> 字符串（<span class="built_in">string</span>）</span><br><span class="line"></span><br><span class="line">String是Redis最基本的类型，也是键值对的形式。且是二进制安全的，可以包含任何数据。</span><br><span class="line"></span><br><span class="line">String中value大小最大是<span class="number">512</span>M</span><br><span class="line"></span><br><span class="line">#### 常用命令</span><br><span class="line"></span><br><span class="line">- <span class="keyword">set</span> \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;value&gt;</span> [NX | EX | XX | PX]</span><br><span class="line"></span><br><span class="line">  NX：当前数据库中key不存在时，将K-V添加到数据库</span><br><span class="line"></span><br><span class="line">  XX：当前数据库中key存在时，将K-V添加到数据库，与NX参数互斥</span><br><span class="line"></span><br><span class="line">  EX：key的超时秒数</span><br><span class="line"></span><br><span class="line">  PX：key的超时毫秒数，与EX互斥</span><br><span class="line"></span><br><span class="line">- <span class="built_in">get</span> \<span class="symbol">&lt;key&gt;</span> 查询对应的键值</span><br><span class="line"></span><br><span class="line">- <span class="keyword">append</span>  \<span class="symbol">&lt;key&gt;</span>\<span class="symbol">&lt;value&gt;</span>将给定的\<span class="symbol">&lt;value&gt;</span> 追加到原值的末尾</span><br><span class="line"></span><br><span class="line">- <span class="built_in">strlen</span>  \<span class="symbol">&lt;key&gt;</span>获得值的长度</span><br><span class="line"></span><br><span class="line">- setnx  \<span class="symbol">&lt;key&gt;</span>\<span class="symbol">&lt;value&gt;</span>只有在 key 不存在时   设置 key 的值</span><br><span class="line"></span><br><span class="line">- incr  \<span class="symbol">&lt;key&gt;</span></span><br><span class="line"></span><br><span class="line">  将 key 中储存的数字值增<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  只能对数字值操作，如果为空，新增值为<span class="number">1</span></span><br><span class="line"></span><br><span class="line">- decr  \<span class="symbol">&lt;key&gt;</span></span><br><span class="line"></span><br><span class="line">  将 key 中储存的数字值减<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  只能对数字值操作，如果为空，新增值为-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">- incrby / decrby  \<span class="symbol">&lt;key&gt;</span> &lt;步长&gt;将 key 中储存的数字值增减。自定义步长。</span><br><span class="line"></span><br><span class="line">- mset  \<span class="symbol">&lt;key1&gt;</span> \<span class="symbol">&lt;value1&gt;</span> \<span class="symbol">&lt;key2&gt;</span> \<span class="symbol">&lt;value2&gt;</span>  ..... </span><br><span class="line"></span><br><span class="line">  同时设置一个或多个 key-value对  </span><br><span class="line"></span><br><span class="line">- mget  \<span class="symbol">&lt;key1&gt;</span> \<span class="symbol">&lt;key2&gt;</span> \<span class="symbol">&lt;key3&gt;</span> .....</span><br><span class="line"></span><br><span class="line">  同时获取一个或多个 value  </span><br><span class="line"></span><br><span class="line">- msetnx \<span class="symbol">&lt;key1&gt;</span> \<span class="symbol">&lt;value1&gt;</span> \<span class="symbol">&lt;key2&gt;</span> \<span class="symbol">&lt;value2&gt;</span>  ..... </span><br><span class="line"></span><br><span class="line">  同时设置一个或多个 key-value 对，**当且仅当所有给定 key 都不存在。原子性，有一个失败则都失败**</span><br><span class="line"></span><br><span class="line">- getrange  \<span class="symbol">&lt;key&gt;</span>&lt;起始位置&gt;&lt;结束位置&gt;</span><br><span class="line"></span><br><span class="line">  获得值的范围，类似java中的substring，**前包，后包**</span><br><span class="line"></span><br><span class="line">- setrange  \<span class="symbol">&lt;key&gt;</span>&lt;起始位置&gt;\<span class="symbol">&lt;value&gt;</span></span><br><span class="line"></span><br><span class="line">  用 \<span class="symbol">&lt;value&gt;</span>  覆写\<span class="symbol">&lt;key&gt;</span>所储存的字符串值，从&lt;起始位置&gt;开始(**索引从<span class="number">0</span>开始**)。包含前后</span><br><span class="line"></span><br><span class="line">- setex  \<span class="symbol">&lt;key&gt;</span> &lt;过期时间&gt; \<span class="symbol">&lt;value&gt;</span></span><br><span class="line"></span><br><span class="line">  设置键值的同时，设置过期时间，单位秒。</span><br><span class="line"></span><br><span class="line">- getset \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;value&gt;</span></span><br><span class="line"></span><br><span class="line">  以新换旧，设置了新值同时获得旧值。</span><br><span class="line"></span><br><span class="line">#### 数据结构</span><br><span class="line"></span><br><span class="line">String结构类似Java里面的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配</span><br><span class="line"></span><br><span class="line">分配策略：长度小于<span class="number">1</span>M时，当字符串长度大于当前分配空间的长度，分配空间翻倍一次。</span><br><span class="line"></span><br><span class="line">​长度大于<span class="number">1</span>M时，扩容一次只会多扩<span class="number">1</span>M的空间。最大长度<span class="number">512</span>M</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### <span class="number">2.2</span> 列表（List）</span><br><span class="line"></span><br><span class="line">双向链表结构。对两端的操作性能高，通过索引下标操作中间的节点性能会较差。</span><br><span class="line"></span><br><span class="line">#### 常用命令</span><br><span class="line"></span><br><span class="line">- lpush/rpush  \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;value1&gt;</span> \<span class="symbol">&lt;value2&gt;</span> \<span class="symbol">&lt;value3&gt;</span> .... 从左边/右边插入一个或多个值。</span><br><span class="line"></span><br><span class="line">- lpop/rpop  \<span class="symbol">&lt;key&gt;</span>从左边/右边吐出一个值。**值如果没有了，键就会被删除。**</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">- rpoplpush  \<span class="symbol">&lt;key1&gt;</span> \<span class="symbol">&lt;key2&gt;</span>从 \<span class="symbol">&lt;key1&gt;</span>列表右边吐出一个值，插到\<span class="symbol">&lt;key2&gt;</span>列表左边。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">- lrange \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;start&gt;</span> \<span class="symbol">&lt;stop&gt;</span></span><br><span class="line"></span><br><span class="line">  按照索引下标获得元素(从左到右)</span><br><span class="line"></span><br><span class="line">- lrange mylist <span class="number">0</span> -<span class="number">1</span>  **<span class="number">0</span>左边第一个，-<span class="number">1</span>右边第一个，（<span class="number">0</span>  -<span class="number">1</span>表示获取所有）**</span><br><span class="line"></span><br><span class="line">- lindex \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;index&gt;</span>按照索引下标获得元素(从左到右)</span><br><span class="line"></span><br><span class="line">- llen \<span class="symbol">&lt;key&gt;</span>获得列表长度 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">- linsert \<span class="symbol">&lt;key&gt;</span>  before \<span class="symbol">&lt;value&gt;</span> \<span class="symbol">&lt;newvalue&gt;</span>在 \<span class="symbol">&lt;value&gt;</span>的后面插入\<span class="symbol">&lt;newvalue&gt;</span>插入值</span><br><span class="line"></span><br><span class="line">- lrem \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;n&gt;</span> \<span class="symbol">&lt;value&gt;</span>从左边删除n个value(从左到右)</span><br><span class="line"></span><br><span class="line">- lset \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;index&gt;</span> \<span class="symbol">&lt;value&gt;</span>将列表key下标为<span class="built_in">index</span>的值替换成value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 数据结构</span><br><span class="line"></span><br><span class="line">List的数据结构为快速链表 quickList</span><br><span class="line"></span><br><span class="line">​列表元素较少时，会采用一块**连续的内存存储**，结构为 ziplist，压缩列表。所有元素紧挨在一起存储，分配的是一块连续的内存。</span><br><span class="line"></span><br><span class="line">​Redis将 链表 和 ziplist 结合起来组成 quicklist。也就是多个ziplist 使用双向指针。形成双向链表。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### <span class="number">2.3</span> 集合（<span class="keyword">set</span>）</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> 对外提供的功能与<span class="keyword">list</span>类似。特殊在于可以**自动排重**的。<span class="keyword">set</span>提供了判断某个成员是否在一个<span class="keyword">set</span>集合内的重要接口。</span><br><span class="line"></span><br><span class="line">Set是<span class="built_in">string</span>类型的**无序集合。底层是一个value为null的hash表**，所以添加，删除，查找的复杂度都是<span class="keyword">o</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 常用命令</span><br><span class="line"></span><br><span class="line">- sadd \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;value&gt;</span> \<span class="symbol">&lt;value&gt;</span></span><br><span class="line"></span><br><span class="line">  将一个或多个member元素加入到集合 key 中，已经存在的member元素将被忽略</span><br><span class="line"></span><br><span class="line">- smembers \<span class="symbol">&lt;key&gt;</span>取出该集合的所有值。</span><br><span class="line"></span><br><span class="line">- sismember \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;value&gt;</span>判断集合 \<span class="symbol">&lt;key&gt;</span>是否为含有该 \<span class="symbol">&lt;value&gt;</span>值，有<span class="number">1</span>，没有<span class="number">0</span></span><br><span class="line"></span><br><span class="line">- scard \<span class="symbol">&lt;key&gt;</span>返回该集合的元素个数。</span><br><span class="line"></span><br><span class="line">- srem \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;value1&gt;</span> \<span class="symbol">&lt;value2&gt;</span> .... 删除集合中的某个元素。</span><br><span class="line"></span><br><span class="line">- spop \<span class="symbol">&lt;key&gt;</span>**随机从该集合中吐出一个值。**</span><br><span class="line"></span><br><span class="line">- srandmember \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;n&gt;</span>随机从该集合中取出n个值。不会从集合中删除 。</span><br><span class="line"></span><br><span class="line">- smove \<span class="symbol">&lt;source&gt;</span> \<span class="symbol">&lt;destination&gt;</span> value把集合中一个值从一个集合移动到另一个集合</span><br><span class="line"></span><br><span class="line">- sinter \<span class="symbol">&lt;key1&gt;</span> \<span class="symbol">&lt;key2&gt;</span>返回两个集合的**交集**元素。</span><br><span class="line"></span><br><span class="line">- sunion  \<span class="symbol">&lt;key1&gt;</span> \<span class="symbol">&lt;key2&gt;</span>返回两个集合的**并集**元素。</span><br><span class="line"></span><br><span class="line">- sdiff \<span class="symbol">&lt;key1&gt;</span> \<span class="symbol">&lt;key2&gt;</span>返回两个集合的**差集**元素(key1中的，不包含key2中的)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 数据结构</span><br><span class="line"></span><br><span class="line">Set 数据结构是dict字典，字典是用哈希表实现的</span><br><span class="line"></span><br><span class="line">Java中HashSet的内部实现使用的是 HashMap，只不过所有的value都指向同一个对象。</span><br><span class="line"></span><br><span class="line">Redis的<span class="keyword">set</span>结构，内部使用hash结构，所有value都指向同一个内部值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### <span class="number">2.4</span> 哈希（Hash）</span><br><span class="line"></span><br><span class="line">Redis hash是一个键值对集合。是一个String类型的 **field 和 value**的映射表，hash 特别适合用于存储对象。</span><br><span class="line"></span><br><span class="line">类似Java中的 <span class="keyword">map</span>&lt;String,Object&gt;</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20210616110003546</span>](http<span class="variable">s:</span>//blog-<span class="number">1257997408</span>.<span class="built_in">cos</span>.ap-guangzhou.myqcloud.<span class="keyword">com</span>/images/image-<span class="number">20210616110003546</span>.png)</span><br><span class="line"></span><br><span class="line">通过 **key+field** 就可以操作对应属性数据。不需要重复存储数据，也不会带来序列化和并发修改控制的问题。</span><br><span class="line"></span><br><span class="line">#### 常用命令</span><br><span class="line"></span><br><span class="line">- hset \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;field&gt;</span> \<span class="symbol">&lt;value&gt;</span>给 \<span class="symbol">&lt;key&gt;</span>集合中的  \<span class="symbol">&lt;field&gt;</span>键赋值 \<span class="symbol">&lt;value&gt;</span></span><br><span class="line"></span><br><span class="line">- hget \<span class="symbol">&lt;key1&gt;</span> \<span class="symbol">&lt;field&gt;</span>从\<span class="symbol">&lt;key1&gt;</span>集合\<span class="symbol">&lt;field&gt;</span>取出 value </span><br><span class="line"></span><br><span class="line">- hmset \<span class="symbol">&lt;key1&gt;</span> \<span class="symbol">&lt;field1&gt;</span> \<span class="symbol">&lt;value1&gt;</span> \<span class="symbol">&lt;field2&gt;</span> \<span class="symbol">&lt;value2&gt;</span>... 批量设置hash的值</span><br><span class="line"></span><br><span class="line">- hexists \<span class="symbol">&lt;key1&gt;</span> \<span class="symbol">&lt;field&gt;</span>查看哈希表 key 中，给定域 field 是否存在。 </span><br><span class="line"></span><br><span class="line">- hkeys \<span class="symbol">&lt;key&gt;</span>列出该hash集合的所有field</span><br><span class="line"></span><br><span class="line">- hvals \<span class="symbol">&lt;key&gt;</span>列出该hash集合的所有value</span><br><span class="line"></span><br><span class="line">- hincrby \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;field&gt;</span> \<span class="symbol">&lt;increment&gt;</span>为哈希表 key 中的域 field 的值加上增量 <span class="number">1</span>  -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">- hsetnx \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;field&gt;</span> \<span class="symbol">&lt;value&gt;</span>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 数据结构</span><br><span class="line"></span><br><span class="line">Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### <span class="number">2.5</span> 有序集合(Zset)</span><br><span class="line"></span><br><span class="line">有序集合与普通集合 <span class="keyword">set</span> 类似，是**没有重复元素**的字符串集合</span><br><span class="line"></span><br><span class="line">不同之处在于，有序集合每个成员都关联了一个  评分（score），这个评分被用来按照从最低分到最高分的方式来排序集合中的成员。**集合的成员是唯一的，但是评分可以是重复的**</span><br><span class="line"></span><br><span class="line">&gt; 因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 常用命令</span><br><span class="line"></span><br><span class="line">- zadd  \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;score1&gt;</span> \<span class="symbol">&lt;value1&gt;</span> \<span class="symbol">&lt;score2&gt;</span> \<span class="symbol">&lt;value2&gt;</span>…</span><br><span class="line"></span><br><span class="line">  将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</span><br><span class="line"></span><br><span class="line">- **zrange \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;start&gt;</span> \<span class="symbol">&lt;stop&gt;</span>  [WITHSCORES]**  </span><br><span class="line"></span><br><span class="line">  返回有序集 key 中，下标在\<span class="symbol">&lt;start&gt;</span> \<span class="symbol">&lt;stop&gt;</span>之间的元素</span><br><span class="line"></span><br><span class="line">  带WITHSCORES，可以让分数一起和值返回到结果集。</span><br><span class="line"></span><br><span class="line">- zrangebyscore key **<span class="built_in">min</span> <span class="built_in">max</span>** [withscores] [limit offset <span class="built_in">count</span>]</span><br><span class="line"></span><br><span class="line">  返回有序集 key 中，所有 score 值介于 <span class="built_in">min</span> 和 <span class="built_in">max</span> 之间(包括等于 <span class="built_in">min</span> 或 <span class="built_in">max</span> )的成员。有序集成员按 score 值递增(从小到大)次序排列。 </span><br><span class="line"></span><br><span class="line">- zrevrangebyscore key **<span class="built_in">max</span> <span class="built_in">min</span>** [withscores] [limit offset <span class="built_in">count</span>]        </span><br><span class="line"></span><br><span class="line">  同上，改为从大到小排列。 </span><br><span class="line"></span><br><span class="line">- zincrby \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;increment&gt;</span> \<span class="symbol">&lt;value&gt;</span>    为元素的score加上增量</span><br><span class="line"></span><br><span class="line">- zrem  \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;value&gt;</span>删除该集合下，指定值的元素 </span><br><span class="line"></span><br><span class="line">- zcount \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;min&gt;</span> \<span class="symbol">&lt;max&gt;</span>统计该集合，分数区间内的元素个数 </span><br><span class="line"></span><br><span class="line">- zrank \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;value&gt;</span>返回该值在集合中的排名，从<span class="number">0</span>开始。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 数据结构</span><br><span class="line"></span><br><span class="line">zset 是一个redis提供的一个特别的数据结构，一方面等价于 Java 数据结构 <span class="keyword">map</span>&lt;String,Double&gt;，可以给每个元素value 赋予一个权重score，另一方面又类似与TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，可以通过score的范围来获取元素的列表。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zset底层使用了俩个数据结构</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. hash，关联元素value和score，保障元素value的唯一性，可以通过value找到相应的score值</span><br><span class="line"><span class="number">2</span>. 跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**跳跃表结构**</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20210616112117821</span>](http<span class="variable">s:</span>//blog-<span class="number">1257997408</span>.<span class="built_in">cos</span>.ap-guangzhou.myqcloud.<span class="keyword">com</span>/images/image-<span class="number">20210616140956166</span>.png)</span><br><span class="line"></span><br><span class="line">如果找<span class="number">51</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 从第<span class="number">2</span>层找<span class="number">1</span>，<span class="number">21</span>.没找到到下一层</span><br><span class="line"><span class="number">2</span>. 第<span class="number">1</span>层，<span class="number">41</span>，<span class="number">61</span>，没找到。再下一层</span><br><span class="line"><span class="number">3</span>. 第<span class="number">0</span>层，<span class="number">51</span>。找到。共查找<span class="number">4</span>次</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## <span class="number">3</span>.Redis 发布和订阅</span><br><span class="line"></span><br><span class="line">类似于 Kafka的机制，一个发布者发布消息，订阅者接收消息</span><br><span class="line"></span><br><span class="line">Redis客户端可以订阅任意数量的频道。</span><br><span class="line"></span><br><span class="line">**客户端订阅频道**</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20210616140949389</span>](http<span class="variable">s:</span>//blog-<span class="number">1257997408</span>.<span class="built_in">cos</span>.ap-guangzhou.myqcloud.<span class="keyword">com</span>/images/image-<span class="number">20210616140949389</span>.png)</span><br><span class="line"></span><br><span class="line">**接收消息**</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20210616140956166</span>](http<span class="variable">s:</span>//blog-<span class="number">1257997408</span>.<span class="built_in">cos</span>.ap-guangzhou.myqcloud.<span class="keyword">com</span>/images/image-<span class="number">20210616112117821</span>.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 命令行实现</span><br><span class="line"></span><br><span class="line">**订阅**</span><br><span class="line"></span><br><span class="line">subscribe channel2</span><br><span class="line"></span><br><span class="line">**发布消息**</span><br><span class="line"></span><br><span class="line">publish channel2 <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">订阅chennel2的客户端就会接收到消息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 注：发布的消息没有持久化，只能先订阅之后，才能收到后续的消息。之前的消息是收不到的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## <span class="number">4</span>.Redis新数据类型</span><br><span class="line"></span><br><span class="line">### <span class="number">4.1</span>Bitmaps</span><br><span class="line"></span><br><span class="line">一个key，带一串二进制码，可以设置<span class="number">0</span>/<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20210616141854995</span>](http<span class="variable">s:</span>//blog-<span class="number">1257997408</span>.<span class="built_in">cos</span>.ap-guangzhou.myqcloud.<span class="keyword">com</span>/images/image-<span class="number">20210616141854995</span>.png)</span><br><span class="line"></span><br><span class="line">可以对每一个位置的设置<span class="number">0</span>/<span class="number">1</span>，使用偏移量表示每个位置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 命令</span><br><span class="line"></span><br><span class="line">- setbit \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;offset&gt;</span> \<span class="symbol">&lt;value&gt;</span>设置Bitmaps中某个偏移量的值（<span class="number">0</span>或<span class="number">1</span>）</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> bit user1 <span class="number">12</span> <span class="number">1</span>   设置key为user，偏移量<span class="number">12</span>的位置为<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  &gt; 在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</span><br><span class="line"></span><br><span class="line">- getbit \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;offset&gt;</span>获取Bitmaps中某个偏移量的值</span><br><span class="line"></span><br><span class="line">- bitcount \<span class="symbol">&lt;key&gt;</span> [start end]，<span class="number">0</span>是起始位置，-<span class="number">1</span>是结束位置，-<span class="number">2</span>倒数第二个</span><br><span class="line"></span><br><span class="line">  统计字符串中 start 到end 值为<span class="number">1</span>的个数</span><br><span class="line"></span><br><span class="line">- bitop <span class="built_in">and</span>(<span class="built_in">or</span>/not/<span class="built_in">xor</span>) \<span class="symbol">&lt;destkey&gt;</span> [key…]  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">and</span>交集，<span class="built_in">or</span>并集，not非，<span class="built_in">xor</span>异或。destkey是接收端，中括号里面的是进行<span class="built_in">and</span>，<span class="built_in">or</span>等操作的数据。符合的数据会保存在destkey中。例如以下交集</span><br><span class="line"></span><br><span class="line">  ![image-<span class="number">20210616143544007</span>](http<span class="variable">s:</span>//blog-<span class="number">1257997408</span>.<span class="built_in">cos</span>.ap-guangzhou.myqcloud.<span class="keyword">com</span>/images/image-<span class="number">20210628100626307</span>.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Bitmaps与<span class="keyword">set</span>对比</span><br><span class="line"></span><br><span class="line">假设网站有<span class="number">1</span>亿用户， 每天独立访问的用户有<span class="number">5</span>千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</span><br><span class="line"></span><br><span class="line">| <span class="keyword">set</span>和Bitmaps存储一天活跃用户对比 |                    |                  |                        |</span><br><span class="line">| -------------------------------- | ------------------ | ---------------- | ---------------------- |</span><br><span class="line">| 数据类型                         | 每个用户id占用空间 | 需要存储的用户量 | 全部内存量             |</span><br><span class="line">| 集合类型                         | <span class="number">64</span>位               | <span class="number">50000000</span>         | <span class="number">64</span>位*<span class="number">50000000</span> = <span class="number">400</span>MB  |</span><br><span class="line">| Bitmaps                          | <span class="number">1</span>位                | <span class="number">100000000</span>        | <span class="number">1</span>位*<span class="number">100000000</span> = <span class="number">12.5</span>MB |</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的</span><br><span class="line"></span><br><span class="line">| <span class="keyword">set</span>和Bitmaps存储独立用户空间对比 |        |        |       |</span><br><span class="line">| -------------------------------- | ------ | ------ | ----- |</span><br><span class="line">| 数据类型                         | 一天   | 一个月 | 一年  |</span><br><span class="line">| 集合类型                         | <span class="number">400</span>MB  | <span class="number">12</span>GB   | <span class="number">144</span>GB |</span><br><span class="line">| Bitmaps                          | <span class="number">12.5</span>MB | <span class="number">375</span>MB  | <span class="number">4.5</span>GB |</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有<span class="number">10</span>万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">| <span class="keyword">set</span>和Bitmaps存储一天活跃用户对比（独立用户比较少） |                    |                  |                        |</span><br><span class="line">| -------------------------------------------------- | ------------------ | ---------------- | ---------------------- |</span><br><span class="line">| 数据类型                                           | 每个userid占用空间 | 需要存储的用户量 | 全部内存量             |</span><br><span class="line">| 集合类型                                           | <span class="number">64</span>位               | <span class="number">100000</span>           | <span class="number">64</span>位*<span class="number">100000</span> = <span class="number">800</span>KB    |</span><br><span class="line">| Bitmaps                                            | <span class="number">1</span>位                | <span class="number">100000000</span>        | <span class="number">1</span>位*<span class="number">100000000</span> = <span class="number">12.5</span>MB |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### <span class="number">4.2</span> HyperLogLog</span><br><span class="line"></span><br><span class="line">解决基数问题。如同<span class="keyword">set</span>，hash，bitmaps等数据结构。不能有重复数据。但是HyperLogLog使用的内存更少。一般用于统计网站独立ip访问量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">什么是基数?</span><br><span class="line"></span><br><span class="line">比如数据集 &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>&#125;， 那么这个数据集的基数集为 &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> ,<span class="number">7</span>, <span class="number">8</span>&#125;, 基数(不重复元素)为<span class="number">5</span>。 基数估计就是在误差可接受的范围内，快速计算基数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 命令</span><br><span class="line"></span><br><span class="line">- pfadd \<span class="symbol">&lt;key&gt;</span> \&lt; element&gt; [element ...]  </span><br><span class="line"></span><br><span class="line">  pfadd k1 <span class="string">&quot;java&quot;</span></span><br><span class="line"></span><br><span class="line">- pfcount \<span class="symbol">&lt;key&gt;</span> [key] 计算key里面有多少数量</span><br><span class="line"></span><br><span class="line">- pfmerge \<span class="symbol">&lt;destkey&gt;</span> \<span class="symbol">&lt;sourcekey&gt;</span> [sourcekey....]  将一个或多个key合并，将结果存到destkey中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### <span class="number">4.3</span> Geospatial</span><br><span class="line"></span><br><span class="line">​Redis <span class="number">3.2</span> 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的<span class="number">2</span>维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 命令</span><br><span class="line"></span><br><span class="line">- geoadd \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;longitude&gt;</span> \<span class="symbol">&lt;latitude&gt;</span> \<span class="symbol">&lt;member&gt;</span> [longitude latitude member.....]</span><br><span class="line"></span><br><span class="line">  添加地理位置  经度 纬度 名称，可添加多个</span><br><span class="line"></span><br><span class="line">  geoadd chin<span class="variable">a:city</span>  <span class="number">121</span>  <span class="number">90</span>  shanghai   </span><br><span class="line"></span><br><span class="line">  &gt; 注：两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 有效的经度从 -<span class="number">180</span> 度到 <span class="number">180</span> 度。有效的纬度从 -<span class="number">85.05112878</span> 度到 <span class="number">85.05112878</span> 度。</span><br><span class="line"></span><br><span class="line">- geopos  \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;member&gt;</span> [member...]  获得指定地区的坐标值</span><br><span class="line"></span><br><span class="line">- geodist \<span class="symbol">&lt;key&gt;</span> \<span class="symbol">&lt;member1&gt;</span> \<span class="symbol">&lt;member2&gt;</span>  [<span class="keyword">m</span>|km|ft|mi ]  获取两个位置之间的直线距离</span><br><span class="line"></span><br><span class="line">  单位：</span><br><span class="line"></span><br><span class="line">  <span class="keyword">m</span> 表示单位为米[默认值]。</span><br><span class="line"></span><br><span class="line">  km 表示单位为千米。</span><br><span class="line"></span><br><span class="line">  mi 表示单位为英里。</span><br><span class="line"></span><br><span class="line">  ft 表示单位为英尺。</span><br><span class="line"></span><br><span class="line">  如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</span><br><span class="line"></span><br><span class="line">- georadius \<span class="symbol">&lt;key&gt;</span> \&lt; longitude&gt; \<span class="symbol">&lt;latitude&gt;</span> radius <span class="keyword">m</span>|km|ft|mi  以给定的经纬度为中心，找出某一半径内的元素</span><br><span class="line"></span><br><span class="line">  key 经度 纬度 半径 单位</span><br><span class="line"></span><br><span class="line">  georadius chin<span class="variable">a:city</span> <span class="number">110</span> <span class="number">30</span> <span class="number">100</span> km</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## <span class="number">5</span>.Redis-Jedis</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line"><span class="symbol">&lt;dependency&gt;</span></span><br><span class="line">    <span class="symbol">&lt;groupId&gt;</span>redis.clients&lt;/groupId&gt;</span><br><span class="line">    <span class="symbol">&lt;artifactId&gt;</span>jedis&lt;/artifactId&gt;</span><br><span class="line">    <span class="symbol">&lt;version&gt;</span><span class="number">3.2</span>.<span class="number">0</span>&lt;/<span class="keyword">version</span>&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p><strong>前置要求</strong></p><blockquote><p>关掉Linux防火墙或打开redis的端口</p><p>防火墙关闭</p><p>systemctl disable firewalld.service</p><p>配置redis.conf</p><p>将 bind 127.0.0.1注释</p><p>protected-mode yes改为no</p></blockquote><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.yvenxx.test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">redis1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.1.6&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        String ping = jedis.ping();</span><br><span class="line">        System.out.println(ping);</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试kv键值对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.1.6&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    jedis.set(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;v1&quot;</span>);</span><br><span class="line">    String k1 = jedis.get(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">    System.out.println(k1);</span><br><span class="line"></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他功能查api</p><h2 id="6-Springboot整合Redis"><a href="#6-Springboot整合Redis" class="headerlink" title="6.Springboot整合Redis"></a>6.Springboot整合Redis</h2><h2 id="7-Redis事务-锁机制"><a href="#7-Redis事务-锁机制" class="headerlink" title="7.Redis事务_锁机制"></a>7.Redis事务_锁机制</h2><h3 id="7-1-事务定义"><a href="#7-1-事务定义" class="headerlink" title="7.1 事务定义"></a>7.1 事务定义</h3><p>​    Redis事务是一个单独的隔离操作，事务中的所有命令都会被序列化，按顺序执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>​    Redis事务的主要作用是<strong>串联多个命令</strong>防止别的命令插队。</p><h3 id="7-2-Multi，Exec，Discard"><a href="#7-2-Multi，Exec，Discard" class="headerlink" title="7.2 Multi，Exec，Discard"></a>7.2 Multi，Exec，Discard</h3><p>Multi开启事务，输入的命令依次进入命令队列中，不会执行，输入Exec之后，对前面的命令依次执行。</p><p>discard放弃组队。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210616143544007.png" alt="image-20210628100626307"></p><h3 id="7-3-事务冲突"><a href="#7-3-事务冲突" class="headerlink" title="7.3 事务冲突"></a>7.3 事务冲突</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210628103538726.png" alt="image-20210628103538726"></p><h3 id="7-4-悲观锁"><a href="#7-4-悲观锁" class="headerlink" title="7.4 悲观锁"></a>7.4 悲观锁</h3><p>每次拿数据都认为别人会修改数据。所以每次都上锁。别人要拿到数据，除非他释放。传统数据库中很多这类锁机制。行锁，表锁，读锁，写锁。</p><h3 id="7-5-乐观锁"><a href="#7-5-乐观锁" class="headerlink" title="7.5 乐观锁"></a>7.5 乐观锁</h3><p>每次拿数据都认为别人不会修改，所以不会上锁。但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。利用版本号等机制。乐观锁适用于多读的应用类型，可以提高吞吐量。<strong>Redis就是利用这种check-and-set机制实现事务的。</strong></p><h3 id="7-6-WATCH-key-key-…"><a href="#7-6-WATCH-key-key-…" class="headerlink" title="7.6 WATCH key [key ….]"></a>7.6 WATCH key [key ….]</h3><p>执行multi之前，先执行 watch key1 [key2] 可以监视一个或多个key，<strong>如果在事务执行之前这些key被其他命令改动，那么事务将打断。</strong></p><p><strong>unwatch</strong>取消对key的监视。如果先执行了exec或discard命令。也不需要执行unwatch</p><h3 id="8-Redis事务三特性"><a href="#8-Redis事务三特性" class="headerlink" title="8 Redis事务三特性"></a>8 Redis事务三特性</h3><ol><li><p>单独的隔离操作</p><p>事务中的所有命令都会被序列化，按顺序执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</p></li><li><p>没有隔离级别的概念</p><p>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</p></li><li><p>不保证原子性</p><p>事务中如果有一条命令执行失败，其后的命令任然会被执行，没有回滚</p></li></ol><h2 id="8-Redis持久化"><a href="#8-Redis持久化" class="headerlink" title="8 Redis持久化"></a>8 Redis持久化</h2><ul><li><p>RDB（Redis DataBase)</p></li><li><p>AOF （Append Of File)</p></li></ul><h3 id="1-RDB（Redis-DataBase）"><a href="#1-RDB（Redis-DataBase）" class="headerlink" title="1.RDB（Redis DataBase）"></a>1.RDB（Redis DataBase）</h3><p>在指定的<strong>时间间隔</strong>内将内存中的数据集<strong>快照</strong>写入磁盘，也就是Snapshot快照，他恢复时是将快照文件直接读进内存里</p><p><strong>备份执行</strong></p><p>Redis会单独创建（<strong>fork</strong>）一个子进程来进行持久化，<strong>会先将数据写入到一个临时文件。</strong>等持久化结束了，再用这个<strong>临时文件替换上次持久化好的文件。</strong></p><p>整个过程中，主进程不进行任何IO操作，确保了极高的性能，如果需要进行大规模数据的回复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB缺点是最后一次进行持久化的数据可能丢失。</strong></p><h4 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h4><ul><li>Fork的作用是复制一个与当前进程<strong>一样的进程</strong>。新进程的所有数据（变量，环境变量，程序计数器等）数值都和原进程一致，但是 是一个全新的进程，并<strong>作为原进程的子进程</strong></li><li>在Linux中，fork（）会产生一个和父进程完全相同的进程，但子进程在此后，多会用exec调用，出于效率，Linux引入了<strong>“写时复制技术”</strong></li><li><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li></ul><h4 id="RDB持久化流程"><a href="#RDB持久化流程" class="headerlink" title="RDB持久化流程"></a>RDB持久化流程</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210628121128446.png" alt="image-20210628121128446"></p><h4 id="持久化配置文件"><a href="#持久化配置文件" class="headerlink" title="持久化配置文件"></a>持久化配置文件</h4><p>redis.conf中配置文件名称，默认为dump.rdb</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dbfilename dump.dbp</span><br><span class="line"></span><br><span class="line"><span class="comment">#rdb 文件的保存位置</span></span><br><span class="line"><span class="keyword">dir </span><span class="string">&quot;/xxx/xx&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>配置文件中默认的快照配置</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210628121425305.png" alt="image-20210628121425305"></p><p><strong>save / bgsave：</strong>save是同步进行操作，bgsave是异步进行保存操作</p><p>save [时间] [次数]   默认一分钟内改一万次，五分钟改了10次，或15分钟改了一次</p><p>stop-writes-on-bgsave-error  当redis无法写入磁盘时，直接关掉redis的写操作。推荐yes</p><p>rdbchecksum 检查完整性</p><p>在存储快照后，可以让redisCRC64算法来进行数据校验，推荐yes</p><h4 id="rdb的备份"><a href="#rdb的备份" class="headerlink" title="rdb的备份"></a>rdb的备份</h4><ol><li>通过 config get dir 查询rdb文件的位置</li><li>将 *.rdb的文件拷贝到别的地方</li><li>关闭redis-》把备份的文件拷贝到工作目录下</li><li>启动redis，备份的数据会自动加载</li></ol><p><strong>优势</strong></p><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高更适合使用</li><li><strong>节省磁盘空间</strong></li><li><strong>恢复速度快</strong></li></ul><p><strong>劣势</strong></p><ul><li>Fork的时候，内存中的数据被克隆了一份，需要考虑2倍的膨胀性</li><li>虽然在fork时使用了 写拷贝技术，但是数据庞大消耗性能</li><li>redis意外宕机，会丢失最后一次快照的所有修改</li></ul><p><strong>停止RDB</strong></p><p>redis-cli config set save “”</p><p>表示禁用保存策略</p><h3 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2.AOF"></a>2.AOF</h3><p>以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来。只许追加文件但不可以改写文件，redis启动之处会读取该文件重新构建数据。换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次完成数据的恢复工作。</p><h4 id="AOF持久化流程"><a href="#AOF持久化流程" class="headerlink" title="AOF持久化流程"></a>AOF持久化流程</h4><ol><li>客户端的请求写命令会被append追加到AOF缓冲区内</li><li>AOF缓冲区根据AOF持久化策略 [always , everysec, no] 将操作sync同步到磁盘的AOF文件中</li><li>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量</li><li>Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的</li></ol><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210628165839312.png" alt="image-20210628165839312"></p><blockquote><p>AOF默认不开启</p><p>且AOF和RDB同时开启，系统默认读取AOF的数据，不会存在数据丢失</p></blockquote><h4 id="AOF-启动-修复-恢复"><a href="#AOF-启动-修复-恢复" class="headerlink" title="AOF 启动/修复/恢复"></a>AOF 启动/修复/恢复</h4><p>AOF备份和恢复操作与RDB一样，拷贝备份文件，需要恢复时拷贝到Redis工作目录下</p><ul><li><p>正常恢复</p><p>修改默认的 appendonly no改为yes</p><p>将有数据的aof文件复制到对应目录</p><p>重启redis</p></li><li><p>异常恢复</p><p>修改默认的 appendonly no 改为yes</p><p>遇到aof文件损坏，使用redis-check-aof –fix appendonly.aof进行恢复</p><p>备份被写坏的AOF文件</p><p>重启redis</p></li></ul><h4 id="AOF同步频率"><a href="#AOF同步频率" class="headerlink" title="AOF同步频率"></a>AOF同步频率</h4><p>appendonly [xxxx]</p><ul><li>always 始终同步，每次操作都会写入redis，性能差但数据完整性好</li><li>everysec 每秒同步，每秒记入日志一次，若宕机，本秒的数据可能丢失</li><li>no  不主动进行同步，把同步时机交给操作系统</li></ul><h4 id="Rewrite压缩"><a href="#Rewrite压缩" class="headerlink" title="Rewrite压缩"></a>Rewrite压缩</h4><p>AOF采用文件追加方式，文件会越来越大，为避免此情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof</p><p>重写原理</p><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写（先写临时文件，最后rename）**redis4.0版本后的重写，是指吧rdb的快照以二进制的形式附加在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作</p><p>no-appendfsync-on-rewrite= yes/no</p><ul><li>yes时，不写入aof文件，只写入缓存，用户请求不会阻塞，但是在这段时间宕机会丢失这段时间的缓存数据（降低安全，提高性能）</li><li>no时，把数据写入磁盘里，但是遇到重写操作，可能会发生堵塞（数据安全，性能降低）</li></ul><p>重写时机</p><p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍，且文件大于64MB时触发</p><p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定负担的，因此设定Redis要满足一定条件才会重写</p><p>auto-aof-rewrite-percentage: 设置重写的基准值，文件达到100%时开始重写（文件是原来                                                        重写后文件的两倍）</p><p>auto-aof-rewrite-min-size: 设置重写的基准值，最小64MB，达到这个值开始重写</p><p>重写流程</p><ol><li>bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</li><li>主进程fork出子进程执行重写操作，保证主进程不会阻塞</li><li>子进程遍历redis内存中数据，写到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf 重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失</li><li>子进程写完新的 aof文件。向主进程发信号，父进程更新统计信息。主进程吧aof_rewrite_buf中的数据写入到新的AOF文件</li><li>使用新的AOF文件覆盖旧的AOF文件，完成AOF重写</li></ol><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210628185832538.png" alt="image-20210628173928884"></p><p><strong>优势</strong></p><ul><li><p>备份机制更稳健，丢失数据概率更低</p></li><li><p>可读的日志文件，通过日志处理误操作</p></li></ul><p><strong>劣势</strong></p><ul><li><p>比起RDB占用更多的磁盘空间</p></li><li><p>恢复备份速度要慢</p></li><li><p>每次读写都同步的话，有一定的性能压力</p></li><li><p>存在个别bug。</p></li></ul><h2 id="9-Redis-主从复制"><a href="#9-Redis-主从复制" class="headerlink" title="9 Redis 主从复制"></a>9 Redis 主从复制</h2><p>主机数据更新后根据配置和策略，自动同步到备机的master/slave机制，Master写为主，slave读为主</p><ul><li>读写分离，性能扩展</li><li>容灾快速恢复</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>拷贝多个redis.conf文件 include（写绝对路径）</p><p>开启 daemonize yes </p><p>pid文件名字 pidfile</p><p>指定端口 port</p><p>Log 文件名字</p><p>dump.rdb名字 dbfilename</p><p>appendonly 关掉或者换名字</p><p>slave-priority 10 优先级，值越小，优先级越高，用于选举主机时使用，默认100</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="regexp">/myredis/</span>redis.conf</span><br><span class="line">pidfile <span class="regexp">/var/</span>run/redis_6379.pid</span><br><span class="line">port <span class="number">6379</span></span><br><span class="line">dbfilename dump6379.rdb</span><br></pre></td></tr></table></figure><p><strong>多台就配置多个文件</strong></p><ol><li>启动几台机子</li><li>slaveof [ip] [port]   成为某个实例的从服务器</li><li>info replication 查看主从复制的相关信息</li></ol><blockquote><p>主机挂掉，重启就行</p><p>从机挂掉，重启，并重新运行  slaveof 命令才是从机。否则是单主机</p></blockquote><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>后台监控主机是否故障，如果故障了根据投票自动将从库转换为主库</p><p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p><ul><li><strong>监控（Monitoring</strong>）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li><strong>提醒（Notification）</strong>： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li><strong>自动故障迁移（Automatic failover）</strong>： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li></ul><p>两种方式使用 sentinel</p><ol><li><p>对于 redis-sentinel 程序， 你可以用以下命令来启动 Sentinel 系统：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel <span class="regexp">/path/</span>to/sentinel.conf</span><br></pre></td></tr></table></figure></li><li><p>对于 redis-server 程序， 你可以用以下命令来启动一个运行在 Sentinel 模式下的 Redis 服务器：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-<span class="keyword">server</span> /<span class="type">path</span>/<span class="keyword">to</span>/sentinel.conf <span class="comment">--sentinel</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="sentinel配置文件"><a href="#sentinel配置文件" class="headerlink" title="sentinel配置文件"></a>sentinel配置文件</h4><p>运行一个 Sentinel 所需的最少配置如下所示：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sentinel<span class="built_in"> monitor </span>mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line">sentinel<span class="built_in"> monitor </span>resque 192.168.1.3 6380 4</span><br><span class="line">sentinel down-after-milliseconds resque 10000</span><br><span class="line">sentinel failover-timeout resque 180000</span><br><span class="line">sentinel parallel-syncs resque 5</span><br></pre></td></tr></table></figure><p>第一行配置，sentinel去监视 mymaster的主服务器。最后那个2，是如果要将这个服务器判断为失效至少需要2个Sentinel同意（只要同意sentinel的数量不达标，自动故障迁移就不会执行）</p><p>不过要注意， 无论你设置要多少个 Sentinel 同意才能判断一个服务器失效， 一个 Sentinel 都需要获得系统中多数（majority） Sentinel 的支持， 才能发起一次自动故障迁移， 并预留一个给定的配置纪元 （configuration Epoch ，一个配置纪元就是一个新主服务器配置的版本号）。</p><p>换句话说， 在只有少数（minority） Sentinel 进程正常运作的情况下， Sentinel 是不能执行自动故障迁移的。</p><p>其他选项的基本格式如下：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel <span class="attribute">&lt;选项的名字&gt;</span> <span class="attribute">&lt;主服务器的名字&gt;</span> <span class="attribute">&lt;选项的值&gt;</span></span><br></pre></td></tr></table></figure><p>具体意思查 api</p><h4 id="故障恢复原则"><a href="#故障恢复原则" class="headerlink" title="故障恢复原则"></a>故障恢复原则</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210628173928884.png" alt="image-20210628185832538"></p><p><strong>Java主从复制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisSentinelPool jedisSentinelPool=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedisFromSentinel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(jedisSentinelPool==<span class="keyword">null</span>)&#123;</span><br><span class="line">        Set&lt;String&gt; sentinelSet=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        sentinelSet.add(<span class="string">&quot;192.168.11.103:26379&quot;</span>);</span><br><span class="line"></span><br><span class="line">        JedisPoolConfig jedisPoolConfig =<span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">10</span>); <span class="comment">//最大可用连接数</span></span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">5</span>); <span class="comment">//最大闲置连接数</span></span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">5</span>); <span class="comment">//最小闲置连接数</span></span><br><span class="line">        jedisPoolConfig.setBlockWhenExhausted(<span class="keyword">true</span>); <span class="comment">//连接耗尽是否等待</span></span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(<span class="number">2000</span>); <span class="comment">//等待时间</span></span><br><span class="line">        jedisPoolConfig.setTestOnBorrow(<span class="keyword">true</span>); <span class="comment">//取连接的时候进行一下测试 ping pong</span></span><br><span class="line"></span><br><span class="line">        jedisSentinelPool=<span class="keyword">new</span> JedisSentinelPool(<span class="string">&quot;mymaster&quot;</span>,sentinelSet,jedisPoolConfig);</span><br><span class="line">        <span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-Redis集群"><a href="#10-Redis集群" class="headerlink" title="10 Redis集群"></a>10 Redis集群</h2><p>集群实现了对Redis的水平扩容，启动N个借点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的 1/N</p><p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><h3 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h3><ol><li><p>将rdb aof文件都删除</p></li><li><p>制作六个实例，6379 - 6381   6389-6391</p></li><li><p>配置基本信息</p><p>daemonize yes</p><p>pid 文件名</p><p>端口</p><p>Log文件名</p><p>dump.rdb名</p><p>appendonly 关掉或换名字</p></li><li><p>redis cluster配置修改</p><p>cluster-enable yes   打开集群模式</p><p>cluster-config-file nodes-6379.conf    设定节点配置文件名</p><p>cluster-node-timeout 15000   设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</p></li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> /home/bigdata/redis.<span class="keyword">conf</span></span><br><span class="line">port 6379</span><br><span class="line">pidfile <span class="string">&quot;/var/run/redis_6379.pid&quot;</span></span><br><span class="line">dbfilename <span class="string">&quot;dump6379.rdb&quot;</span></span><br><span class="line"><span class="keyword">dir</span> <span class="string">&quot;/home/bigdata/redis_cluster&quot;</span></span><br><span class="line">logfile <span class="string">&quot;/home/bigdata/redis_cluster/redis_err_6379.log&quot;</span></span><br><span class="line"><span class="keyword">cluster</span>-enabled yes</span><br><span class="line"><span class="keyword">cluster</span>-config-<span class="keyword">file</span> nodes-6379.<span class="keyword">conf</span></span><br><span class="line"><span class="keyword">cluster</span>-node-timeout 15000</span><br></pre></td></tr></table></figure><p>配置六个这个文件   不同端口文件名记得修改</p><p><strong>启动六个redis服务，将六个节点合成一个集群</strong></p><p>组合之前确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210629102146527.png" alt="image-20210628192753659"></p><p>组成集群</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在redis bin目录下</span><br><span class="line">redis-cli --cluster create --cluster-replicas <span class="number">1 192.168.1</span>.<span class="number">1:6379 192</span>.<span class="number">168.1.1</span>:<span class="number">6380 192.168</span>.<span class="number">1.1:6381</span> <span class="number">192.168.1.1</span>:<span class="number">6389 192.168</span>.<span class="number">1.1:6390</span> <span class="number">192.168.1.1</span>:<span class="number">6391</span> </span><br></pre></td></tr></table></figure><p>replicas 1   采用最简单的方式配置集群，一台主机，一台从机。组成三组</p><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p>普通方式登陆，可能直接进入读主机，会出现MOVED重定向操作。所以，应该以集群方式登陆。</p><p>集群方式登陆，加 -c，在设置数据时，会自动切换到相应的写主机。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">redis</span>-cli -c -p <span class="number">6379</span></span><br></pre></td></tr></table></figure><p><strong>通过cluster nodes 命令，查看集群信息</strong></p><h3 id="分配节点"><a href="#分配节点" class="headerlink" title="分配节点"></a><strong>分配节点</strong></h3><p>一个集群至少要<strong>三个主节点</strong>， –cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</p><p>分配原则：尽量保证每个主数据库运行在不同的 ip 地址，每个从库和主库不在一个 ip 地址上。</p><h3 id="slots"><a href="#slots" class="headerlink" title="slots"></a>slots</h3><p>一个Redis集群包含16384个插槽（hash slot），数据库的每个键都属于这16384个插槽的其中一个。</p><p>集群使用公式**CRC16(key) % 16384 来计算 key 属于哪个插槽，其中CRC16 语句用于计算key的CRC16校验和集群中的每个节点负责处理一部分插槽。</p><p>如</p><p>节点 A 负责处理 0 号至 5460 号插槽。</p><p>节点 B 负责处理 5461 号至 10922 号插槽。</p><p>节点 C 负责处理 10923 号至 16383 号插槽。</p><h3 id="集群录入值"><a href="#集群录入值" class="headerlink" title="集群录入值"></a>集群录入值</h3><p>redis-cli每次录入，查询键值，redis都会计算出该key应该送往的插槽，如果不是该服务器的插槽，redis会报错，并告知应当前往的redis实例地址和端口。</p><p>redis-cli客户端提供了 <strong>-c 参数实现自动重定向</strong>，<strong>不在一个slot下的键值，不能使用mset，mget等多键操作</strong>。但可以使用  {}，来定义组的概念，从而使key中 {} 内相同内容的键值对放到一个slot中去。</p><p><strong>查询集群中的值</strong></p><p>CLUSTER GETKEYSINSLOT [slot] [count]     返回count个slot槽中的键</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210629094110735.png" alt="image-20210629094110735"></p><h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><ol><li>主从都挂掉，如果配置了 cluster-require-full-coverage为yes，那么整个集群挂掉</li><li>主从都挂掉，如果配置了，cluster-require-full-coverage为no，那么，该插槽数据全部不能使用，也无法存储。</li></ol><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>即使链接的不是主机。也会自动切换到需要的主机和从机</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterTest</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line">     Set&lt;HostAndPort&gt;<span class="built_in">set</span> =<span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">     <span class="built_in">set</span>.add(<span class="keyword">new</span> HostAndPort(<span class="string">&quot;192.168.31.211&quot;</span>,<span class="number">6379</span>));</span><br><span class="line">     JedisCluster jedisCluster=<span class="keyword">new</span> JedisCluster(<span class="built_in">set</span>);</span><br><span class="line">     jedisCluster.<span class="built_in">set</span>(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">     System.out.<span class="built_in">println</span>(jedisCluster.<span class="built_in">get</span>(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优势</strong></p><p>实现扩容，分摊压力，无中心化配置相对简单</p><p><strong>劣势</strong></p><p>多键操作不被支持，lua不被支持。</p><h2 id="Redis-6新功能"><a href="#Redis-6新功能" class="headerlink" title="Redis 6新功能"></a>Redis 6新功能</h2><h3 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h3><p>Redis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。</p><p>在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。</p><p>ACL功能对用户进行更细粒度的权限控制：</p><ol><li>接入权限：用户名和密码</li><li>可以执行的命令</li><li>可以操作的key</li></ol><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ul><li><p>acl list 展现用户权限列表</p></li><li><p>acl cat 【string…..】 查看添加权限指令类别，加string或其他数据结构，可以查看具体的权限。</p></li><li><p>acl whoami 查看当前用户</p></li><li><p>acl setuser 创建和编辑用户。</p><p>acl setuser user1 on &gt;123456 ~a* +get</p><p>user1 密码 123456 可以get所有a开头的key</p></li><li><p>auth user password 切换用户</p></li></ul><h3 id="IO多线程"><a href="#IO多线程" class="headerlink" title="IO多线程"></a>IO多线程</h3><p>IO多线程指<strong>客户端交互部分</strong>的网络IO交互处理模块多线程，而非执行命令多线程。Redis执行线程依然是单线程</p><p>Redis多线程部分只是用来处理网络数据的读写和协议解析，执行命令任然是单线程。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210628192753659.png" alt="image-20210629102146527"></p><p>默认不开启</p><p>配置</p><p>io-threads-do-reads yes</p><p>io-threads 4</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统 第五章</title>
      <link href="2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
      <url>2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h1><h2 id="基本概念和分类"><a href="#基本概念和分类" class="headerlink" title="基本概念和分类"></a>基本概念和分类</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211118205440632.png" alt="image-20211118205440632"></p><h2 id="IO控制器"><a href="#IO控制器" class="headerlink" title="IO控制器"></a>IO控制器</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211118210210053.png" alt="image-20211118210210053"></p><p><strong>机械部件</strong>：主要用来执行具体IO操作</p><p><strong>电子部件：</strong>通常是一块插入主板扩展槽的印刷电路板</p><p><strong>IO控制器（电子部件）</strong></p><p>CPU无法直接控制设备机械部件，需要通过IO控制器（设备控制器）</p><p>功能</p><ul><li>接受和识别CPU发出的命令（控制寄存器）</li><li>向CPU报告设备状态（状态寄存器）</li><li>数据交换（数据寄存器）</li><li>地址识别（类似于内存的地址），为了区分内部各个寄存器，会给他们设置特定地址</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211118205926032.png" alt="image-20211118205926032"></p><blockquote><p>小细节</p><ol><li>一个IO控制器可能会对应多个设备</li><li>数据寄存器，控制寄存器，状态寄存器可能有多个。有的计算机会让这些寄存器占用内存地址的一部分，称为<strong>内存映像IO</strong>；另一些计算机用IO专用地址，<strong>寄存器独立编织</strong></li></ol><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211118210157110.png" alt="image-20211118210157110"></p></blockquote><h2 id="IO控制方式"><a href="#IO控制方式" class="headerlink" title="IO控制方式"></a>IO控制方式</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211118210731830.png" alt="image-20211118210731830"></p><h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211118210437961.png" alt="image-20211118210437961"></p><p><strong>读写操作的流程（轮询）</strong></p><ul><li>优点：实现简单。在读/写指令后，加上实现循环检查的一系列指令即可</li><li><strong>缺点：CPU和IO设备只能串行工作，CPU需要一直轮询检查，长期处于 “忙 等”状态，</strong>CPU利用率低</li><li>数据流向：读( IO –&gt;  CPU—-&gt; 内存)     写（内存—-&gt;CPU—-&gt;IO设备）</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211118210513353.png" alt="image-20211118210513353"></p><h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><p>引入<strong>中断机制</strong>，在CPU发出读写命令后，<strong>将等待IO的进程阻塞</strong>，切换到其他进程执行。当IO完成后，发出中断信号，<strong>CPU检测中断信号</strong>，去执行中断处理程序。CPU从IO控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，<strong>CPU恢复等待IO的进程（或其他进程）的运行环境，继续执行</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211118210937368.png" alt="image-20211118210937368"></p><blockquote><ol><li>CPU会在每个指令周期的末尾检查中断</li><li>中断处理过程中需要保存、恢复进程的运行环境</li></ol></blockquote><ul><li>数据流向：读（IO —&gt; CPU—&gt; 内存） 写（内存—&gt; CPU—&gt;IO设备）</li><li>优点：CPU不需要轮询检查，<strong>可与IO设备并行工作</strong></li><li><strong>缺点：</strong>每个字在IO设备与内存之间的传输，都需要经过CPU。而<strong>频繁的中断处理会消耗较多的CPU时间</strong></li></ul><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><p>与 “中断驱动方式”相比，DMA方式（直接存储器存取）。主要用于块设备的（IO控制）。改进如下</p><ol><li><strong>数据的传送单位是 “块”。</strong></li><li>数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU来进行传输</li><li>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</li></ol><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211118211828323.png" alt="image-20211118211828323"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211118211836585.png" alt="image-20211118211836585"></p><ul><li>数据传送的单位：每次读入一个/多个块（每次读写的只能是连续的块，且这些块读入内存后在内存中也必须是连续的，如果要离散的块，就需要多次读写）</li><li>优点：数据传输以块为单位，CPU介入频率降低。数据传输不需要线经过CPU再进入内存。CPU和IO设备并行性得到提升</li><li><strong>缺点：</strong>CPU发出一条IO指令，只能读写一个或多个连续的数据块。如果读写多个离散存储的数据块，或者将数据写到不同的内存区域时，CPU要分别发出多条指令</li></ul><h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><p><strong>通道：一种硬件</strong>，组原 里面有这个解释。可以理解为小型的CPU，通道可以识别一系列<strong>通道指令</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211118212128149.png" alt="image-20211118212128149"></p><p>数据传送单位：<strong>一组数据块</strong></p><p><strong>优点：CPU，通道，IO设备可以并行工作，资源利用率很高</strong></p><p>缺点：实现复杂，需要专门的通道硬件支持</p><h2 id="IO软件层次结构"><a href="#IO软件层次结构" class="headerlink" title="IO软件层次结构"></a>IO软件层次结构</h2><p>硬件上面，是IO软件的层次。每一层会利用其下层提供的服务，实现某些功能，并屏蔽实现的具体细节，向高层提供服务。</p><p><strong>重要的：设备独立性软件，设备驱动程序，中断处理程序。统称为IO系统 /  IO核心子系统</strong></p><ul><li><p>用户层：<strong>实现了与用户交互的借口</strong>，用户可直接使用该层提供的，与IO操作相关的库函数对设备进行操作（例如printf库函数）</p></li><li><p><strong>设备独立性软件：设备无关性软件</strong>。与设备的硬件特性无关的功能基本在这一层实现</p><ul><li><p>向上层提供统一的调用接口（read/write…..调用）</p></li><li><p>设备的保护</p></li><li><p>差错处理</p></li><li><p>设备的分配与回收</p></li><li><p>数据缓冲区管理</p></li><li><p>建立逻辑设备名到物理设备名的映射关系：根据设备类型选择调用相应的驱动程序</p><ul><li>逻辑设备表LUT（可以整个系统只设置一张LUT）</li><li>也可以为每个用户设置一张LUT</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211118212821828.png" alt="image-20211118212821828"></p></li></ul></li><li><p>设备驱动程序：主要负责对硬件设备的具体控制，将上层发出的一系列指令，转化为特定设备的”执行“ 的一系列操作。包括设置设备寄存器等</p></li><li><p>中断处理程序：当IO任务完成时，io控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序执行。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211118213136380.png" alt="image-20211118213136380"></p></li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211118212430222.png" alt="image-20211118212430222"></p><h2 id="IO核心子系统"><a href="#IO核心子系统" class="headerlink" title="IO核心子系统"></a>IO核心子系统</h2><p>考研中，我们需要重点理解和掌握的功能是：I/O调度、设备保护、假脱机技术（SPOOLing技术）、设备分配与回收、缓冲区管理（即缓冲与高速缓存</p><p><strong>IO调度，设备保护</strong>，设备分配与回收、缓冲区管理。都是在IO核心子系统完成。</p><p>假脱机（SPOOLing技术）：实际是在用户层实现，但是考纲中 归为 IO核心子系统中</p><ul><li>IO调度：用某种算法确定一个顺序来处理IO请求，如前面磁盘调度的算法</li><li>设备保护：UNIX系统中，<strong>设备被看作是一种特殊的文件</strong>，每个设备也有对应的FCB。会根据访问权限来实现保护功能</li></ul><h2 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211119091015737.png" alt="image-20211119091015737"></p><p>用软件的方式模拟脱机技术。批处理阶段引入了 <strong>脱机输入/脱机输出</strong>。</p><p>实现SPOOLing技术，<strong>必须要有多道程序技术的支持。</strong>系统会建立 “输入输出进程”</p><ul><li>输出缓冲区：暂存从输入设备输入的数据</li><li>输入缓冲区：暂存从输出井送来的数据</li></ul><blockquote><p>输入缓冲区和输出缓冲区是在内存中的缓冲区</p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211119090250963.png" alt="image-20211119090250963"></p><p>独占式设备：<strong>只允许各个进程串行使用的设备。</strong>一段时间内只能满足一个进程需要</p><p>共享设备：<strong>允许多个进程 “同时” 使用的设备</strong>（微观上可能与CPU一样，交替运行）</p><p>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备。</p><h2 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211119094424849.png" alt="image-20211119094424849"></p><h3 id="考虑的因素"><a href="#考虑的因素" class="headerlink" title="考虑的因素"></a>考虑的因素</h3><ol><li>独占，共享，虚拟设备</li><li>设备分配算法（先来先服务，优先级高者优先……</li><li>设备分配的安全性<ul><li>安全分配方式：为进程分配一个设备后将进程阻塞，本次IO完成后才将进程唤醒</li><li>不安全分配方式：进程发出IO请求后，系统为其分配IO设备，进程可继续执行，还可发出新的IO请求。只有某个IO请求得不到满足时才将进程阻塞。</li></ul></li></ol><h3 id="静态-动态分配"><a href="#静态-动态分配" class="headerlink" title="静态/动态分配"></a>静态/动态分配</h3><p>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源（不会发生死锁）</p><p>动态分配：进程运行过程中动态申请设备资源</p><h3 id="设备分配中的数据结构"><a href="#设备分配中的数据结构" class="headerlink" title="设备分配中的数据结构"></a>设备分配中的数据结构</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211119091810922.png" alt="image-20211119091810922"></p><p><strong>–设备控制表DCT–</strong></p><p>系统为每个设备配置一张DCT，用于记录设备情况</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211119091909278.png" alt="image-20211119091909278"></p><p><strong>–控制器控制表（COCT）–</strong></p><p>每个设备都会对应一张COCT，操作系统根据COCT的信息对控制器进行操作和管理。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211119092146712.png" alt="image-20211119092146712"></p><p><strong>–通道控制表CHCT–</strong></p><p>每个通道对应一张CHCT，操作系统根据CHCT的信息对通道进行管理</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211119092257070.png" alt="image-20211119092257070"></p><p><strong>–系统设备表SDT–</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211119092558200.png" alt="image-20211119092558200"></p><h3 id="设备分配步骤"><a href="#设备分配步骤" class="headerlink" title="设备分配步骤"></a>设备分配步骤</h3><ol><li>根据进程请求的<strong>物理设备名</strong>查找SDT（物理设备名是进程请求分配设备时提供的参数）</li><li>根据SDT找到DCT，若<strong>设备</strong>忙碌则将进程PCB挂到<strong>设备等待队列</strong>中，不忙碌则将<strong>设备</strong>分配给进程</li><li>根据DCT找到COCT，若<strong>控制器</strong>忙碌则将进程PCB挂到<strong>控制器等待队列</strong>，不忙碌则将<strong>控制器</strong>分配给进程</li><li>根据COCT找到CHCT，若<strong>通道</strong>忙碌则将进程PCB挂到<strong>通道等待队列</strong>中，不忙碌则将<strong>通道</strong>分配给进程</li></ol><p>缺点：</p><ul><li>用户编程时必须使用 “物理设备名” ，低层细节对用户不透明，不方便编程</li><li>若换了一个物理设备，程序无法运行</li><li>若进程亲求的物理设备正在忙碌，则即使系统中还有同类型空闲设备，进程也必须阻塞等待</li></ul><p>改进</p><p>上面第一步，改为，根据进程请求的<strong>逻辑设备名</strong>查找SDT（逻辑设备名实际就是设备类型）</p><p><strong>逻辑设备表（LUT）建立了逻辑设备名和物理设备名之间的映射关系。</strong></p><p>某用户进程第一次使用逻辑设备名向系统发请求，查找系统设备表，分配给进程，并在LUT中增加相应表项。</p><p><strong>之后用户进程再次通过相同的逻辑设备名请求使用设备。则操作系统通过LUT表即可知道用户进程实际要使用哪个物理设备，也能知道该设备的驱动程序入口地址。</strong></p><p>整个系统只有一张LUT / 每个用户都有一张LUT。</p><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211119132128642.png" alt="image-20211119132128642"></p><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区</p><p>使用<strong>硬件作为缓冲区</strong>的<strong>成本较高，容量也较小</strong>。一般情况下，更多的是利用<strong>内存作为缓冲区</strong>，”设备独立性软件“ 的缓冲区管理就是要组织管理好这些缓冲区。</p><p>缓冲区的作用</p><ul><li><strong>缓和CPU与IO设备之间速度不匹配的矛盾</strong></li><li><strong>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</strong></li><li><strong>解决数据粒度不匹配的问题</strong></li><li><strong>提高CPU与IO设备之间的并行性</strong></li></ul><p>CPU可以把要输出的数据快速的放入缓冲区，之后就可以做别的事情。</p><h3 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h3><p>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>单缓冲</strong>的策略，操作系统会<strong>在主存中为其分配一个缓冲区</strong>（若题目中没有特别说明，一个缓冲区的大小就是一个块）</p><p><strong>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出</strong>。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211119130759284.png" alt="image-20211119130759284"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211119131006073.png" alt="image-20211119131006073"></p><p><strong>采用单缓冲策略，处理一块数据平均耗时 Max（C,T)+M</strong></p><h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p>若采用<strong>双缓冲</strong>的策略，操作系统会<strong>在主存中为其分配两个缓冲区</strong></p><p>双缓冲题目中，假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空。</p><p><strong>假设 T&gt;C+M</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211119131522261.png" alt="image-20211119131522261"></p><p><strong>假设T&lt;C+M</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211119131545212.png" alt="image-20211119131545212"></p><p><strong>结论：采用双缓冲策略，处理一个数据块的平均耗时为Max（T,C+M）</strong></p><h3 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h3><p>将多个<strong>大小相等</strong>的缓冲区链接称一个<strong>循环队列</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211119131713433.png" alt="image-20211119131713433"></p><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>由系统中共用的缓冲区组成。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211119132047583.png" alt="image-20211119132047583"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统 第四章</title>
      <link href="2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211113105245107.png" alt="image-20211113105245107"></p><p><strong>文件名：</strong>由创建文件的用户决定文件名，主要是为了方便用户找到文件，**同一目录下不允许有重名文件</p><p><strong>标识符：</strong>一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称</p><p>类型：指明文件的类型</p><p><strong>位置</strong>：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，用户不可见）</p><p><strong>大小：</strong>指明文件大小</p><p><strong>创建时间、上次修改时间</strong></p><p><strong>文件所有者信息</strong></p><p><strong>保护信息：</strong>对文件进行保护的访问控制信息</p><p>—<strong>文件内部的数据组织</strong>—</p><ul><li><p>无结构文件，由一系列二进制或字符流组成</p><p>例如 txt 文件</p></li><li><p>有结构文件、多个记录，记录下面有数据项</p><p>例如 Excel 文件，一行是一个记录，一行里面的数据是数据项</p></li></ul><p>—<strong>操作系统向上提供的功能</strong>—</p><ul><li>创建文件（create系统调用）</li><li>删除文件（delete系统调用）</li><li>读文件（read系统调用）</li><li>写文件（write系统调用）</li><li>打开文件（open系统调用）</li><li>关闭文件（close系统调用）</li></ul><p>—<strong>从上往下看、文件应如何存放在外存</strong>—</p><p>操作系统以 “块” 为单位为文件分配存储空间，因此即使一个文件太小只有10B，但它依然需要占用1KB的磁盘块。外存中的数据读入内存时同样以块为单位。外存由一个个存储单元组成，每个对应一个地址</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211113103428653.png" alt="image-20211113103428653"></p><p>—-<strong>从下往上看</strong>—</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211113105159574.png" alt="image-20211113105159574"></p><p>文件共享：使多个用户可以共享使用一个文件</p><p>文件保护：保证不同的用户对文件有不同的权限</p><h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><h3 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h3><p>文件的内部数据就是一系列二进制流或字符流组成。又称 “<strong>流式文件</strong>“。如 txt 文件</p><p>所以无需讨论无结构文件的逻辑问题</p><h3 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211114181527021.png" alt="image-20211114181527021"></p><p>由一组相似的记录组成，又称 ”<strong>记录式文件</strong>“。每条记录由若干条数据项组成，每条记录有一个数据项可作为<strong>关键字</strong>（作为识别不同记录的ID，类似sql的主键）。</p><p>根据各条记录的长度是否相等，可分为<strong>定长记录</strong>和<strong>可变长记录</strong>两种</p><blockquote><p>例如，学生表固定长度</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211113105949645.png" alt="image-20211113105949645"></p><p>不固定长度</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211113110007852.png" alt="image-20211113110007852"></p></blockquote><h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211113110514694.png" alt="image-20211113110514694"></p><p>文件中的记录一个接着一个的顺序排列（逻辑上），记录上可以是<strong>定长</strong>的或<strong>可变长</strong>的。各个记录在物理上可以<strong>顺序存储</strong>或<strong>链式存储</strong></p><ul><li><strong>顺序存储</strong>：逻辑上相邻的记录，物理上也相邻（类似顺序表）</li><li><strong>链式存储：</strong>逻辑上相邻的记录，物理上不一定相邻（链表）</li></ul><ul><li><strong>串结构：记录直接的顺序与关键字无关</strong></li><li><strong>顺序结构：记录直接的顺序按关键字顺序排列</strong></li></ul><h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><p><strong>索引表</strong>本身是<strong>定长记录的顺序文件</strong>。因此可以快速找到第i个记录对应的索引项。</p><p>可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此<strong>主要用于对信息处理的及时性要求比较高的场合</strong></p><p><strong>可以用不同的数据项建立多个索引表</strong>。如 可以用学号建立一张，姓名也可以建立一张。实现可以用学号或姓名检索</p><h5 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h5><p><strong>一组记录对应一个索引表项</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211114181147558.png" alt="image-20211114181147558"></p><p>文件检索快：</p><p>如果是<strong>顺序文件</strong>有10000个记录。只能从头开始顺序查找。平均须查找5000个记录</p><p>而<strong>索引顺序文件</strong>，可分为100组，每组100个记录，则<strong>平均查找只要50+50=100次</strong></p><p><strong>还可建立多级索引表</strong>，套娃</p><h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><p><strong>磁盘块大小与内存块、页面的大小相同</strong>，读取文件块（磁盘块）时，每次读入或写出 一块。</p><p><strong>文件的逻辑结构空间也被分为了一个一个的文件“块”</strong>，因此逻辑地址也可以表示为<strong>（逻辑块号，块内地址）</strong>的形式</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211114195901602.png" alt="image-20211114195901602"></p><h3 id="文件的分配方式"><a href="#文件的分配方式" class="headerlink" title="文件的分配方式"></a>文件的分配方式</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211114211428050.png" alt="image-20211114211428050"></p><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p><strong>每个文件在磁盘上占有一组  连续  的块</strong>。文件目录中记录存放 起始块号和长度。</p><p><strong>物理块号 = 起始块号 + 逻辑块号</strong>，因此<strong>连续分配支持顺序访问和直接访问</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211114200242748.png" alt="image-20211114200242748"></p><p><strong>连续分配的文件在顺序 读/写 时速度最快</strong>，但因为是必须连续的状态，<strong>不容易扩展</strong>。假如目前拥有3个块，但是后面的块被人用了，则需要找其他连续的空闲块。且<strong>连续分配存储空间利用率低，会产生难以利用的磁盘碎片</strong>。虽然可以用<strong>紧凑</strong>来处理碎片，代价大。</p><p>简单来说</p><p><strong>优点：支持顺序访问和直接访问，顺序读写速度快</strong></p><p><strong>缺点：不方便文件扩展，存储空间利用率低，会产生磁盘碎片</strong></p><h4 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h4><p>采用离散分配的方式，为文件分配离散的磁盘块，分为 <strong>隐式链接</strong>和<strong>显式链接</strong></p><p><strong>—-隐式链接—-</strong></p><p>类似于链表的方式，但是每次只能顺序访问，不能随机访问。除文件的最后一个盘块之外，每个盘块都存有一个指向下一节点的指针。文件目录包括文件第一块的指针和最后一块的指针。</p><p><strong>优点：</strong>方便文件扩展，不会有碎片问题，外存利用率高</p><p><strong>缺点：</strong>只支持顺序访问，不支持随机访问，查找效率低，指向下一盘块的指针也需要h耗费少量的存储空间</p><p>—-<strong>显式链接</strong>—-</p><p>把用于链接各文件物理块的指针显示的存放在一张表中。文件分配表（FAT，File Allocation Table）</p><p><strong>一个磁盘仅设置一张 FAT。开机时，将FAT读入内存，并常驻内存</strong>。因为是常驻内存，<strong>逻辑块号转换成物理块号的过程不需要读磁盘操作</strong>。</p><p>则采用<strong>显式链接</strong>方式的文件，支持顺序访问，也<strong>支持随机访问（想访问i号逻辑块时，不需要依次访问之前的部分，直接访问i）</strong>。<strong>不会产生碎片</strong></p><p><strong>优点：</strong>方便文件拓展，不会有碎片问题，外存利用率高，并且<strong>支持随机访问</strong>，相比于隐式链接，<strong>地址转换时不需要访问磁盘，文件的访问效率更高</strong></p><p><strong>缺点：</strong>文件分配表需要占用一定的存储空间</p><p>例如 a文件依次存放2-&gt;5-&gt;0&gt;1 最后一个指针为-1，特殊值</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211114201508327.png" alt="image-20211114201508327"></p><h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><p>允许文件离散的分配在各个磁盘块中，系统会<strong>给每个文件建立一张索引表</strong>，索引表中<strong>记录文件的各个逻辑块对应的物理块</strong>。索引块一样存储在磁盘块中，称为索引块，其余称为数据块。</p><p><strong>索引分配可支持随机访问，文件拓展可很容易实现，但索引表需要占用一定的存储空间</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211114205529006.png" alt="image-20211114205529006"></p><p>注意一个问题，每个磁盘块是固定大小的。如果索引块需要存储的索引数据比块大。就没法存储</p><p>——解决方案如下——</p><h5 id="链接方案"><a href="#链接方案" class="headerlink" title="链接方案"></a>链接方案</h5><p>如果索引表太大，一个索引块放不下，可以将多个索引块链接起来存放。</p><p>但是有个问题是，如果有几百个索引块，我们要最后一个索引块，就需要一直顺序查到最后一个。效率低下</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211114205947135.png" alt="image-20211114205947135"></p><h5 id="多层索引"><a href="#多层索引" class="headerlink" title="多层索引"></a>多层索引</h5><p><strong>原理类似多级页表</strong>，第一层索引块指向第二层索引块…….</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211114210716940.png" alt="image-20211114210716940"></p><p>K+1次是读磁盘操作</p><h5 id="混合索引"><a href="#混合索引" class="headerlink" title="混合索引"></a>混合索引</h5><p>多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含<strong>直接地址索引（直接指向数据项）</strong>，又包含一级<strong>间接索引</strong>，还包含<strong>二级间接索引</strong>………..</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211114210958185.png" alt="image-20211114210958185"></p><p><strong>重点重点重点重点重点重点重点</strong></p><ol><li>要会根据多层索引，或者索引的结构计算出文件的最大长度（关键：各级索引表最大不能超过一个块（磁盘块））</li><li>要能自己分析访问某个数据块所需要的读磁盘次数（关键：FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外要<strong>注意题目条件–顶级索引块是否已调入内存</strong>）</li></ol><h2 id="物理结构vs逻辑结构"><a href="#物理结构vs逻辑结构" class="headerlink" title="物理结构vs逻辑结构"></a>物理结构vs逻辑结构</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115131608349.png" alt="image-20211115131608349"></p><p>逻辑结构是用户看到的样子，而物理结构是操作系统进行决定的。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115131726077.png" alt="image-20211115131726077"></p><p>关于索引文件，链式存储，链接分配，索引分配的区别</p><p><strong>—- 顺序文件 采用 顺序存储/链式存储 —-</strong></p><p>顺序存储，各条记录相邻的存放。链式存储，用指针进行相连，实际也是顺序存储。</p><p><strong>—-链式存储 的 顺序文件 采用连续分配（物理结构）—-</strong></p><p>在连续的空间上，进行链式存储 存为连续分配 顺序文件的形式</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115132327188.png" alt="image-20211115132327188"></p><p><strong>—-链式存储 的 顺序文件 采用 链接分配（物理结构）—-</strong></p><p>采用链式存储 实现 链接分配的顺序文件。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115132517860.png" alt="image-20211115132517860"></p><p><strong>—-索引文件（物理）采用索引分配（逻辑）—-</strong></p><p>简单的说就是，采用索引文件的方式存储数据（用户决定），操作系统用索引分配方式存储。</p><p><strong>物理上</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115134038539.png" alt="image-20211115134038539"></p><p><strong>逻辑上</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115134101788.png" alt="image-20211115134101788"></p><h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115155034068.png" alt="image-20211115155034068"></p><h3 id="对非空闲磁盘块的管理"><a href="#对非空闲磁盘块的管理" class="headerlink" title="对非空闲磁盘块的管理"></a>对非空闲磁盘块的管理</h3><p>存放了文件数据的磁盘块。链接分配，连续分配，索引分配</p><h3 id="存储空间的划分与初始化"><a href="#存储空间的划分与初始化" class="headerlink" title="存储空间的划分与初始化"></a>存储空间的划分与初始化</h3><p>文件卷，C盘，D盘这样的。初始化就是将文件卷，分为文件区和目录区。</p><p>其中一个物理磁盘可以划分为多个文件卷，也可以多个物理磁盘分为一个文件卷</p><h3 id="对空闲磁盘块的管理"><a href="#对空闲磁盘块的管理" class="headerlink" title="对空闲磁盘块的管理"></a>对空闲磁盘块的管理</h3><h4 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h4><p>适用于 “连续分配方式”</p><p>分配磁盘块与内存管理中的动态分区分配类似，为一个文件 <strong>分配连续的存储空间</strong>。同样<strong>可采用首次适应，最佳适应，最坏适应等算法</strong>来决定为文件分配哪个区间。</p><p>回收磁盘块也与内存类似。</p><ol><li>回收区的前后都没有相邻空闲区。自己为一个空闲区</li><li>回收区前后都是空闲区，将前后和回收的组合成一个。</li><li>回收区前面是空闲区，合并到前面</li><li>回收区后面是空闲区，合并到后面的空闲区</li></ol><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115150948560.png" alt="image-20211115150948560"></p><h4 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h4><ul><li><p>空闲盘块链：以盘块为单位组成一条空闲链</p><p>操作系统保存着 <strong>链头，链尾指针</strong>。</p><p>分配：若申请k个盘块，则从链头开始拿k个盘块分配，并修改链头指针</p><p>回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针</p></li><li><p>空闲盘区链：以盘区为单位组成一条空闲链，在一起的盘块组成盘区，一个个盘区指针链接</p><p>操作系统保存着 <strong>链头，链尾指针</strong>。</p><p>分配：申请k个盘块，可以通过 最佳适应，首次适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的分配给文件。</p><p>如果没有盘块满足需求，可以将不同盘区的盘块同时分配给一个文件（分配后需要修改相应的链指针等数据）</p><p>回收：盘区相邻，则将回收区合并到盘区，不相邻就自己为一个盘区</p></li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115151507824.png" alt="image-20211115151507824"></p><h4 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h4><p>分配：若文件需要k个块</p><ol><li>顺序扫描位示图，找到k个相邻或不相邻的 “0” （若0代表未分配）</li><li>根据字号，位号算出对应的盘块号，将相应盘块分配给文件；</li><li>将相应位设置为1</li></ol><p>回收：</p><ol><li>根据回收的盘块号计算出对应的字号、位号</li><li>将相应的二进制位设为 “0”</li></ol><p>这里n为字长 i j 图中有说明</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115152626097.png" alt="image-20211115152626097"></p><h4 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h4><p>空闲表法，空闲链表法不适用于大型文件系统，可能使他们过大。UNIX采用成组链接法对磁盘进行管理</p><p><strong>文件卷的目录区中</strong>专门用一个磁盘块作为 “<strong>超级块</strong>”，当系统启动时需要将<strong>超级块读入内存</strong>。并且要保证内存外存中“<strong>超级块</strong>”数据一致</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115153535549.png"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115153638616.png" alt="image-20211115153638616"></p><p>—-分配—-</p><p>1.假设分配1个块，将超级块的100变为99，然后将头部201分配出去。表中201那一项去掉</p><p>2.假设分配100个块，<strong>因为是这里是以100块为一组，而我们头部300的位置，存了下一个组的链接。所以我们需要将300中的内容复制到 超级块中。这样保证不断组</strong>。</p><p>—-回收—-</p><p>1.假设超级块100个容量，有99个空闲块，现在需要回收一个块，则将其回收到超级块，并将99+1。</p><p>2.假设超级块100容量，100个空闲块都在。需要回收一个块，因为已经满了，所以可以将这个块变为超级块，指向原超级块的内容。因为只有一个分组所以超级快 第一个置为1。如下图，红色框起来的是原超级块的内容。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115154910684.png" alt="image-20211115154910684"></p><h2 id="操作系统向上提供的基本功能"><a href="#操作系统向上提供的基本功能" class="headerlink" title="操作系统向上提供的基本功能"></a>操作系统向上提供的基本功能</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115162610424.png" alt="image-20211115162610424"></p><p><strong>—-创建文件（create系统调用）—-</strong></p><p>需要提供的主要参数</p><ol><li>所需的外存空间大小（如：一个盘块（1KB））</li><li>文件存放路径</li><li>文件名</li></ol><p>操作系统处理Create系统调用，主要步骤</p><ol><li><strong>在外存中找到文件所需的空间</strong>（用上面学的空闲链表法等）</li><li>根据文件存放路径的信息找到该目录对应的目录文件，在目录中<strong>创建该文件对应的目录项</strong>。目录项中包含了文件名，文件在外存中的存放位置等信息。</li></ol><p><strong>—-删除文件（delete）—-</strong></p><p>主要参数</p><ol><li>文件存放路径</li><li>文件名</li></ol><p>主要步骤</p><ol><li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的目录项</strong></li><li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，<strong>回收文件占用的磁盘块</strong>（根据空闲表法，空闲链表法等，管理策略的不同，需要做不同的处理）</li><li>从目录表中<strong>删除文件对应的目录项</strong></li></ol><p><strong>—-打开文件—-</strong></p><p>主要参数</p><ol><li>文件存放路径</li><li>文件名</li><li>要对文件的操作类型（r,w,rw等)</li></ol><p>主要步骤</p><ol><li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的目录项</strong>，并检查该用户是否有指定的操作权限</li><li><strong>将目录项复制到内存中的 “打开文件表” 中</strong>。并将对应表目的编号返回给用户。之后<strong>用户使用打开文件表的编号来指明要操作的文件</strong></li></ol><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115160723872.png" alt="image-20211115160723872"></p><p><strong>—-关闭文件—-</strong></p><p>与打开文件对应</p><ol><li>将进程的打开文件表对应表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器（count) 减 1，若count=0，则在系统打开文件表中删除表项</li></ol><p><strong>—-读文件—-</strong></p><p>进程使用read系统调用完成写操作。指明是哪个文件（在支持 “打开文件” 的操作系统中，只需要提供文件在打开文件表的索引号即可），还需要指明要读入多少数据（如 1kb），指明读入的数据要存放在内存中的什么位置</p><p>操作系统在处理read系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中</p><p><strong>—-写文件—-</strong></p><p>进程使用 write 系统调用完成写操作，需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要写出多少数据（如：写出 1KB）、写回外存的数据放在内存中的什么位置</p><p>操作系统在处理 write 系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。</p><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115163637800.png" alt="image-20211115163637800"></p><h3 id="基于索引结点的共享方式（硬链接）"><a href="#基于索引结点的共享方式（硬链接）" class="headerlink" title="基于索引结点的共享方式（硬链接）"></a>基于索引结点的共享方式（硬链接）</h3><p>前面文件的物理结构那里有 混合链接方式，其中链接文件的方式就是硬链接。</p><p>索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名，索引结点指针地址</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115163204114.png" alt="image-20211115163204114"></p><p>索引结点中 count表示现在有几个用户正在使用这个文件。假设现在是2，如果其中一个用户删除文件，实际只是把用户目录中与该文件对应的目录项删除，count-1。要完全删除这个文件，需要当count=0时，才会在物理上真正删除此文件。</p><h3 id="基于符号链的共享方式（软链接）"><a href="#基于符号链的共享方式（软链接）" class="headerlink" title="基于符号链的共享方式（软链接）"></a>基于符号链的共享方式（软链接）</h3><p>软链接就类似于快捷方式。例如一个目录的快捷方式，一个应用的快捷方式。用一个link类型文件，记录存放另外一个文件的路径。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211115163608760.png" alt="image-20211115163608760"></p><h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117140603557.png" alt="image-20211117140603557"></p><h3 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h3><p>为文件设置一个 ”口令“，用户请求访问该文件时必须提供 ”口令“</p><p>优点：保存口令的空间开销不多，验证口令的时间开销也很小</p><p>缺点：正确的 ”口令“ 存放在系统内部，不够安全</p><h3 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h3><p>使用 ”密钥“ 对文件进行加密，在访问文件时需要提供正确的 ”密码“ 才能对文件进行正确的解密。</p><p>优点：保密性强，不需要在系统中存储 ”密码“</p><p>缺点： 编码/译码，或者说加密/解密要花费一定时间</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>在每个文件的FCB（或索引结点）中增加一个<strong>访问控制列表</strong>（Access-Control List，ACL），在该表中记录了各个用户可以对该文件执行哪些操作。</p><p>访问类型：</p><ul><li>读</li><li>写</li><li>执行</li><li>添加</li><li>删除</li><li>列表清单</li></ul><p>例如 Linux 中的用户组可以设置权限。单个用户也可以设置权限</p><h2 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117140726004.png" alt="image-20211117140726004"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117140750006.png" alt="image-20211117140750006"></p><h2 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117141900567.png" alt="image-20211117141900567"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117141047181.png" alt="image-20211117141047181"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117141141108.png" alt="image-20211117141141108"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117141254656.png" alt="image-20211117141254656"></p><p><strong>(柱面号，盘面号，扇区号)</strong> 来定位 任意一个 ”磁盘块”</p><p>可根据该地址读取一个“块”</p><p>①根据“柱面号”移动磁臂，让磁头指向指定柱面；</p><p>②激活指定盘面对应的磁头；</p><p>③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。</p><p>盘片可更换的为”<strong>可换盘磁盘</strong>“ 反之 ”<strong>固定盘磁盘</strong>“</p><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117143843571.png" alt="image-20211117143843571"></p><p><strong>一次磁盘读/写操作需要的时间</strong></p><ol><li><p><strong>寻找时间（寻道时间）</strong>：将磁头移动到指定磁道所花时间，<strong>启动磁头臂</strong>假设耗时为s，<strong>移动磁头</strong>每跨越一个磁道为m，需要n条磁道</p><p>*<em>寻道时间 Ts= s + m</em>n**</p></li><li><p>延迟时间 Tr：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r（转/秒，转/分）</p><p>*<em>平均所需延迟时间 Tr = (1/2) \</em> (1/e) = 1/(2r) **</p></li><li><p>传输时间Tt：从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读/写的字节数为 b ，每个磁道上的字节数为 N。则</p><p>*<em>传输时间 Tt = (1/r) * (b/N) = b/(rN)*</em></p></li></ol><p><strong>总得平均存取时间 Ta = Ts + 1/2r + b/(rN)</strong></p><p>操作系统的调度算法会直接影响寻道时间，另外两个跟硬盘自身有关</p><h3 id="先来先服务算法（FCFS）"><a href="#先来先服务算法（FCFS）" class="headerlink" title="先来先服务算法（FCFS）"></a>先来先服务算法（FCFS）</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117142811909.png" alt="image-20211117142811909"></p><h3 id="最短寻找时间优先（SSTF）"><a href="#最短寻找时间优先（SSTF）" class="headerlink" title="最短寻找时间优先（SSTF）"></a>最短寻找时间优先（SSTF）</h3><p>优先处理的是与当前磁头最近的磁道。可以保证每次寻道时间最短，但是并不能保证总的寻道时间最短。但如果左右一直有很近的磁道被请求，就会一直处理这两个，会导致其他饥饿</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117143016108.png" alt="image-20211117143016108"></p><h3 id="扫描算法（SCAN）"><a href="#扫描算法（SCAN）" class="headerlink" title="扫描算法（SCAN）"></a>扫描算法（SCAN）</h3><p>最短寻找时间优先的改良，<strong>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内测磁道的时候才能往外移动。</strong>也叫<strong>电梯算法</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117143155180.png" alt="image-20211117143155180"></p><h3 id="LOOK调度算法"><a href="#LOOK调度算法" class="headerlink" title="LOOK调度算法"></a>LOOK调度算法</h3><p>在扫描算法基础上改良。<strong>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向（边移动边观察）</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117143302333.png" alt="image-20211117143302333"></p><h3 id="循环扫描算法（C-SCAN）"><a href="#循环扫描算法（C-SCAN）" class="headerlink" title="循环扫描算法（C-SCAN）"></a>循环扫描算法（C-SCAN）</h3><p>SCAN算法对于各个位置磁道的响应不平均，<strong>C-SCAN</strong>规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而<strong>返回时直接快速移动至起始端而不处理任何请求</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117143518007.png" alt="image-20211117143518007"></p><h3 id="C-LOOK调度算法"><a href="#C-LOOK调度算法" class="headerlink" title="C-LOOK调度算法"></a>C-LOOK调度算法</h3><p>C-SCAN算法还是要到最后一个磁道，C-LOOK在后面没有磁道需要处理的时候，磁头直接返回。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117143824698.png" alt="image-20211117143824698"></p><h2 id="减少延迟时间"><a href="#减少延迟时间" class="headerlink" title="减少延迟时间"></a>减少延迟时间</h2><h3 id="磁盘地址结构的设计"><a href="#磁盘地址结构的设计" class="headerlink" title="磁盘地址结构的设计"></a><strong>磁盘地址结构的设计</strong></h3><p>为什么要用 （柱面，盘面，扇区），而不用（盘面，柱面，扇区）</p><p>原因：在读取连续地址的磁盘块时，前者不需要移动磁头</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117144633979.png" alt="image-20211117144633979"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117144608259.png" alt="image-20211117144608259"></p><h3 id="交替编号"><a href="#交替编号" class="headerlink" title="交替编号"></a>交替编号</h3><p>因为走完一个扇区的时候，不能马上处理下一个扇区，需要再转一圈才能处理下一个。</p><p>可以让 逻辑上相邻 物理上有一定的间隔，就可以不用转一圈就可以处理下一个。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117144031772.png" alt="image-20211117144031772"></p><h3 id="错位命名"><a href="#错位命名" class="headerlink" title="错位命名"></a>错位命名</h3><p>让相邻<strong>盘面</strong>的扇区编号 错位。原理与交替编号一样。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117145232837.png" alt="image-20211117145232837"></p><h2 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211117145343193.png" alt="image-20211117145343193"></p><h3 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h3><ol><li>进行<strong>低级格式化（物理格式化）</strong>，将磁盘的各个磁道<strong>划分为扇区</strong>。一个扇区通常可分为头，数据区域，尾三个部分。管理扇区所需要的各种数据结构一般存放在头尾。包括扇区校验码（校验码用于检验扇区中的数据是否发生错误）</li><li>将磁盘分区，每个分区由若干柱面组成（C盘，D盘..)</li><li>进行<strong>逻辑格式化</strong>，创建文件系统。包括创建文件系统的根目录，初始化存储空间管理所用数据结构</li></ol><h3 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h3><p>计算机开机的初始化需要通过执行<strong>初始化程序（自举程序）</strong></p><p>初始化程序可以放在ROM中，ROM中的数据出厂时就写入了。<strong>以后不能修改</strong></p><p>但一般都是 Rom中只存放很小的 自举装入程序，通过执行该程序就可以找到引导块，将完整的自举程序读入内存，完成初始化。</p><p>完整的自举程序放在磁盘的启动块（启动分区）。启动块位于磁盘的固定位置。拥有启动分区的磁盘称为<strong>启动磁盘 / 系统盘</strong></p><h3 id="坏块的管理"><a href="#坏块的管理" class="headerlink" title="坏块的管理"></a>坏块的管理</h3><p>对于简单磁盘，可以在逻辑格式化时，对整个磁盘进行坏块检查，标明哪些扇区是坏扇区。例如FAT表上标明（这种方式中，<strong>坏块对操作系统不透明</strong>）</p><p>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件）会维护一张坏块链表。</p><p>在磁盘出厂前进行低级格式化（物理格式化）时就将 坏块链表 进行初始化。会保留一些“备用扇区”，用于替换坏块。这种方案称为 <strong>扇区备用</strong> 。且这种处理方式中，坏块<strong>对操作系统透明</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-第三章</title>
      <link href="2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108200241755.png" alt="image-20211108200241755"></p><p>内存可存放数据。程序执行前<strong>需要先放到内存中才能被CPU处理</strong>–缓和CPU与硬盘之间的速度矛盾</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108194713985.png" alt="image-20211108194713985"></p><h3 id="装入指令的三种方式"><a href="#装入指令的三种方式" class="headerlink" title="装入指令的三种方式"></a>装入指令的三种方式</h3><h4 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h4><p>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码，装入程序按照装入模块中的地址，将程序和数据装入内存。</p><p>也就是<strong>物理地址（绝对地址）</strong></p><p>绝对装入<strong>只适用于单道程序环境</strong>，也就是如果换一台电脑，就可能无法运行，或者是有多个程序，可能会导致错误。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108195119947.png" alt="image-20211108195119947"></p><h4 id="可重定位装入"><a href="#可重定位装入" class="headerlink" title="可重定位装入"></a>可重定位装入</h4><p><strong>静态重定位</strong>：可重定位装入。编译，链接后的装入模块的地址都是从0开始的。</p><p>指令中使用的地址，数据存放的地址都是相对起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“<strong>重定位</strong>“，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）</p><p>特点：一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，<strong>在运行期间就不能再移动</strong>，也不能再申请内存空间。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108195527475.png" alt="image-20211108195527475"></p><h4 id="动态运行时装入"><a href="#动态运行时装入" class="headerlink" title="动态运行时装入"></a>动态运行时装入</h4><p><strong>动态重定位</strong>：又称<strong>动态运行时装入</strong>。编译，链接后的装入模块都是从0开始的。</p><p>装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把<strong>地址转换为推迟到程序真正要执行时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个<strong>重定位寄存器</strong>的支持。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108195900451.png" alt="image-20211108195900451"></p><h3 id="从写程序到运行"><a href="#从写程序到运行" class="headerlink" title="从写程序到运行"></a>从写程序到运行</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108195920041.png" alt="image-20211108195920041"></p><h3 id="链接的三种方式"><a href="#链接的三种方式" class="headerlink" title="链接的三种方式"></a>链接的三种方式</h3><p><strong>静态链接</strong>：在程序运行之前，先将各目标模块及他们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108200036714.png" alt="image-20211108200036714"></p><p><strong>装入时动态链接</strong>：将各目标模块装入内存时，边装入边链接的 方式。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108200127778.png" alt="image-20211108200127778"></p><p><strong>运行时动态链接：</strong>在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108200219921.png" alt="image-20211108200219921"></p><h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109102641039.png" alt="image-20211109102641039"></p><ol><li>在CPU中<strong>设置一对上，下限寄存器</strong>，存放进程的上，下限地址。进程的指令要访问某个地址时，CPU检查是否越界</li><li>采用<strong>重定位寄存器（基址寄存器）</strong>和<strong>界地址寄存器（限长寄存器）</strong>进行越界检查。重定位寄存器中存放的是进程的<strong>起始物理地址</strong>。界地址寄存器中存放的是进程的<strong>最大逻辑地址</strong></li></ol><h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109103858829.png" alt="image-20211109103858829"></p><h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p><strong>覆盖技术</strong>：<strong>解决程序大小超过了物理内存总和  的问题</strong></p><p>思想：将<strong>程序分为多个段</strong>，常用的段常驻内存，不常用的段在需要时调入内存</p><p>内存中分为<strong>固定区</strong>和若干个“<strong>覆盖区</strong>”。常驻的内容放在固定区，覆盖区放需要的内容</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109103104887.png" alt="image-20211109103104887"></p><p><strong>必须由程序员声明覆盖结构</strong>，操作系统完成自动覆盖。</p><p>缺点：<strong>对用户不透明，</strong>增加了用户编程负担。只用于早期的操作系统</p><h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><p>内存空间紧张时，系统将内存中某些进程暂时<strong>换出</strong>外存，把外存已具备运行条件的进程<strong>换入</strong>内存（进程在内存与磁盘间动态调度）</p><p><strong>内存调度（中级调度）</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109103406861.png" alt="image-20211109103406861"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109103539109.png" alt="image-20211109103539109">   在有对换功能的操作系统中，通常把磁盘空间分为<strong>对换区和文件区</strong>。文件区主要存放文件，<strong>主要追求存储空间的利用率</strong>，对文件区空间的管理<strong>采用离散分配方式。对换区</strong>空间只占磁盘空间的小部分，<strong>被换出的进程放在对换区。主要追求换入换出速度</strong>，因此<strong>通常采用连续分配方式。对换区的IO速度比文件区快</strong></p><p><strong>PCB会常驻内存</strong></p><h4 id="交换-分配方式"><a href="#交换-分配方式" class="headerlink" title="交换-分配方式"></a>交换-分配方式</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109111844012.png" alt="image-20211109111844012"></p><p>—-<strong>单一连续分配</strong>—-</p><p>系统区通常位于内存低地址部分，存放操作系统相关数据。用户区存放用户进程相关数据。</p><p>内存中<strong>只能有一道用户程序</strong>，用户程序独占整个用户区空间</p><p><strong>优点：</strong>实现简单，<strong>无外部碎片</strong>；可采用覆盖技术扩充内存，不一定需要采取内存保护</p><p><strong>缺点：</strong>只能用于单用户，单任务的操作系统。<strong>有内部碎片</strong>，存储器利用率极低</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109104426119.png" alt="image-20211109104426119"></p><p>—-<strong>固定分区分配</strong>—-</p><p>其中需要 一个数据结构—<strong>分区说明表</strong>，每个表项对应一个分区，包括对应分区的<strong>大小，起始地址，状态</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109112407539.png" alt="image-20211109112407539"></p><p>优点：实现简单，<strong>无外部碎片</strong></p><p>缺点：用户程序太大时，可能所有分区都不能满足需求，不得不采用覆盖技术，会降低性能</p><p><strong>会产生内部碎片</strong>，内存利用率低</p><ul><li><p>分区大小相等：用户作业划分为<strong>若干个固定大小的分区</strong>，每个分区中装入一个作业</p><p>缺乏灵活性，<strong>适用于用一台计算机控制多个相同对象的场合</strong></p></li><li><p>分区大小不等：从小到大分多个区</p><p>增加了灵活性，可以满足不同大小的进程需求。</p></li></ul><p>—-<strong>动态分区分配</strong>—–</p><p>可变分区分配。<strong>不会预先划分内存分区</strong>。进程进入内存时，<strong>根据进程大小动态地建立分区</strong></p><p><strong>没有内部碎片，有外部碎片</strong></p><p><strong>内部碎片：</strong>分配给某进程的内存区域中，有些部分没用上</p><p>**外部碎片;**内存中的某些空闲分区太小难以利用</p><p>回收内存分区时，可能遇到的四种情况</p><p>具体的操作就是，如果前面有相邻分区，只需要将分区大小改一下。如果是后面有相邻空闲分区，则需要改 下标和分区大小</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109111622172.png" alt="image-20211109111622172"></p><ol><li>回收区之后有相邻的空闲分区</li><li>回收区之前有相邻的空闲分区</li><li>前后都有相邻的空闲分区</li><li>前后都没有相邻的空闲分区</li></ol><h4 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h4><p>—-<strong>首次适应算法</strong>—-</p><p><strong>思想</strong>：每次从低地址开始查找，找到第一个能满足大小的空闲分区</p><p><strong>实现：空闲分区以地址递增的次序排列</strong>。每次分配内存时顺序查找<strong>空闲分区链</strong>（<strong>或空闲分区表</strong>），找到大小能满足的第一个空闲分区</p><p>—-<strong>最佳适应算法</strong>—-</p><p><strong>思想：</strong>动态分区分配是一种连续分配方式。为了保证打进程到来有连续的空间。尽可能留下大片空闲区，优先使用小空闲区</p><p>实现：空闲分区<strong>按容量递增次序链接</strong>。每次分配内存时顺序查找<strong>空闲分区链/表</strong>，找到大小能满足要求的第一个分区</p><p><strong>缺点：每次都选最小的分区进行分配，会留下越来越多的小，小的难以利用的内存快。会产生很多外部碎片</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109113014395.png" alt="image-20211109113014395"></p><p>—-<strong>最坏适应算法</strong>—-</p><p><strong>思想：优先使用 最大的连续空闲区</strong></p><p><strong>实现：</strong>空闲分区<strong>按容量递减次序链接</strong>。每次分配找到大小能满足要求的第一个空闲分区（最大的）</p><p><strong>缺点：每次都选最大的分区分配，会导致较大的连续分区被迅速用完。如果有”大进程“到达，就没有内存可用</strong></p><p>—-<strong>邻近适应算法</strong>—-</p><p><strong>思想：</strong>每次从上次结束的位置开始检索。</p><p><strong>实现：</strong>空闲分区以地址递增的顺序排列（可排为循环链表）。每次分配内存时<strong>从上次查找结束的位置开始</strong>查找<strong>空闲分区表/链</strong>，找到大小能满足要求的第一个空闲分区</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109113604367.png" alt="image-20211109113604367"></p><h3 id="分页存储"><a href="#分页存储" class="headerlink" title="分页存储"></a>分页存储</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109124645089.png" alt="image-20211109124645089"></p><p>将内存分为<strong>大小相等的 分区</strong>，称为<strong>页框（页框=页帧=内存块=物理块=物理页面）</strong>，每个分区有一个<strong>页框号（页框 号=页帧号=内存块号=物理块号=物理页号）</strong>。<strong>页框号从0开始</strong></p><p>进程的逻辑空间也分为<strong>和页框号大小相等</strong>的一个个部分，称为 页/页面。<strong>页面号从0开始</strong>。每个页面对应一个页框，<strong>可以不连续存放</strong>。</p><blockquote><p><strong>页框不能太大，否则会造成 程序最后一个页面，比页框小的情况。可能产生过大的内部碎片浪费</strong></p></blockquote><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><ol><li><strong>每个进程建立一张  页表</strong>。页表通常存在PCB中。</li><li>进程的每个页面对应一个页表项</li><li>每个<strong>页表项</strong>由 ”页号“ 和 ”块号“ 组成</li><li>页表记录进程<strong>页面</strong>和实际存放的<strong>内存块</strong>之间的<strong>映射关系</strong></li><li>每个页表项长度相同</li></ol><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109122354619.png" alt="image-20211109122354619"></p><p>—<strong>页表项占用多少字节</strong>—</p><p>其中页号，是按顺序来算的。例如数组下标，所以不占用内存，是逻辑上显示，物理上没有的。所以只需要存储块号。</p><p><strong>内存块大小=页面大小</strong>=4KB=2^12B</p><p>4GB内存会被分为 2^32/2^12 = 2^20个内存块，内存块号范围为 0 ~ 2^20 -1。则内存块号至少要20bit来表示。则至少要用<strong>3B</strong>来表示块号(3<em>8=24bit)   <strong>（重点）</strong>。存储整个页表则需要 3\</em>(n+1)B</p><p><strong>—实现地址的转换—</strong></p><p>重定位寄存器指明了进程在内存中的起始位置。后面的地址就是相对于起始位置的”<strong>偏移量</strong>”</p><p>–如何确定一个逻辑地址对应的页号、页内偏移量–</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109124458921.png" alt="image-20211109124458921"></p><blockquote><p>如果是2为整数幂，则页号有规律。红色部分的数字是多少，页号就是多少</p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109124513407.png" alt="image-20211109124513407"></p><p>–子问题 为何页面大小要取 2 的整数幂–</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109124608960.png" alt="image-20211109124608960"></p><h4 id="逻辑地址结构（上面页号的结构）"><a href="#逻辑地址结构（上面页号的结构）" class="headerlink" title="逻辑地址结构（上面页号的结构）"></a>逻辑地址结构（上面页号的结构）</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109124628180.png" alt="image-20211109124628180"></p><h4 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109192655065.png" alt="image-20211109192655065"></p><p>通常会在系统中设置一个<strong>页表寄存器</strong>(PTR)，存放<strong>页表在内存中的起始地址F</strong>和<strong>页表长度M</strong>。</p><p>进程未执行时，页表的始址 和 页表长度 <strong>放在进程控制块（PCB）中</strong>，当进程被调度时，操作系统内核会把他们放到页表寄存器中。</p><p><strong>页面大小是2的整数幂。</strong></p><p>例 设页面大小为L，逻辑地址A到物理地址E的变换过程如下</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109191734152.png" alt="image-20211109191734152"></p><p>具体过程</p><ol><li>计算页号P和业内偏移量W（十进制计算是  P=A/L，W=A%L；但在计算机实际运行时，逻辑地址结构是固定不变的，计算机硬件可以很快得到二进制页号，页内偏移量）</li><li>比较页号和页表长度M，若P&gt;=M，就会产生越界中断，否则继续执行。</li><li>页表中页号P对应 *<em>页表项地址=页表起始地址F + 页号P * 页表项长度，*</em>取出该页表项内容b，即为内存块号。</li><li>计算 E=b * L + W，用得到的物理地址E 去访存。（如果是二进制，那么页号和业内偏移量合起来就是物理地址了）</li></ol><blockquote><p>例题</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109192526458.png" alt="image-20211109192526458"></p></blockquote><p><strong>页面管理中地址是一维的。</strong>：只要给出一个逻辑地址，系统就可以自动的算出页号，页内偏移量两个部分。</p><h4 id="快表的基本地址变换机构"><a href="#快表的基本地址变换机构" class="headerlink" title="快表的基本地址变换机构"></a>快表的基本地址变换机构</h4><p><strong>快表</strong>，又称<strong>联想寄存器（TLB</strong>，translation lookaside buffer），是一种<strong>访问速度比内存快很多</strong>的高速缓存（<strong>TLB不是内存</strong>），用来存放<strong>最近访问的页表项的副本</strong>，可以加速地址变换的速度。与此对应，内存中的页表常称为<strong>慢表</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109202258379.png" alt="image-20211109202258379"></p><p>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。 </p><p>② 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块 号，再将内存块号与页内偏移量拼接形成物理地址，最后，<strong>访问</strong>该物理地址对应的<strong>内存单元</strong>。因此，若<strong>快表命中</strong>，则访问某个逻辑地址仅需<strong>一次访存</strong>即可。 </p><p>③ 如果没有找到匹配的页号，则<strong>需要访问内存中的页表</strong>，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，<strong>访问</strong>该物理地址对应的<strong>内存单元</strong>。因此，<strong>若快表未命中</strong>，则访问某个逻辑地址需要<strong>两次访存（注意：在找到页表项后，应同时将其存入快表，</strong> 以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换） </p><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，一般来说快表的命中率可以达到 90% 以上</p><blockquote><p>例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时 1us，访 </p><p>问一次内存耗时 100us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少？ </p><p>(1+100) *    0.9 + (1+100+100) *    0.1 = 111 us。前面1+100是快表查询和访存的时间，后面是慢表的。</p><p>有的系统支持<strong>快表和慢表同时查找</strong>，如果是这样，平均耗时应该是 (1+100) *    0.9 + (100+100) *    0.1 =</p><p>110.9 us</p><p>若<strong>未</strong>采用快表机制，则访问一个逻辑地址需要 100+100 = 200us</p><p>显然，引入快表机制后，访问一个逻辑地址的速度快多了</p></blockquote><p><strong>–局部性原理–</strong></p><p>组原里面有介绍。分为时间局部性和空间局部性。简单来说</p><p>时间局部性，如果执行了程序中的某条指令，那么不久后这条指令可能再次执行。如果数据被访问过，那么数据还可能再被访问</p><p>空间局部性，程序执行的语句，不久之后，其附近的语句也可能会被执行。</p><h4 id="–区别–"><a href="#–区别–" class="headerlink" title="–区别–"></a>–<strong>区别</strong>–</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109202829839.png" alt="image-20211109202829839"></p><h4 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109205117393.png" alt="image-20211109205117393"></p><p>先说单级页表的缺点。</p><ol><li><strong>所有的页表项都需要连续存放</strong>。不然就不能找到页表项。</li><li>还有就是<strong>进程在一段时间内只需要访问某几个页面就可以正常运行。因此没有必要让整个页表都常驻内存</strong></li></ol><p>采用两级页表解决第一个问题</p><p>采用两级页表，二级页表还是存放 内存块号，新加的一级页号存放二级页表的内存块号</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109203523293.png" alt="image-20211109203523293"></p><p>注意的是，物理地址是几个逻辑地址合起来的。</p><blockquote><p>例 找 块号4的内存块。</p><p>则，内存块起始地址为 4*4096=16384，页内偏移量为4095</p><p>则，最终地址为 16384+4095=20479</p><p>这里4*4096是 4内存块号，4096是2^12次方，需要将1左移到第13位。</p></blockquote><p>问题二解决</p><p>可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已调入内存。</p><p>若想访问的页面不再内存中，则产生缺页中断（内中断/异常），然后将目标页面从外存调入内存。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109204836430.png" alt="image-20211109204836430"></p><p>注意的细节</p><ol><li><p>若分为两级页表之后，页表依然很长，还可以采用更多级页表，一般来说<strong>各级页表的大小不能超过一个页面</strong></p><p>例如<img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109205002232.png" alt="image-20211109205002232"></p></li><li><p>两级页表的<strong>访存次数</strong>分析（假设没有快表）</p><p>第一次访存：访问内存中的页目录表</p><p>第二次访存：访问内存中的二级页表</p><p>第三次访存：访问目标内存单元</p></li></ol><h4 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109211804412.png" alt="image-20211109211804412"></p><p><strong>分段：</strong>进程的地址空间，按照程序<strong>自身的逻辑</strong>关系<strong>划分为若干个段</strong>，每个段都有一个段明（在低级语言中，程序员使用段名来编程），<strong>每段从0开始编制</strong></p><p>内存分配规则：以段位单位进行分配，<strong>每个段在内存中占据连续空间，但各段之间可以不相邻</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109205403027.png" alt="image-20211109205403027"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109210651556.png" alt="image-20211109210651556"></p><p><strong>段号的位数决定了每个进程最多可以分几个段</strong> </p><p><strong>段内地址位数决定了每个段的最大长度是多少</strong></p><p>上面图中三个颜色可以从上到下 0-2的段号</p><h5 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h5><p>类似与 页表</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109210934214.png" alt="image-20211109210934214"></p><ol><li>每个段对应一个段表项，其中记录了该段在内存中的<strong>起始位置</strong>（又称 “<strong>基址</strong>”）和<strong>段的长度</strong></li><li><strong>各个段表项的长度是相同的。且段号是可以隐含的，不占存储空间。</strong></li></ol><h5 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h5><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109211218662.png" alt="image-20211109211218662"></p><h5 id="分段分页对比"><a href="#分段分页对比" class="headerlink" title="分段分页对比"></a>分段分页对比</h5><p><strong>页</strong>是<strong>信息的物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管 理上的需要，完全是系统行为，<strong>对用户是不可见的</strong>。 </p><p><strong>段</strong>是<strong>信息的逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<strong>分段对用户是可见的</strong>，用户编程时需要显式地给出段名。 </p><p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。 </p><p><strong>分页</strong>的用户进程<strong>地址空间是一维的</strong>，程序员只需给出一个记忆符即可表示一个地址。 </p><p><strong>分段</strong>的用户进程<strong>地址空间是二维的</strong>，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</p><p><strong>分段比分页更容易实现信息的共享和保护。</strong> </p><p>不能被修改的代码称为<strong>纯代码或可重入代码</strong>（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）</p><p>因为分段是一整个程序段，分为一段。分页是固定大小分页，其中可能一个页面中有两个程序的数据。</p><p>访问一个逻辑地址需要几次访存？ </p><p><strong>分页（单级页表）</strong>：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共<strong>两次 访存</strong></p><p><strong>分段</strong>：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共<strong>两次访存</strong> </p><p>与分页系统类似，分段系统中也<strong>可以引入快表机构</strong>，将近期访问过的段表项放到快表中，这样<strong>可以</strong> <strong>少一次</strong>访问，加快地址变换速度。</p><h4 id="段页管理方式"><a href="#段页管理方式" class="headerlink" title="段页管理方式"></a>段页管理方式</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109212904572.png" alt="image-20211109212904572"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109211859707.png" alt="image-20211109211859707"></p><p>使用分段+分页=段页式管理</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109211943020.png" alt="image-20211109211943020"></p><p><strong>逻辑结构</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109212033084.png" alt="image-20211109212033084"></p><blockquote><p>分段是对用户可见的，分页是对用户不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此<strong>段页式</strong>管理的<strong>地址结构是二维的</strong></p></blockquote><p><strong>段号的位数决定了每个进程最多可以分几个段，页号位数决定了每个段最大有多少页，页内偏移量决定了页面大小，内存块大小是多少</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109212806680.png" alt="image-20211109212806680"></p><hr><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211109212840643.png" alt="image-20211109212840643"></p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211112210535212.png" alt="image-20211112210535212"></p><p>先说  传统存储管理方式的特征、缺点</p><ul><li><strong>一次性：作业必须一次性全部装入内存后才能开始运行</strong>。会造成两个问题<ul><li>作业很大时，不能全部装入内存，导致<strong>大作业无法运行</strong></li><li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行。导致<strong>多道程序并发度下降</strong></li></ul></li><li><strong>驻留性：</strong>一旦作业被装入内存，就<strong>会一直驻留在内存</strong>中，直至作业运行结束。但事实上，一个时间段内，只需要访问作业的一小部分数据即可正常运行，这导致内存中会有大量冗余、暂时用不到的数据。</li></ul><p><strong>虚拟内存的定义和特征</strong></p><p>基于局部性原理，</p><p>在程序装入时，可以将程序中<strong>很快会用到的部分装入内存，暂时用不到的部分留在外存</strong>就可以让程序开始执行。</p><p>在程序执行过程中，当所访问的<strong>信息不在内存时</strong>，由<strong>操作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序</p><p>若内存空间不够，由<strong>操作系统负责</strong>将内存中<strong>暂时用不到的信息换出到外存</strong></p><p>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的，这就是<strong>虚拟内存</strong></p><blockquote><p>虚拟内存的<strong>最大容量</strong>是由计算机的地址结构（CPU寻址范围）确定的</p><p>虚拟内存的<strong>实际容量</strong> = min（内存和外存容量之和，CPU寻址范围）</p><p>例如</p><p>计算机地址结构32位，按字节编制，内存大小为512MB，外存大小2GB</p><p>则虚拟内存的<strong>最大容量</strong>为 2^32B = 4GB</p><p>虚拟内存的<strong>实际容量</strong> = min(2^32B , 512MB+2GB) = 2GB+512MB</p></blockquote><p><strong>三个主要特征</strong></p><ul><li><strong>多次性</strong>：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存</li><li><strong>对换性</strong>：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出</li><li><strong>虚拟性</strong>：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量</li></ul><p><strong>实现</strong></p><p>虚拟内存需要建立在<strong>离散分配</strong>的内存管理方式基础上</p><p>虚拟内存的实现，有三种方法</p><ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ul><h3 id="请求分页的方式"><a href="#请求分页的方式" class="headerlink" title="请求分页的方式"></a>请求分页的方式</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211112212651952.png" alt="image-20211112212651952"></p><p><strong>请求分页</strong>存储管理与<strong>基本分页</strong>存储管理的主要区别是：</p><p>在程序执行过程中，当所<strong>访问的信息不在内存时，由操作系统负责将所需信息从外存调入</strong>，然后继续执行程序。若内存空间不足，由操作系统负责<strong>将内存中暂时用不到的信息换出外存</strong></p><h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a><strong>页表机制</strong></h4><blockquote><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要 知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存 中存放的位置。 </p><p>当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到 底换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页 面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。</p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211112211252646.png" alt="image-20211112211252646"></p><h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a><strong>缺页中断机构</strong></h4><p><strong>属于内中断</strong>，<strong>一条指令</strong>在执行期间，<strong>可能产生多次缺页中断</strong></p><p>假如此时要访问逻辑地址 = （页号，页内偏移量） = （0，1024）</p><p>在请求分页系统中，每当要访问的<strong>页面不存在时</strong>，就会产生<strong>缺页中断</strong>，然后由操作系统的缺页<strong>中断处理程序处理中断</strong></p><p>此时<strong>缺页的进程阻塞</strong>，放入阻塞队列，调页<strong>完成后再将其唤醒</strong>，放回就绪队列。</p><p>如果内存中<strong>有空闲块</strong>，则为进程<strong>分配一个空闲块</strong>，将所缺页面装入该块，并修改页表中相应的页表项</p><p>而如果内存汇总<strong>没有空闲块</strong>，则<strong>由页面置换算法选择一个页面淘汰</strong>，若该页面在内存期间<strong>被修改过</strong>，则要将其<strong>写回外存</strong>。未修改过的页面不用写回外存</p><h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p>想比于基础的地址变换机构。新增了几个步骤</p><ol><li>请求调页（查到页表项时进行判断）</li><li>页面置换（需要调入页面，但没有空闲内存块时进行）</li><li>需要修改请求页表中新增的表项</li></ol><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211112212311567.png" alt="image-20211112212311567"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211112212516506.png" alt="image-20211112212516506"></p><blockquote><p>补充细节： 图中1-5，王道考研书3-24</p><p>①只有“写指令”才需要修改 “修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。 </p><p>②和普通的中断处理一样，缺页 中断处理依然需要保留CPU现场。 </p><p>③需要用某种“页面置换算法” 来决定一个换出页面（下节内容） </p><p>④换入/换出页面都需要启动慢 速的I/O操作，可见，如果换入/ 换出太频繁，会有很大的开销。 </p><p>⑤页面调入内存后，需要修改慢 表，同时也需要将表项复制到快 表中。</p></blockquote><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>需求：<strong>追求更少的缺页率</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211112215635730.png" alt="image-20211112215635730"></p><h4 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h4><p>OPT , Optimal : 每次选择<strong>淘汰的页面</strong>将是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率</p><p>注意：最佳置换算法可以保证最低的缺页率。但进程执行过程中才能知道接下来会访问到的是哪一个页面。操作系统无法预知页面访问序列。因此<strong>最佳置换算法无法实现</strong></p><blockquote><p>例题这里是假设已知所有进程的序列。所以才能做到最佳置换算法</p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211112213154551.png" alt="image-20211112213154551"></p><h4 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h4><p>每次选择<strong>淘汰的页面</strong>是<strong>最早进入内存的页面</strong></p><p>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211112213710918.png" alt="image-20211112213710918"></p><hr><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211112213728049.png" alt="image-20211112213728049"></p><hr><p>注意到：分配4个内存块的反而比3个内存块的缺页次数更多。<strong>Belady异常</strong>—-当为进程分配的物理快增大时，缺页次数不减反增的异常现象</p><p><strong>只有FIFO算法会产生Belady异常。</strong>FIFO算法虽然<strong>实现简单</strong>。但算法与进程实际运行规律不适应，先进入的页面也有可能最经常被访问。<strong>算法性能差</strong></p><h4 id="最近最近未使用置换算法（LRU）"><a href="#最近最近未使用置换算法（LRU）" class="headerlink" title="最近最近未使用置换算法（LRU）"></a>最近最近未使用置换算法（LRU）</h4><p>每次<strong>淘汰的页面</strong>是<strong>最近最久未使用的页面</strong></p><p>实现方法：赋予每个页面对应的页表项中，用**访问字段记录该页面自上次被访问以来所经历的时间 t **。当需要淘汰一个页面时，选择现有页面中 t 最大的。最近最久未使用的页面</p><p>缺点：算法的实现需要专门的硬件支持，<strong>算法性能好，实现困难，开销大</strong></p><blockquote><p>这里到3的位置那里，最久未使用的是7，则7被置换</p><p>手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号，在<strong>逆向扫描过程中最后一个出现的页号就是要淘汰的页面</strong></p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211112214207507.png" alt="image-20211112214207507"></p><h4 id="时钟置换算法（CLOCK）"><a href="#时钟置换算法（CLOCK）" class="headerlink" title="时钟置换算法（CLOCK）"></a>时钟置换算法（CLOCK）</h4><p>又称<strong>最近未用算法（NRU，Not Recently Used）</strong></p><p>实现方法：为每个页面设置一个<strong>访问位</strong>，再将内存中的页面都通过链接指针<strong>链接称一个循环队列</strong>。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位，如果是0，就选择该页换出；如果是1，则将他置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（一定会有0的页面，因此<strong>简单的CLOCK算法</strong>选择一个淘汰页面<strong>最多会经过两轮扫描</strong>）</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211112214925547.png" alt="image-20211112214925547"></p><h4 id="改进的时钟置换算法"><a href="#改进的时钟置换算法" class="headerlink" title="改进的时钟置换算法"></a>改进的时钟置换算法</h4><p>简单的时钟置换算法只考虑到了是否被访问过，改进的是，增加了<strong>只有被淘汰的页面被修改过，才需要写回外存</strong>。在<strong>其他条件都相同时，应优先淘汰没有修改过的页面</strong>，避免IO操作。</p><p><strong>修改位=0 页面没有被修改——————修改位=1 页面被修改</strong>。<strong>（讨论位，修改位）</strong></p><p>算法规则–四个步骤</p><ol><li>从当前位置开始扫描到第一个 （0，0）的帧用于替换。<strong>本轮扫描不修改任何标志</strong></li><li>第一轮扫描失败，重新扫描。查找第一个 （0，1）的帧用于<strong>替换</strong>。本轮将所有扫描过的帧 <strong>访问位</strong>置为0</li><li>第二轮扫描失败，重新扫描。查找第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位</li><li>第三轮扫描失败，重新扫描。查找第一个（0，1）的帧用于替换</li></ol><p>由于第二轮已将所有帧的访问位置为0，因此经过第三轮第四轮扫描，一定会有帧被选中，因此<strong>改进型CLOCK置换算法</strong>选择一个淘汰页面<strong>最多会进行四轮扫描</strong></p><h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211112223243687.png" alt="image-20211112223243687"></p><p><strong>驻留集：</strong>指请求分页存储管理中给进程分配的物理快的集合</p><blockquote><p>若驻留集太小：会导致缺页频繁，系统要花大量的时间处理缺页。</p><p>驻留集太大：会导致多道程序并发度下降，资源利用率低</p></blockquote><ul><li><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不变，即<strong>驻留集大小不变</strong></li><li><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即<strong>驻留集大小可变</strong></li><li><strong>局部置换：</strong>发生缺页时只能选进程自己的物理块进行置换</li><li><strong>全局置换：</strong>可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211112220357770.png" alt="image-20211112220357770"></p><p><strong>固定分配局部置换：</strong>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。</p><p>优缺点：很难从刚开始就确定应为每个进程分配多少个物理块才算合理。（这种策略的系统可以根据进程大小，优先级，或是根据程序员给出的参数来确定为一个进程分配的内存块数）</p><p><strong>可变分配全局置换</strong>：刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给进程；若已无空闲物理块，则可选择一个<strong>未锁定</strong>的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，<strong>只要某进程发生缺页，都将获得新的物理块</strong>，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个<strong>被选中的进程拥有的物理块会减少，缺页率会增加</strong></p><blockquote><p>系统会锁定一些页面。这些页面中的内容不会被换出到外存（如重要的内核数据）</p></blockquote><p><strong>可变分配局部置换：</strong>刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁的缺页，系统会为该进程多分配几个物理块，直至该进程缺页率到适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块</p><p>可变分配<strong>全局</strong>置换：只要缺页就给分配新物理块</p><p>可变分配<strong>局部</strong>置换：要根据发生<strong>缺页的频率</strong>来动态的增加或减少进程的物理块</p><h4 id="何时调入"><a href="#何时调入" class="headerlink" title="何时调入"></a>何时调入</h4><ol><li>预调页策略：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不就之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%。这种策略<strong>主要用于进程的首次调入</strong></li><li>请求调页策略：进程<strong>在运行期间发现缺页时才将所缺页面调入内存</strong>。需要IO操作，IO开销大</li></ol><h4 id="何处调入"><a href="#何处调入" class="headerlink" title="何处调入"></a>何处调入</h4><ol><li>系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区</li><li>系统缺少足够的对换区空间：凡事不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入</li><li>UNIX方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入</li></ol><h4 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h4><p>刚刚换出的页面马上又要换入内存，刚刚换入页面的马上又被换出内存，这种频繁的页面调度行为称为<strong>抖动</strong>，或<strong>颠簸</strong>。产生抖动的<strong>主要原因</strong>是进程频繁访问的页面数目高于可用的物理块数（<strong>分配给进程的物理块不够</strong>）</p><p>解决 Denning “工作集概念</p><h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><p>在某段时间间隔内，进程实际访问页面的集合</p><p>操作系统会根据 ”窗口尺寸“ 来算出工作集</p><p>例<img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211112222725247.png" alt="image-20211112222725247"></p><p><strong>工作集大小</strong>可能小于窗口尺寸。实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。</p><p>如 窗口尺寸5，一段时间检测发现某进程工作集最大为3，那么说明该进程有很好的局部性，只需要分配3个以上的内存块即可满足进程的需要。</p><p><strong>驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页</strong></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-第二章</title>
      <link href="2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030161833740.png" alt="image-20211030161833740"></p><p>程序：是<strong>静态的</strong>，存放在磁盘的可执行文件，是一系列指令集合</p><p>进程（Process）：<strong>动态的</strong>，是程序的一次执行过程（同一个程序多次执行会对应多个进程）</p><h3 id="进程的组成-pcb"><a href="#进程的组成-pcb" class="headerlink" title="进程的组成-pcb"></a>进程的组成-pcb</h3><p>PID：当进程被创建时，操作系统会给该系统分配一个<strong>唯一的，不重复</strong>的”身份号</p><p>UDI：进程所属用户</p><p>还要记录给进程分配了哪些资源（如内存，正在使用哪些IO设备….)，运行情况（CPU使用时间，磁盘使用情况….)</p><p>这些同一放在数据结构 <strong>PCB(Process Control Block) **中，即</strong>进程控制块<strong>，操作系统需要对各个并发运行的进程进行管理，</strong>但凡管理时所需要的信息，都会被放在PCB中**</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030161125698.png" alt="image-20211030161125698"></p><h3 id="进程的组成—程序段、数据段"><a href="#进程的组成—程序段、数据段" class="headerlink" title="进程的组成—程序段、数据段"></a>进程的组成—程序段、数据段</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030161150663.png" alt="image-20211030161150663"></p><p>一个<strong>进程实体（进程映像）由PCB、程序段、数据段</strong>租车给你。进程是动态的，进程实体是静态的。进程实体反应了进程在某一时刻的状态。</p><p>进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>系统分配和调度</strong>的一个独立单位</p><h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><ul><li>动态性：进程是程序的一次执行过程，是动态的产生、变化和消亡</li><li>并发性：内存中有多个进程实体，各进程可并发执行</li><li>独立性：进程能独立运行、独立获得资源、独立接收调度的基本单位</li><li>异步性：各进程按各自独立的、不可预知的速度向前推进、操作系统要提供 “进程同步机制” 来解决异步问题</li><li>结构性：每个进程都会配置一个PCB，结构上看，进程由程序段、数据段、PCB组成</li></ul><h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3><p>进程的组成讨论的是<strong>进程内部</strong>由哪些部分构成，而进程的<strong>组织</strong>是多个进程之间组织方式问题</p><ul><li><p>链接方式</p><ul><li><p>按照进程状态将PCB分为多个队列</p></li><li><p>操作系统持有只想各个队列的指针</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030162139923.png" alt="image-20211030162139923"></p></li></ul></li><li><p>索引方式</p><ul><li><p>根据进程状态的不同，建立几张索引表</p></li><li><p>操作系统持有指向各个索引表的指针</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030162154894.png" alt="image-20211030162154894"></p></li></ul></li></ul><h2 id="状态与转换"><a href="#状态与转换" class="headerlink" title="状态与转换"></a>状态与转换</h2><p><strong>进程PCB中，会有一个变量state来表示进程的当前状态。如1表示创建态…..**为了对同一个进程的状态进行统一的管理，操作系统会降各个进程的PCB组织起来。  就是</strong>上面的链接和索引的组织方式**</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030163556374.png" alt="image-20211030163556374"></p><h3 id="创建态、就绪态"><a href="#创建态、就绪态" class="headerlink" title="创建态、就绪态"></a><strong>创建态、就绪态</strong></h3><p>进程正在被创建时，他的状态是“<strong>创建态</strong>”，在这个阶段操作系统会为进程分配资源，初始化PCB。当进程创建完成后，便进入 “<strong>就绪态</strong>”，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行</p><h3 id="运行态"><a href="#运行态" class="headerlink" title="运行态"></a>运行态</h3><p>如果一个进程此时在CPU上运行，那么这个进程就 处于 “<strong>运行态</strong>。CPU会执行该进程对应的程序</p><h3 id="阻塞态"><a href="#阻塞态" class="headerlink" title="阻塞态"></a>阻塞态</h3><p>在进程运行的过程中，可能会<strong>请求等待某个时间的发生</strong>（如等待系统资源的分配，或等待其他程序的响应）。在这个时间发生之前，进程无法执行，此时会让这个进程出CPU，并进入”<strong>阻塞态“</strong> 。当CPU空闲时又会选择另一个 ”就绪态“进程上CPU运行</p><h3 id="终止态"><a href="#终止态" class="headerlink" title="终止态"></a>终止态</h3><p>可以通过exit系统调用，请求操作系统终止该进程。此时该进程会进入 ”终止态“ ，操作系统会让该进程下CPU，并回收内存空间等资源，回收该进程的PCB。终止进程完成后，这个进程就消失。</p><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030163638116.png" alt="image-20211030163638116"></p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211101205913272.png" alt="image-20211101205913272"></p><p>进程控制实现进程状态转换</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211101204410503.png" alt="image-20211101204410503"></p><p>原语的必要性：如果在阻塞队列的PCB2，要换为就绪态，就得先把PCB2的state换为1(就绪态)，然后将PCB2放到就绪队列。刚做完第一步，被其他进程抢了CPU，则PCB2还在阻塞队列，但是state为2。</p><h3 id="原语原子性"><a href="#原语原子性" class="headerlink" title="原语原子性"></a>原语原子性</h3><p>原语的执行有<strong>原子性</strong>，执行只能一次走到底，期间<strong>不允许被中断</strong>，可以用<strong>关中断</strong>指令和<strong>开中断</strong>指令，这两个<strong>特权指令</strong>实现<strong>原子性</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211101204739037.png" alt="image-20211101204739037"></p><blockquote><p>CPU执行了关中断指令之后，就不会检查中断信号。只到开中断信号</p></blockquote><h3 id="相关原语"><a href="#相关原语" class="headerlink" title="相关原语"></a>相关原语</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211101205633873.png" alt="image-20211101205633873"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211101205649053.png" alt="image-20211101205649053"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211101205655050.png" alt="image-20211101205655050"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211101205717127.png" alt="image-20211101205717127"></p><p>这里的<strong>运行环境</strong>指的是，假如一个程序被中断，运行其他程序。则会将自己的指令执行的地址，寄存器的数据等等。放到PCB中</p><p>**进程控制相关的原语的 运行 **</p><p>1.更行PCB中的信息</p><p>​    a.所有的进程控制原语一定都会修改进程状态标志</p><p>​    b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境</p><p>​    c.某进程开始运行前必然要恢复其运行环境</p><p>2.将PCB插入合适的队列</p><p>3.分配/回收资源</p><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211101211704031.png" alt="image-20211101211704031"></p><p>进程之间的信息交换</p><p>进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程</strong>拥有的<strong>内存地址空间相互独立</strong>。且为了安全，<strong>一个进程不能直接访问其他进程的地址空间</strong>。操作系统另外提供了进程直接通信的方法</p><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><ul><li><p>基于数据结构的共享</p><p>例：共享空间里只能放一个长度为10的数组。这样的共享方式速度慢，限制多，是<strong>低级通信</strong>方式</p></li><li><p>基于存储区的共享</p><p>在内存中画出一块共享存储区。存放位置都由进程控制，而不是操作系统。共享速度更快，<strong>高级通信</strong></p></li></ul><h3 id="管道-pipe-通信"><a href="#管道-pipe-通信" class="headerlink" title="管道(pipe)通信"></a>管道(pipe)通信</h3><p>用于连接读写进程的一个共享文件。其实就是内存中开辟一个大小固定的缓冲区</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211101211044223.png" alt="image-20211101211044223"></p><p>1.管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向传输。如果要实现<strong>双向同时通信</strong>，则<strong>需要设置两个管道</strong></p><p>2.各进程要<strong>互斥</strong>地访问管道</p><p>3.数据以字符的形式写入管道，管道满时，写操作被阻塞。等待读进程将数据取走。读进程取光之后。管道空，读进程阻塞。</p><p>4.如果<strong>没写满，不允许读</strong>。如果<strong>没读空，不允许写</strong></p><p>5.数据一旦被读出，就从管道中被抛弃。所以读进程只能有一个，否则会有数据错读。</p><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>进程间的数据交换以<strong>格式化的消息（Message）</strong>为单位。进程通过操作系统提供的 “发送消息/接收消息” 两个<strong>原语</strong>进行数据交换。有消息头和消息体，发送给对方。</p><p>且有间接和直接的方式。直接方式就是直接传到他的地址，间接方式类似于信箱模式，放到信箱等接收方取。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102144123643.png" alt="image-20211102144123643"></p><h3 id="概念与特点"><a href="#概念与特点" class="headerlink" title="概念与特点"></a>概念与特点</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211101212242037.png" alt="image-20211101212242037"></p><p>可以把线程理解为 “轻量级进程”</p><p><strong>线程</strong>是一个<strong>基本的CPU执行单元</strong>，也是<strong>程序执行流的最小单位</strong>。<strong>进程内部的线程之间也可以并发，提高了系统的并发度。</strong></p><p>在使用了线程后，<strong>进程</strong>只作为<strong>除CPU之外的系统资源的分配单元</strong>（如打印机，内存地址空间等都是分配给进程的）。线程则作为<strong>处理机的分配单元</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211101212746689.png" alt="image-20211101212746689"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211101212755785.png" alt="image-20211101212755785"></p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a><strong>用户级线程</strong></h4><p>早期的操作系统，只支持进程，不支持线程。当时的“线程”是 由线程库实现</p><ol><li>用户级线程由应用程序通过线程库实现，所有的<strong>线程管理工作</strong>都由<strong>应用程序负责</strong>（包括线程切换）</li><li>用户级线程中，<strong>线程切换</strong>可以在<strong>用户态下即可完成</strong>，无需操作系统干预</li><li>在用户看来，是有多个线程。但是在操作系统内核看来，意识不到线程的存在。<strong>用户级线程</strong>就是<strong>从用户视角能看到的线程</strong></li></ol><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上并行运行</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102142312546.png" alt="image-20211102142312546"></p><h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p>内核支持的线程，由操作系统支持的线程</p><ol><li><strong>内核级线程的管理工作</strong>由<strong>操作系统内核完成</strong></li><li>线程调度、切换等工作都由内核负责，因此<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下才能完成</li><li>操作系统会为每个内核级线程建立对应的TCB（Thread control block，线程控制块），通过TCB对线程进行管理。“<strong>内核级线程</strong>”就是“<strong>从操作系统内核视角看，可以看到的线程</strong>”</li></ol><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上执行</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，线程管理成本高，开销大。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102143018181.png" alt="image-20211102143018181"></p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><ul><li><p><strong>一对一</strong>：一个用户级线程映射到一个内核级线程，每个用户进程有与用户级线程同数量的内核级线程</p><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上执行</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态。线程管理的成本高，开销大</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102143622785.png" alt="image-20211102143622785"></p></li><li><p><strong>多对一：</strong>多个用户级线程映射到一个内核级线程，且一个进程只被分配一个内核级线程</p><p>优点：用户级线程的切换在用户空间可以完成。开销小，效率高</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会阻塞。并发度不高。多个线程不可在多核处理机上并行运行</p></li></ul><h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a><strong>重点</strong></h4><p>操作系统只 看得见 内核级线程，<strong>只有内核级线程才是处理机分配的单位</strong></p><ul><li><p><strong>多对多</strong></p><p>n用户及线程映射到m个内核级线程 (<strong>n&gt;=m</strong>)。每个用户进程对应m个内核级线程</p><p>内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程都在运行时，这个进程才会阻塞</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102143951105.png" alt="image-20211102143951105"></p></li></ul><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102145415881.png" alt="image-20211102145415881"></p><p>当有一堆任务要处理，由于资源有限，就需要确定<strong>某种规则</strong>来<strong>决定</strong>处理这些任务的<strong>顺序</strong></p><h4 id="高级调度（作业调度）"><a href="#高级调度（作业调度）" class="headerlink" title="高级调度（作业调度）"></a>高级调度（作业调度）</h4><p>按一定的原则从 <strong>外存</strong>的作业后背队列中挑选一个作业 <strong>调入内存</strong>，并创建进程。<strong>每个作业只调入一次，调出一次</strong>。作业调入会建立PCB，调出就撤销PCB</p><h4 id="中级调度（内存调度）"><a href="#中级调度（内存调度）" class="headerlink" title="中级调度（内存调度）"></a>中级调度（内存调度）</h4><p>按照某种策略决定将那个处于挂起状态的进程重新调入内存。一个进程可能会被多次调入，多次调出内存，因此<strong>中级调度</strong>发生的<strong>频率</strong>比高级调度<strong>更高</strong></p><p>暂时调到外存等待的进程状态为<strong>挂起状态</strong>。被挂起的进程PCB会被组织为<strong>挂起队列</strong></p><h4 id="低级调度（进程调度-处理机调度）"><a href="#低级调度（进程调度-处理机调度）" class="headerlink" title="低级调度（进程调度/处理机调度）"></a>低级调度（进程调度/处理机调度）</h4><p>按照某种策略从 <strong>就绪队列</strong>中选取一个进程，将处理机分配给他。进程调度是操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度。进程调度的<strong>频率很高</strong>，一般几十毫秒一次。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102145354576.png" alt="image-20211102145354576"></p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102153704667.png" alt="image-20211102153704667"></p><h4 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h4><p>这里，有的系统中，只允许进程主动放弃处理机。</p><p>有的系统中，进程可以主动放弃处理机，当有更紧迫的任务需要处理时，也会强行剥夺处理机（被动放弃）</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102152414870.png" alt="image-20211102152414870"></p><p>进程在<strong>操作系统内核程序临界区</strong>中<strong>不能</strong>进行调度与切换。这里要注意临界区和内核程序临界区的区别。临界区可以进行调度与切换。</p><p>临界资源：一个时间段内只允许一个进程使用的资源，各进程需要<strong>互斥的</strong>访问临界资源。</p><ul><li><p>临界区：访问临界区资源的那一段代码</p></li><li><p><strong>内核程序程序临界区</strong>：一般是用来访问<strong>某种内核数据结构</strong>，比如进程的就绪队列</p></li></ul><h4 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h4><ul><li><p><strong>非剥夺方式</strong>，又称<strong>非抢占方式</strong>。只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，知道该进程终止或主动要求进入阻塞态</p><p>适用于早期的批处理系统</p></li><li><p><strong>剥夺调度方式</strong>，又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停当前正在执行的进程。将处理机分配给更重要的进程</p><p>适合分时操作系统，实时操作系统</p></li></ul><h4 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h4><ul><li><strong>狭义的进程调度</strong>：指的是从就绪队列中<strong>选中一个要运行的进程</strong>（可以是刚刚被暂停的进程，也可能是<strong>另一个进程</strong>，后一种情况需要<strong>进程切换</strong>）。<strong>进程切换</strong>指一个进程让出处理机，由另一个进程占用处理机的过程</li><li><strong>广义的进程调度</strong>包含了选择一个进程和进程切换两个步骤</li></ul><p>进程切换过程主要完成了，对原来运行进程各种数据的保存，对新的进程各种数据的恢复</p><p><strong>进程切换是有代价的</strong>，如果<strong>过于频繁的</strong>进行进程<strong>调度，切换</strong>，必然会使整个<strong>系统的效率降低</strong>，使系统大部分时间都花在进程切换上，而真正用于执行进程的时间减少</p><h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102154001761.png" alt="image-20211102154001761"></p><h4 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h4><p>指 cpu 忙碌的时间占总时间的比例</p><p><strong>利用率= 忙碌的时间/总时间</strong></p><h4 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h4><p>单位时间内完成作业的数量</p><p><strong>系统吞吐量= 总共完成多少作业 / 总共花了多少时间</strong></p><h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4><p>指 从<strong>作业被提交给系统开始</strong>，到<strong>作业完成为止</strong>的这段时间间隔</p><p>它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等 待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项 在一个作业的整个处理过程中，可能发生多次。</p><p><strong>周转时间 (作业)</strong>=作业完成时间 - 作业提交时间</p><p>**平均周转时间=**各作业周转时间之和 /  作业数</p><p>**带权周转时间=**作业周转时间 / 作业实际运行的时间 = (作业完成时间 - 作业提交时间) / 作业实际运行的时间  </p><blockquote><p>带权周转时间必然  &gt;=1，带权周转时间和周转时间都是越小越好</p></blockquote><p><strong>平均带权周转时间=</strong> 各作业带权周转时间之和 / 作业数</p><blockquote><p>对呀周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的次数更多，带权周转时间更小，用户满意度更高</p><p>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，满意度更高</p></blockquote><h4 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h4><p>指 进程/作业 <strong>处于等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。作业在外存中等待被调度，或内存中等待服务的过程。</p><p>对于<strong>进程</strong>来说，等待时间指进程建立后<strong>等待被服务的时间之和</strong>，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p><p>对于<strong>作业</strong>来说，不仅要考虑<strong>建立进程后的等待时间之和，还要加上作业在外存后备队列中的等待时间</strong></p><p>使用<strong>平均等待时间</strong>来评价整体性能</p><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><p>指用户<strong>提交请求</strong>到<strong>首次产生响应</strong>作用的时间</p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务(FCFS)"></a>先来先服务(FCFS)</h4><p>和队列的思想一样，不赘述</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102155839954.png" alt="image-20211102155839954"></p><h4 id="短作业有限-SJF"><a href="#短作业有限-SJF" class="headerlink" title="短作业有限(SJF)"></a>短作业有限(SJF)</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102160416491.png" alt="image-20211102160416491"></p><p>分为抢占式和非抢占式</p><p><strong>非抢占式</strong>：每次调度 选择 <strong>当前已到达</strong>且<strong>运行时间最短</strong>的作业/进程</p><p><strong>抢占式，最短剩余时间优先算法：</strong>每当有进程加入<strong>就绪队列，就绪队列改变时就需要调度</strong>。如果新到达的进程<strong>剩余时间</strong>比当前运行的进程剩余时间<strong>更短</strong>，则由新进程<strong>抢占处理机</strong>，当前运行进程重新回到就绪队列中。当一个<strong>进程完成时也需要调度</strong></p><blockquote><ol><li><p>如果题目<strong>未特别说明</strong>，所提到的“短作业/进程优先算法“ <strong>默认是非抢占式</strong></p></li><li><p>SJF调度算法的平均等待时间，平均周转时间最少。  <strong>这个说法是错误的。</strong></p><p>应加上条件 <strong>在所有进程同时可运行时</strong>，如果不加上这个条件，则应该说 ”<strong>抢占式的</strong>短作业/进程优先调度算法（<strong>最短剩余时间有限，SRNT算法</strong>）的平均等待时间，平均周转时间最少</p></li><li><p>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间</p></li><li><p>如果选择题中遇到“SJF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项 是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</p></li></ol></blockquote><h4 id="高响应比有限-HRRN"><a href="#高响应比有限-HRRN" class="headerlink" title="高响应比有限(HRRN)"></a>高响应比有限(HRRN)</h4><p>Highest Response Ratio Next</p><p><strong>非抢占式</strong>的调度算法，只有当前运行的进程<strong>主动放弃CPU时</strong>（正常/异常完成，或主动阻塞），才需要进行调度，调度时<strong>计算所有就绪进程的响应比，选响应比最高的进程</strong>来上处理机</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102164657031.png" alt="image-20211102164657031"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这三种一般适用于<strong>早期的批处理系统</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102170314398.png" alt="image-20211102170314398"></p><h4 id="时间片轮转-RR，Round-Robin"><a href="#时间片轮转-RR，Round-Robin" class="headerlink" title="时间片轮转(RR，Round-Robin)"></a>时间片轮转(RR，Round-Robin)</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102165413645.png" alt="image-20211102165413645"></p><p>轮流让就绪队列中的进程一次执行一个时间片（每次选择的都是排在就绪队列头的进程）</p><p>例如，时间片为2，有p1,p2,p3，分别要2，3，和5个时间片</p><p>其中p1先到，p1进行进入处理机，然后到p2，运行2个时间片出来，这时p3进入，则p2排到队尾。先进行p3的2个，再到p2。然后一直做p3。如果中间p3在p2的两个时间片执行玩还没进入，则还是会继续p2。</p><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102165702578.png" alt="image-20211102165702578"></p><p>也有抢占式和非抢占式</p><p>非抢占式：每次调度选择<strong>当前已到达</strong>且<strong>优先级最高</strong>的进程。当前<strong>进程主动放弃处理机时</strong>发生调度。</p><p>抢占式：每次调度时选择<strong>当前已到达</strong>且<strong>优先级最高</strong>的进程，当前进程<strong>主动放弃处理机时</strong>发生调度。另外，当<strong>就绪队列发生改变时</strong>也需要检查是否会发生抢占</p><blockquote><p>根据优先级是否可以动态改变，将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>两种。</p><p><strong>静态优先级：</strong>创建进程时确定，之后一直不变</p><p>动态优先级：创建进程时有一个初始值，之后会根据情况动态的调整优先级</p><p>通常：</p><p>系统进程优先级<strong>高于</strong>用户进程</p><p>前台进程<strong>高于</strong>后台进程</p><p>操作系统更<strong>偏好I/O型进程（或I/O繁忙形进程）</strong></p><p>与IO进程相对的是<strong>计算型进程（或CPU繁忙形进程）</strong></p><p>动态优先级算法应该什么时候调整</p><p>可以从追求公平、提升资源利用率等角度考虑 </p><p>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级 </p><p>如果某进程占用处理机运行了很长时间，则可适当降低其优先级 </p><p>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</p></blockquote><h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102170226755.png" alt="image-20211102170226755"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102170245652.png" alt="image-20211102170245652"></p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102170255999.png" alt="image-20211102170255999"></p><h2 id="进程同步-进程互斥"><a href="#进程同步-进程互斥" class="headerlink" title="进程同步-进程互斥"></a>进程同步-进程互斥</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102171435411.png" alt="image-20211102171435411"></p><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>前面学过进程异步性的特征。主要是无法预测。</p><p>进程同步：必须保证某一个指令在一个指令之前执行</p><p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某 些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互 合作</p><h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><p>进程的“并发” 需要 ”共享“ 的支持。各个并发执行的进程不可避免的需要共享一些系统资源（内存，打印机等）</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102171137312.png" alt="image-20211102171137312"></p><p>我们把<strong>一个时间段内只允许一个进程使用</strong>的资源称为<strong>临界资源</strong>。许多物理设备（比如摄像头、打印机）都 属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。 </p><p>对临界资源的访问，必须<strong>互斥</strong>地进行。互斥，亦称<strong>间接制约关系</strong>。<strong>进程互斥</strong>指当一个进程访问某临界资源 时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后， 另一个进程才能去访问临界资源。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211102171323803.png" alt="image-20211102171323803"></p><ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ol><h3 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103132018180.png" alt="image-20211103132018180"></p><h4 id="单标志位"><a href="#单标志位" class="headerlink" title="单标志位"></a>单标志位</h4><p>两个进程在<strong>访问完临界区后</strong>会把使用临界区的权限转交给另一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103130103977.png" alt="image-20211103130103977"></p><blockquote><p>turn 的初值为 0，即刚开始只允许 0 号进程进入临界区。 </p><p>若 P1 先上处理机运行，则会一直卡在 ⑤。直到 P1 的时间片用完，发生调度，切换 P0 上处理机运行。 </p><p>代码 ① 不会卡住 P0，P0 可以正常访问临界区，在 P0 访问临界区期间即时切换回 P1，P1依然会卡在 ⑤。 </p><p>只有 P0 在退出区将 turn 改为 1 后，P1才能进入临界区。</p></blockquote><p>该算法<strong>可以实现 “同一时刻最多允许一个进程访问临界区”</strong>。</p><blockquote><p>且如果有一种情况是，P0把turn弄为1，而P1不需要使用，就会一直占着资源不运行。P0需要运行也运行不了。</p></blockquote><p>因此<strong>单标志位</strong>，<strong>违背 “空闲让进” 原则</strong></p><h4 id="双标志先检查"><a href="#双标志先检查" class="headerlink" title="双标志先检查"></a>双标志先检查</h4><p>设置一个布尔型数组 flag[]，数组中各个元素用来<strong>标记各进程想进入临界区的意愿</strong>。flag[0]=true表示0号进程想进入临界区。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103130645885.png" alt="image-20211103130645885"></p><blockquote><p>p0判断p1是否运行，没运行就将自己设置为true</p><p>若按152637……的顺序执行，p0p1会同时访问临界区</p></blockquote><p>因此双标志先检查，<strong>违反 ”忙则等待“ 原则”</strong></p><p>原因在于，<strong>进入区</strong>的 “检查”和“上锁” <strong>两个处理不是一气呵成的</strong>。“检查” 后，“上锁”前可能发生进程切换。</p><h4 id="双标志后检查"><a href="#双标志后检查" class="headerlink" title="双标志后检查"></a>双标志后检查</h4><p>先检查法的改版。变成先 上锁 后 检查。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103131101507.png" alt="image-20211103131101507"></p><blockquote><p>1526…..的顺序执行，p0和p1都无法进入临界区。</p><p>因此，<strong>违背了 “空闲让进” 和 ”有限等待“ 原则</strong>，会因各进程都长期无法访问临界区而产生”<strong>饥饿</strong>“</p></blockquote><h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>结合双标志和单标志思想。如果双方都想进入临界区，可以尝试进行谦让，让另一个进程先运行</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103131436278.png" alt="image-20211103131436278"></p><blockquote><p>两个进程会优先给另一个进程表示为true，所以如果p0先给p1，那么p1又给p0，所以p0会先操作。</p></blockquote><p><strong>遵循了空闲让进，忙则等待，有限等待三个原则。</strong>但依然<strong>未遵循让权等待</strong>的原则</p><h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103132841054.png" alt="image-20211103132841054"></p><h4 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h4><p>利用 ”开/关中断指令“ 实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换。</p><p>优点：简单，高效</p><p>缺点：不适用于多处理机，只适用于操作系统内核进程，不适用于用户进程</p><h4 id="TestAndSet-TS指令-TSL指令"><a href="#TestAndSet-TS指令-TSL指令" class="headerlink" title="TestAndSet(TS指令/TSL指令)"></a>TestAndSet(TS指令/TSL指令)</h4><p>TSL指令<strong>是用硬件实现的</strong>，执行的过程不允许被中断，只能一气呵成。</p><blockquote><p>直接上锁并检查，一气呵成。结束才会开锁</p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103132527807.png" alt="image-20211103132527807"></p><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境 </p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p><h4 id="Swap指令-XCHG指令"><a href="#Swap指令-XCHG指令" class="headerlink" title="Swap指令(XCHG指令)"></a>Swap指令(XCHG指令)</h4><p>也叫Exchange指令</p><p><strong>硬件实现</strong>，执行的过程不允许被中断，只能一气呵成。</p><blockquote><p>逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变 量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程 对临界区上锁，则可跳出循环，进入临界区。</p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103132642254.png" alt="image-20211103132642254"></p><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境 </p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103140303294.png" alt="image-20211103140303294"></p><p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而方便的实现了进程互斥，进程同步。</p><p><strong>信号量</strong>其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来<strong>表示系统中某种资源的数量</strong>。比如 打印机，可以设置一个初值为1的信号量</p><p><strong>原语</strong>是一种特殊的程序段，其<strong>执行只能一气呵成，不可被中断</strong>。</p><p><strong>一对原语：wait(S)原语和signal(S)原语</strong>，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的<strong>信号量S</strong>其实就是函数调用时传入的一个参数</p><p>wait，signal原语<strong>简称 P，V操作</strong>。<strong>P(S), V(S)</strong></p><h4 id="整形信号量"><a href="#整形信号量" class="headerlink" title="整形信号量"></a>整形信号量</h4><p>用一个<strong>整数型的变量</strong>作为信号量，用来<strong>表示系统中某种资源的数量</strong>。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103135008401.png" alt="image-20211103135008401"></p><h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>用记录型数据结构表示的信号量</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103135105782.png" alt="image-20211103135105782"></p><p>这里<strong>value</strong>表示的<strong>某种资源的数目</strong>，*<em>process <em>L</em></em> 表示的是<strong>等待的队列</strong>。</p><p>对信号量的一个<strong>P操作</strong>表示对资源的一次使用。则Value–，如果 <strong>&lt;0时 则资源用完</strong>，此时<strong>block进行阻塞</strong>，等待被唤醒。当一个进程使用完资源之后 当前进程将Value++，<strong>判断是否小于等于0，如果满足条件则有进程等待使用资源</strong>。*<em>运行wakeup 从 <em>L中唤醒资源</em></em>。</p><h3 id="信号量机制实现进程互斥，进程同步"><a href="#信号量机制实现进程互斥，进程同步" class="headerlink" title="信号量机制实现进程互斥，进程同步"></a>信号量机制实现进程互斥，进程同步</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103141437716.png" alt="image-20211103141437716"></p><h4 id="进程互斥-1"><a href="#进程互斥-1" class="headerlink" title="进程互斥"></a>进程互斥</h4><p>**互斥信号量(mutex)**，当进入区P(mutex)，退出区V(mutex)</p><blockquote><p>对不同的临界资源用不同的互斥信号量</p><p>且PV的操作必须同时出现</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">p1()&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    P(mutex);</span><br><span class="line"><span class="comment">//  临界区代码</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p2()&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    P(mutex);</span><br><span class="line"><span class="comment">//  临界区代码</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进程同步-1"><a href="#进程同步-1" class="headerlink" title="进程同步"></a>进程同步</h4><p>思想类似，使用互斥信号量来进行同步</p><p>例如有两个进程p1,p2</p><p>p1的第三步执行完才进行p2的第一步代码。则只需将互斥信号量设置为从p1开始到p1的第三步代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">p1()&#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="comment">//1-3步</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    <span class="comment">//  临界区代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p2()&#123;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h4><p>与同步那个机制一样。先进行了某些操作才能进行下一步</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103141419445.png" alt="image-20211103141419445"></p><h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><h4 id="单生产与消费"><a href="#单生产与消费" class="headerlink" title="单生产与消费"></a>单生产与消费</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103143005066.png" alt="image-20211103143005066"></p><p>一组生产者和一组消费者。对缓冲区进行读写。其中必须是<strong>互斥操作</strong>，<strong>缓冲区未满—-&gt;生产区发数据，缓冲区非空—-&gt;消费者消费</strong></p><p>则设置标识符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mutex=<span class="number">1</span>; <span class="comment">//互斥信号量</span></span><br><span class="line">empty=n;  <span class="comment">//表示有多少个空的缓冲区可以放数据</span></span><br><span class="line">full=<span class="number">0</span>; <span class="comment">//表示其中有多少个数据</span></span><br><span class="line"></span><br><span class="line">producer()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        P(empty); <span class="comment">//empty-1</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">//加入数据</span></span><br><span class="line">        V(full); <span class="comment">//full+1</span></span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       </span><br><span class="line">        P(full); <span class="comment">//full-1</span></span><br><span class="line">         P(mutex);</span><br><span class="line">        <span class="comment">//取数据</span></span><br><span class="line">        V(empty); <span class="comment">//empty+1</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        <span class="comment">//使用数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里 上锁的P操作顺序不能颠倒，否则会导致死锁。  </p><p>假设进入生产者，先进行上锁，然后判读到 empty是0，则会跳到消费者的mutex，则判断是上锁状态，就会死锁。</p></blockquote><p>本质上也属于同步问题</p><h4 id="多生产消费者"><a href="#多生产消费者" class="headerlink" title="多生产消费者"></a>多生产消费者</h4><p>假设plate是缓冲区，但是只能每次存放一个数据。也就是如果有一个数据必须等待取走才能继续放。</p><p>其中consumer只能取producter的数据。同理2</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103144109435.png" alt="image-20211103144109435"></p><p><strong>当缓冲区为1时，可以不设置mutex互斥信号量</strong>。也可以实现此功能。</p><p><strong>当缓冲区为2时必须设置mutex，因为如果两个进程同时写一块缓冲区就会造成数据错误。</strong></p><h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><p>三个吸烟者进程，一个供应者进程</p><p>其中每次抽烟需要三个原材料，而他们每人只有其中一种。所以每次供应者会提供 <strong>一组材料</strong>供其使用，是谁的组合谁就取。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103144856860.png" alt="image-20211103144856860"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103145055424.png" alt="image-20211103145055424"></p><p>消费者取完之后进行 V(finish); 将缓冲区变空的信息发回供应者。实际上还是生产者消费者的问题。供应者对于三个消费者有三个offer，供应的那个就V哪个</p><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p>简单来说就是，一个缓冲区，写进程的时候必须上锁，而读进程对于读进程不上锁，对于写进程上锁。</p><ol><li>允许多个读者可以同时对文件执行读操作</li><li>只允许一个写者往文件中写信息</li><li>任一写者在完成操作之前不允许其他读者或写者工作</li><li>写者执行写操作前，应让已有的读者和写者全部退出</li></ol><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103153218838.png" alt="image-20211103153218838"></p><p><strong>其核心思想</strong>在于设置一个<strong>计数器count</strong>，用来记录当前正在访问共享文件的读进程数。可以用count的值来判断当前进入的进程是否第一个/最后一个读进程，做出不同的处理。</p><p>且需要对count的操作一气呵成，否则会导致错误。</p><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们只会思考和用餐，哲学家思考时，并不影响他人。只有当哲学家饥饿时，才视图拿起左右两根筷子（一根一根拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103160618597.png" alt="image-20211103160618597"></p><p>分析：</p><p>定义互斥信号量数组 chopstick[5]={1,1,1,1,1}。</p><p>如果他们同时都拿起左边的筷子，那么就会死锁。<strong>想办法避免死锁</strong></p><p>解决方法</p><ol><li><p>对哲学家进程施加一些限制条件，例如最多允许4个哲学家同时进餐，可以保证必有一个哲学家是拿到两个筷子</p></li><li><p>要求奇数号的哲学家先拿左边的筷子，然后再拿右边的筷子。而偶数号的相反。用这样的方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。避免了占有一只后等待另一个的情况。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103161127278.png" alt="image-20211103161127278"></p></li><li><p>仅当一个哲学家左右两只筷子都可用时才允许抓起筷子。</p><blockquote><p>这里如果有其中一个人在吃饭，则所有人会等待，即使左右两个筷子可以用，也不会拿起。</p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211103161245150.png" alt="image-20211103161245150"></p></li></ol><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108185053965.png" alt="image-20211108185053965"></p><p>上面我们知道，信号量机制如果运行前后顺序不对，就有可能死锁。引入管程</p><p>管程是一种特殊的软件模块，由以下部分组成</p><ol><li>局部于管程的<strong>共享数据结构</strong>说明</li><li>对该数据结构进行操作的<strong>一组过程（函数）</strong></li><li>对局部于管程的共享数据设置初始值的语句</li></ol><p>基本特征</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程，访问共享数据</li><li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong></li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108185951712.png" alt="image-20211108185951712"></p><p>死锁，饥饿，死循环的区别</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108185134939.png" alt="image-20211108185134939"></p><p><strong>死锁产生的必要条件</strong></p><p>产生死锁需要满足以下的四个条件，有一个条件不成立，死锁就不会发生</p><ol><li><strong>互斥条件：</strong>只有对必须互斥使用的资源的争抢才会导致死锁。</li><li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，<strong>不能由其他进程强行夺走</strong>，只能主动释放</li><li><strong>请求和保持条件：</strong>进程<strong>已经保持了至少一个资源</strong>，但又提出了新的资源<strong>请求</strong>，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己拥有的资源<strong>保持</strong>不放</li><li><strong>循环等待条件：</strong>存在一种进程<strong>资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求</li></ol><blockquote><p><strong>发生死锁时一定有循环等待，但是发生循环等待时，不一定有死锁</strong></p></blockquote><p>总结来说：对不可剥夺资源的不合理分配，就可能发生死锁</p><h3 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a><strong>处理策略</strong></h3><ul><li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个</li><li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁。（银行家算法）</li><li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测死锁的发生，然后采取某种措施解除死锁</li></ul><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108190139279.png" alt="image-20211108190139279"></p><p><strong>破坏互斥条件</strong></p><p>把只能互斥使用的资源改造为允许共享使用。例如<strong>SPOOLing技术</strong>。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。</p><p>例如这里 加了一个输出进程</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108190334566.png" alt="image-20211108190334566"></p><p><strong>缺点：</strong>并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方必须<strong>保护</strong>这种互斥性。因此，<strong>很多时候无法破坏互斥条件</strong></p><p><strong>破坏不剥夺条件</strong></p><ul><li>当某个进程请求心的资源得不到满足，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件</li><li>当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（如：剥夺调度方式，将处理机资源强行剥夺给更高优先级的进程使用）</li></ul><p>缺点：</p><p>实现起来复杂，释放已获得的资源可能造成前一阶段工作的失效。因此这种方式一般只适用于易保存和恢复状态的资源（如CPU）。</p><p>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</p><p>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃。以后再申请，如果一直是这种情况就会导致饥饿</p><p><strong>破坏请求和保持条件</strong></p><p>采用<strong>静态分配方法</strong>，即进程在运行前 一次性申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归他所有，该进程就不会再请求别的任何资源了。</p><p>缺点：有些资源可能只需要很短的时间，因此如果进程的整个运行期间都一直保持这所有资源，就会造成严重的资源浪费，<strong>资源利用率极低</strong>。另外，该策略也有<strong>可能导致某些进程饥饿</strong></p><p><strong>破坏循环等待条件</strong></p><p>采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号，规定每个进程<strong>必须按编号递增的顺序请求资源</strong>，同类资源（即编号相同的资源）一次申请完</p><p>原理：一个进程只有先持有小编好的资源时，才有资格申请更大编号的资源。（1-10）先有小编号才能申请大编号。</p><p>缺点：</p><ul><li>不方便增加新的设备，因为可能需要重新分配所有的编号</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li><li>必须按规定次序申请资源，用户编程麻烦</li></ul><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p><strong>安全序列</strong></p><p>指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要找出一个安全序列，系统就是<strong>安全状态</strong>。<strong>安全序列可能有多个</strong></p><p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态。</strong>意味着之后<strong>可能</strong>所有进程都无法顺利的执行下去。但如果有进程提前归还了一些资源，那<strong>系统也有可能重新回到安全状态</strong>。</p><p>如果系统处于<strong>安全状态</strong>，就<strong>一定不会</strong>发生<strong>死锁</strong>，如果系统进入<strong>不安全状态</strong>就有<strong>可能会</strong>发生死锁。（死锁一定不安全状态，不安全状态不一定死锁</p><p>可以在<strong>资源分配之前预先判断这次分配是否会导致系统进入不安全状态</strong>，以此决定是否答应资源分配请求。也就是<strong>银行家算法</strong>的核心思想</p><h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a><strong>银行家算法</strong></h5><p><strong>核心思想</strong>：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108192644526.png" alt="image-20211108192644526"></p><p>按照还需要的进程数，给其进程。然后让他们运行完释放进程。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108193107261.png" alt="image-20211108193107261"></p><h4 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108194443155.png" alt="image-20211108194443155"></p><h5 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h5><p><strong>必须</strong></p><ol><li>用<strong>某种数据结构</strong>来保存资源的请求和分配信息</li><li>提供<strong>一种算法</strong>，利用上述信息来检测系统是否已进入死锁状态</li></ol><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108193406274.png" alt="image-20211108193406274"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211108193601693.png" alt="image-20211108193601693"></p><p><strong>能消除所有边</strong>，就称这个图是<strong>可完全简化</strong>。此时一定<strong>没有发生死锁</strong>。</p><p>如果<strong>不能消除所有边</strong>，那么此时就是<strong>发生了死锁</strong>。<strong>最终还连着边的那些进程就是处于死锁状态的进程</strong></p><p><strong>检测算法</strong></p><p>用上图举例，蓝色的是请求边，也就是说还需要一个资源。绿色是已经给过去的资源。则R1已经给完了资源，P1还需要一个资源，R2正好有。那么先给P1则P1会运行完成，并释放资源，然后给P2也可以运行完成。</p><p><strong>死锁的解除</strong></p><p>一旦检测出死锁的发生，就应该立即解除死锁</p><blockquote><p>并不是系统中所有的进程都是死锁状态，用死锁检测算法<strong>化简资源分配图后，还连着边的那些进程就是死锁进程</strong></p></blockquote><p>解除死锁主要方法</p><ul><li>资源剥夺法：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应繁殖被挂起的进程长时间得不到资源而饥饿</li><li><strong>撤销进程法（终止进程法）：</strong>强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优先是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束，一旦被终止会功亏一篑。</li><li><strong>进程回退法：</strong>让一个或多个死锁进程回退到足以避免死锁的地步。要求系统要记录进程的历史信息，设置还原点</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-第一章</title>
      <link href="2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><p><strong>操作系统（Operating System OS)**是指控制和</strong>管理<strong>整个计算机系统的</strong>硬件和软件<strong>资源，并合理地组织调度计算机的工作和资源的分配；以</strong>提供给用户和其他软件方便的接口和环境<strong>；是计算机系统中最基本的</strong>系统软件**</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030135027449.png" alt="image-20211030135027449"></p><blockquote><p>执行一个程序时，需要先将其从外存放到内存中</p></blockquote><p><strong>联机命令接口=交互式命令接口</strong>，例如win里面的cmd（用户发一个命令，系统做一个）</p><p><strong>脱机命令接口=批处理命令接口</strong>（用户说一堆系统做一堆）</p><p>程序接口：可以在程序中进行<strong>系统调用（广义指令）</strong>来使用接口。普通用户不能直接使用程序接口，只能通过程序代码<strong>间接</strong>使用。例如使用print调用程序接口。</p><p>操作系统实现<strong>对硬件机器的拓展</strong>，没有任何软件的称为<strong>裸机</strong>，<strong>扩充机器（虚拟机）</strong></p><h2 id="四个特征"><a href="#四个特征" class="headerlink" title="四个特征"></a>四个特征</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h3><p>指两个或多个事件在同一时间间隔内发生。这些事件<strong>是宏观上同时发生的</strong>，但<strong>微观上是交替发生的</strong>（也就是CPU是交替进行两个多个任务）。<strong>操作系统和程序并发是一起诞生的</strong></p><p><strong>并行：指两个或多个时间同一时刻发生</strong></p><p><strong>重点</strong></p><p><strong>单核CPU</strong>同一时刻只能执行一个程序，各个程序只能并发的执行</p><p><strong>多核CPU</strong>同一时刻可以执行<strong>多个程序</strong>，多个程序可以<strong>并行</strong>执行</p><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a><strong>共享</strong></h3><p>资源共享，指系统中的资源可供内存中多个并发执行的进程共同使用</p><p>两种共享方式</p><ul><li><p>互斥共享方式</p><p>系统中的资源虽然可以给多个进程使用。但<strong>一个时间内只允许一个进程访问该资源</strong>（摄像头只能一个进程使用）</p></li><li><p>同时共享方式</p><p>系统中的资源，允许一个时间段内由多个进程 “<strong>同时</strong>“ 对它们进行访问（两个不同文件，可以有两个程序进行分别使用）</p></li></ul><blockquote><p>如果没有并发，那么共享性也不存在。如果失去共享性，并发不能同时使用文件，也就没有共享性</p></blockquote><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a><strong>虚拟</strong></h3><p>把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，逻辑上对应物（后者）是用户感受到的</p><p>一个程序<strong>需要放入内存</strong>并分配CPU才能执行。但是如果电脑只有4GB，一个游戏要4GB，但是其他的应用也要内存。这时候就会用到 <strong>虚拟存储器基础</strong>实际只有4GB但是用户看来大于4GB。同样的也有虚拟处理器技术</p><ul><li>空分复用技术（虚拟存储器技术）</li><li>时分复用技术（虚拟处理器）</li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a><strong>异步</strong></h3><p>这里的异步和程序里面的异步有些不同。</p><p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的。而是走走停停，以不可预知的速度前进。 <strong>只有系统拥有并发性，才有可能导致异步性</strong></p><p>例如：两道并发执行的程序，CPU是一边执行一会，交替运行</p><h2 id="发展与分类"><a href="#发展与分类" class="headerlink" title="发展与分类"></a>发展与分类</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030143409272.png" alt="image-20211030143409272"></p><p><strong>手工操作阶段</strong></p><p>缺点：用户独占全机，人机速度矛盾导致资源利用率低。</p><p><strong>批处理阶段–单道批处理系统</strong></p><p>引入<strong>脱机输入输出技术</strong>（外围机+磁带），并由<strong>监督程序</strong>负责控制作业的输入输出</p><p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率提升</p><p>缺点:<strong>内存中仅能有一道程序运行，</strong>只有该程序运行结束之后才能调入下一道程序。<strong>cpu有大量时间是在空闲等待I/O完成</strong>。资源利用率低</p><p><strong>批处理阶段–多道批处理系统</strong></p><p>每次往内存中读入多道程序，操作系统诞生，用于支持多道程序并发运行</p><p>优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源。<strong>资源利用率大幅度提升</strong>。CPU和其他资源更能保持 ”忙碌“状态，系统吞吐量大</p><p>缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</p><p><strong>分时操作系统</strong></p><p>计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。</p><p>优点：用户请求可以被即时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p><p>要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户作业服务一个时间片，不区分任务的紧急性。</p><p><strong>实时操作系统</strong></p><p>优点：能够优先响应一些紧急任务，紧急任务不需排队</p><p>实时操作系统控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是及时性和可靠性</p><ul><li>硬实时操作系统：必须绝对严格的规定时间内完成处理（自动驾驶，导弹控制..)</li><li>软实时操作系统：能接收偶尔违反时间固定（一些网页的更新）</li></ul><p><strong>其他操作系统</strong></p><p>网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传 送等功能，<strong>实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信</strong>。（如：Windows NT 就是 一种典型的网络操作系统，网站服务器就可以使用</p><p>分布式操作系统：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由他们并行、协同完成这个任务</strong></p><p>个人计算机操作系统，xp win10…</p><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030150414578.png" alt="image-20211030150414578"></p><h3 id="两种程序"><a href="#两种程序" class="headerlink" title="两种程序"></a><strong>两种程序</strong></h3><ul><li>内核程序：很多内核程序组成了 ”<strong>操作系统内核</strong>“，<strong>内核</strong>是操作系统最重要最核心的部分，也是<strong>最接近硬件的部分</strong>。可以说，操作系统只要有内核就够了，且操作系统的功能都不一定在内核中（如GUI）</li><li>应用程序：普通程序员写的程序就是</li></ul><h3 id="两种指令"><a href="#两种指令" class="headerlink" title="两种指令"></a>两种指令</h3><p>CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU可以执行指令前就能判断其类型</p><ul><li>应用程序只能使用<strong>非特权指令</strong>（加法指令，减法指令…)</li><li>特权指令：如内存清零指令，影响重大，只允许内核使用</li></ul><h3 id="两种状态"><a href="#两种状态" class="headerlink" title="两种状态"></a>两种状态</h3><ul><li>内核态：在内核态时，说明<strong>正在运行的是内核程序</strong>，此时<strong>可以执行特权指令</strong></li><li>用户态：在用户态时，说明<strong>正在运行的是应用程序</strong>，此时<strong>只能执行非特权指令</strong></li></ul><blockquote><p>CPU中有一个寄存器是 程序状态字寄存器（PSW），其中有一个二进制位，1表示”内核态“ 0表示”用户态” 也可能相反</p></blockquote><p><strong>别名：内核态=核心态=管态</strong>，<strong>用户态=目态</strong></p><blockquote><p>例如</p><p>一个应用程序正常运行，中间有条命令是使用特权指令，但是自己是处于用户态，则会引发一个<strong>中断信号</strong>（<strong>CPU检测到中断信号后</strong>会立即<strong>变为 核心态</strong>，并停止运行当前的应用程序，转而运行处理中断信号的内核程序），“中断” 使操作系统再次夺回CPU的控制权，操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序</p></blockquote><h4 id="相互切换状态"><a href="#相互切换状态" class="headerlink" title="相互切换状态"></a>相互切换状态</h4><p><strong>内核态—&gt;用户态</strong>：执行一条<strong>特权指令–修改psw</strong>的标志位为用户态，这个动作意味着操作系统主动让出CPU使用权</p><p><strong>用户态—&gt;内核态:**由“</strong>中断<strong>“引发，</strong>硬件自动完成变态过程**，触发中断信号意味着操作系统将强行夺回CPU的控制权。</p><blockquote><p><strong>但凡需要操作系统介入的地方，都会触发中断信号</strong></p></blockquote><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>中断 特指狭义的中断，即外中断。   内中断一般称为异常</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030151453255.png" alt="image-20211030151453255"></p><p>”中断“ 是让<strong>操作系统内核夺回CPU使用权</strong>的唯一途径</p><ul><li><p>内中断：与当前执行的指令<strong>有关</strong>，中断信号源于CPU<strong>内部</strong></p><p>例如在用户态下执行特权指令..</p><p>或者有时候应用程序想请求操作系统内核的服务，此时会执行<strong>一条特殊的指令–陷入指令</strong>，该指令会引发一个内部中断信号</p><blockquote><p>陷入指令：意味着应用程序主动的将CPU控制权还给操作系统内核，系统调用就是通过陷入指令完成的</p></blockquote></li><li><p>外中断：与当前执行的指令<strong>无关</strong>，中断信号源于CPU<strong>外部</strong></p><p><strong>每一条指令执行结束时</strong>，CPU都会例行检查是否有外中断信号</p><p>例如 时钟中断—由时钟部件发出的中断信号，还有IO的中断信号</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030151207293.png" alt="image-20211030151207293"></p></li></ul><p><strong>中断机制基本原理</strong></p><p><strong>不同的中断信号，需要不同的中断处理程序来处理</strong>。当CPU检测到中断信号后，会根据中断信号的类型去查询 ”中断向量表“ ，以此来找到相应的中断处理程序在内存中存放位置。（计算机组成原理有详细描述）</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030151628002.png"></p><h2 id="系统调用（程序接口）"><a href="#系统调用（程序接口）" class="headerlink" title="系统调用（程序接口）"></a>系统调用（程序接口）</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030153350472.png" alt="image-20211030153350472"></p><p>操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求活的操作系统内核的服务</strong></p><p>例如 利用程序创建一个新文件，就要用到系统调用。但是例如C里面的取绝对值，不是系统调用，是库函数</p><p>应用程序通过<strong>系统调用</strong>请求操作系统的服务。系统中的各种共享资源都由操作系统内核同一管理，因此<strong>凡事与共享资源有关的操作（如存储分配，IO等），都必须通过系统调用的方式向操作系统内核提出服务请求</strong>，由操作系统内核代为完成。这样<strong>可以保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</p><p>按功能分类</p><ul><li>设备管理：完成设备的 请求/释放/启动等功能</li><li>文件管理：完成文件的 读写/创建/删除等</li><li>进程控制：完成进程的 创建/撤销/阻塞/唤醒等</li><li>进程通信：完成进程之间的 消息传递/信号传递等</li><li>内存管理：完成内存的 分配/回收 等</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030153318656.png" alt="image-20211030153318656"></p><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030153819731.png" alt="image-20211030153819731"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030153649035.png" alt="image-20211030153649035"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211030153712181.png" alt="image-20211030153712181"></p><blockquote><p><strong>变态的过程是有成本的</strong>，要消耗不少时间，<strong>频繁的变态会降低系统性能</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-第七章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I/O系统"></a>I/O系统</h1><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027160249052.png" alt="image-20211027160249052"></p><h3 id="CPU演变过程"><a href="#CPU演变过程" class="headerlink" title="CPU演变过程"></a>CPU演变过程</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027160354207.png" alt="image-20211027160354207"></p><h3 id="IO系统基本组成"><a href="#IO系统基本组成" class="headerlink" title="IO系统基本组成"></a>IO系统基本组成</h3><p><strong>IO软件</strong>：包括驱动程序，用户程序，管理程序，升级补丁等</p><p>通常采用IO指令和通道指令实现CPU和IO设备的信息交换</p><ul><li><p>IO指令</p><table><thead><tr><th>操作码</th><th>命令码</th><th>设备码</th></tr></thead></table><p>操作码识别IO指令，命令码：做什么操作。设备码：对那个设备进行操作</p></li><li><p>通道指令：通道自身的指令</p><p>指出数据的首地址，传送字数，操作命令，通道指令放在主存中，由CPU执行启动IO设备的指令，由通达代替CPU对IO设备进行管理</p></li></ul><p><strong>IO硬件</strong>：包括外部设备，设备控制器和接口，IO总线等</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027160737220.png" alt="image-20211027160737220"></p><h3 id="IO方式简介"><a href="#IO方式简介" class="headerlink" title="IO方式简介"></a>IO方式简介</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027161017484.png" alt="image-20211027161017484"></p><h2 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h2><p><strong>输入设备</strong></p><p>键盘的输入：查出按下的是哪个键，将该键翻译成能被主机接收的编码，如ASCII码，将编码传送给主机</p><p>鼠标（机械式，光电式）</p><p><strong>输出设备</strong></p><p>阴极射线管（CRT）显示器</p><ul><li><p>字符显示器：显示字符的方法以点阵为基础。*<em>点阵是m</em>n的点组成阵列<strong>，</strong>将点阵存入由ROM构成的字符发生器。**在CRTj进行进行光栅扫描的过程中，在字符发生器中依次读出某个字符的点阵，按照点阵中0和1代码不同控制扫描电子束的开或管，从而在屏幕上显示字符。</p><p>对于每个字符窗口，所需显示<strong>字符的ASCII代码被存放在视频存储器VRAM中</strong>，以备刷新</p></li><li><p>图形显示器：显示矢量的图形，例如心电图</p></li><li><p>图像显示器</p></li></ul><p>液晶显示器（LCD）</p><p>LED（发光二极管）显示器</p><p><strong>参数</strong></p><ul><li>屏幕大小：以对角线长度表示，常用的有12-29英寸</li><li>分辨率：所能表示的像素个数，屏幕上的每一个光点就是一个像素，在彩色显示器中则表现为颜色的不同，灰度级越多，图像层次越清楚逼真，典型的有8位（256），16位等。<strong>n位可以表示2^n次方不同的亮度或颜色</strong></li><li>刷新：光点只能保持极短的时间便会消失，为此必须在光点消失之前再重新扫描显示一遍，这个过程称为刷新。</li><li>刷新频率：单位时间内扫描整个屏幕内容的次数，通常为60-120Hz</li><li>**显示存储器(VRAM)**：刷新存储器，提高刷新图像的信号，把每一帧图像信息存储在刷新存储器中。存储容量由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大。</li></ul><p><strong>VRAM容量 = 分辨率 × 灰度级位数</strong></p><p><strong>VRAM带宽 = 分辨率 × 灰度级位数 × 帧频</strong></p><p><strong>打印机</strong></p><p>按印字原理不同分为</p><ul><li>击打式打印机：利用机械动作使印字机构与色带和纸相撞而打印字符<ul><li>优：设备成本低，印字质量好</li><li>缺：噪声大，速度慢</li></ul></li><li>非击打式打印机：采用电，磁，光，喷墨等物理，化学方法来印刷字符<ul><li>优：速度快，噪声小</li><li>缺：成本高</li></ul></li></ul><p>按工作方式不同分为</p><ul><li><p>串行打印机：逐字打印，速度慢</p></li><li><p>行式打印机：逐行打印，速度快</p></li><li><p>针式打印机</p></li><li><p>喷墨打印机</p></li><li><p>激光打印机</p></li></ul><h2 id="外存储器"><a href="#外存储器" class="headerlink" title="外存储器"></a>外存储器</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027175100104.png" alt="image-20211027175100104"></p><p>又称辅助存储器，目前主要是磁表面存储器，是指把某些磁性材料薄薄的涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器，磁带存储器和磁鼓存储器均属于磁表面存储器</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027172018115.png" alt="image-20211027172018115"></p><h3 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h3><p>由磁盘驱动器，磁盘控制器和盘片组成</p><p>磁盘驱动器：核心部件是磁头组件和盘片组件，温彻斯特盘是一种可移动头固定盘片的硬盘存储器。是硬盘存储器和主机的接口，主流的标准有IDE、SCSI、SATA等。</p><p>存储区域：一块硬盘含有若干记录面，每个记录面划分为若干条磁道，而每条磁道又划分为若干扇区，扇区（也称块）是磁盘读写的最小单位，也就是磁盘按块存取</p><ul><li><strong>磁头数（Heads)：</strong>即记录面数，表示硬盘总共有多少个磁头，磁头用于读取/写入盘片上记录面的信息，一个记录面对应一个磁头。</li><li><strong>柱面数（Cylinders）</strong>：表示硬盘每一面盘片上有多少条磁道。在一个盘组中，不同记录面的相同编号（位置）的诸磁道构成一个圆柱面。</li><li><strong>扇区数（Sectors）</strong> 表示每一条磁道上有多少个扇区。（橙色线指向的位置是扇区）</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027172401383.png" alt="image-20211027172401383"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027172621486.png" alt="image-20211027172621486"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027172647355.png" alt="image-20211027172647355"></p><h3 id="磁盘的性能指标"><a href="#磁盘的性能指标" class="headerlink" title="磁盘的性能指标"></a>磁盘的性能指标</h3><ol><li><p>磁盘的容量：一个磁盘所能存储的字节总数称为磁盘容量。有格式化和非格式化的分别</p><ol><li>格式化容量：按照某种特定的记录格式，所能存储信息的总量</li><li>非格式化容量：磁记录表面可以利用的磁化单元总数。</li></ol></li><li><p>记录密度：记录密度指盘片单位面积上记录的二进制的信息量，通常以道密度，位密度，面密度表示（且不论长短，磁道的记录信息量是相等的）</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027173532077.png" alt="image-20211027173532077"></p><ol><li>道密度：沿磁盘半径方向单位长度上的磁道数</li><li>位密度：磁道单位长度上能记录的二进制代码位数</li><li>面密度：位密度和道密度的乘积</li></ol></li><li><p>平均存取时间 =  寻道时间（磁头移动到目的磁道）+ 旋转延迟时间（磁头定位到所在扇区）+传输时间（传输数据所花费的时间）</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027173354184.png" alt="image-20211027173354184"></p></li><li><p>数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率</p><p>假设磁盘转数为<em>r</em>（转/秒），每条磁道容量为<em>N</em>个字节，则数据传输率为<em>D</em>r=<em>rN</em></p></li></ol><h3 id="磁盘地址"><a href="#磁盘地址" class="headerlink" title="磁盘地址"></a>磁盘地址</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027173938415.png" alt="image-20211027173938415"></p><p>若系统中有4个驱动器，每个驱动器带一个磁盘，每个磁盘256个磁道，16个盘面，每个盘面划分为 16个扇区。</p><p>求需要多少位二进制</p><p>4个驱动器要2^2次方，256个磁道 2^8次方,后面也类似。则需要18个二进制位</p><h3 id="磁盘的工作过程"><a href="#磁盘的工作过程" class="headerlink" title="磁盘的工作过程"></a>磁盘的工作过程</h3><p>硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。</p><p>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。</p><h3 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h3><p>RAID（廉价冗余磁盘阵列）是将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。</p><ul><li><p>RAID0：无冗余和无校验的磁盘阵列。 </p></li><li><p>RAID1：镜像磁盘阵列。 </p></li><li><p>RAID2：采用纠错的海明码的磁盘阵列。 </p></li><li><p>RAID3：位交叉奇偶校验的磁盘阵列。 </p></li><li><p>RAID4：块交叉奇偶校验的磁盘阵列。 </p></li><li><p>RAID5：无独立校验的奇偶校验磁盘阵列</p></li></ul><p>越往下可靠性越强。</p><p>RAID通过同时使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞</p><p>吐量；通过镜像功能，可以提高安全可靠性；通过数据校验，可以提供容错能力。</p><h3 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027175019047.png" alt="image-20211027175019047"></p><h3 id="固态"><a href="#固态" class="headerlink" title="固态"></a>固态</h3><p>在微小型高档笔记本电脑中，采用高性能Flash Memory作为硬盘来记录数据，这种“硬盘”称固态硬盘。</p><p>固态硬盘除了需要Flash Memory外，还需要其他硬件和软件的支持。</p><p>注：闪存(Flash Memory)是在E2PROM的基础上发展起来的，本质上是只读存储器。</p><h2 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027180638381.png" alt="image-20211027180638381"></p><p>主机和外设之间的交接j界面，通过接口可以实现主机和外设之间的信息交换</p><p>接口的功能(具体操作) </p><ol><li><p>设备选址 </p></li><li><p>传送命令 </p></li><li><p>传送数据 </p></li><li><p>反映I/O设备的工作状态</p></li></ol><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027180328676.png" alt="image-20211027180328676"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027180452317.png" alt="image-20211027180452317"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027180523962.png" alt="image-20211027180523962"></p><h3 id="IO接口的类型"><a href="#IO接口的类型" class="headerlink" title="IO接口的类型"></a>IO接口的类型</h3><p>按数据传送方式可分为</p><ul><li><p><strong>并行接口</strong>：一个字节或一个字所有位同时传送。</p></li><li><p><strong>串行接口</strong>：一位一位地传送。</p></li></ul><blockquote><p>注：这里所说的数据传送方式指的是外设和接口一侧的传送方式，而在主机和接口一侧，数据总是并行传送的。接口要完成数据格式转换。</p></blockquote><p>按主机访问I/O设备的控制方式可分为</p><ul><li><p><strong>程序查询接口</strong></p></li><li><p><strong>中断接口</strong> </p></li><li><p><strong>DMA接口</strong></p></li></ul><p>按功能选择的灵活性可分为</p><ul><li><p><strong>可编程接口</strong></p></li><li><p><strong>不可编程接口</strong></p></li></ul><h2 id="IO方式"><a href="#IO方式" class="headerlink" title="IO方式"></a>IO方式</h2><h3 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h3><p>上面有一张这样差不多的图，唯一不同的是程序查询方式那里，这里分成两个阶段了。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027180938506.png" alt="image-20211027180938506"></p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027181026455.png" alt="image-20211027181026455"></p><p><strong>逻辑图</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027181241615.png" alt="image-20211027181241615"></p><p><strong>例题</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027181351714.png" alt="image-20211027181351714"></p><blockquote><p><strong>这里32也可以改为 32/8b=4B</strong></p></blockquote><p><strong>独占查询</strong>：CPU 100%的时间都在查询IO状态，完全串行</p><p><strong>定时查询：</strong>保证数据不丢失的情况下，每隔一段时间去查询IO状态，查询的间隔内CPU可以执行其他程序。</p><h3 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028142202469.png" alt="image-20211028142202469"></p><p>基本概念：CPU在执行现有程序时，有某些异常请求或特殊请求需要进行处理。CPU暂时处理中断请求，执行完成后。再回到原来执行的断点，继续执行。</p><p>工作流程</p><ol><li><p>中断请求</p><p>中断源向CPU发出中断请求</p></li><li><p>中断响应</p><p>响应中断的条件</p><p>中断判优：多个中断源同时请求</p></li><li><p>中断处理</p><p>中断隐指令，中断服务程序</p></li></ol><p>中断请求分类</p><ul><li>内中断（内部异常）（信号来源：CPU内部）<ul><li>陷阱，陷入（trap 指令中断）（有意为之的异常，系统调用）</li><li>故障（fault   硬件故障）（由错误条件引起的，可能被故障处理程序修复）</li><li>终止（abort  软件中断）(不可恢复的致命错误造成的结果，终止处理程序不再将控制返回给引发终止的应用)</li></ul></li><li>外中断（信号来源：CPU外部）<ul><li>I/O中断请求</li><li>人工干预</li></ul></li></ul><p>非屏蔽中断：“关中断” 时也会响应（标志位 IF=0)</p><p>屏蔽中断：“关中断” 时 不会被响应</p><blockquote><p>硬件故障中断属于最高级，其次是软件中断</p><p>非屏蔽中断优于可屏蔽中断</p><p>DMA请求优于IO设备传送的中断请求</p><p>高速设备优于低速设备</p><p>输入设备优于输出设备</p><p>实时设备优于普通设备</p></blockquote><h4 id="中断请求标记"><a href="#中断请求标记" class="headerlink" title="中断请求标记"></a>中断请求标记</h4><p>每个中断源向CPU发出中断请求的时间是随机的。为了记录中断事件并区分不同的中断源，中断系统需对每个中断源设置<strong>中断请求标记触发器INTR</strong>，当状态为1时，表示有中断源请求</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028123820739.png" alt="image-20211028123820739"></p><p>对于<strong>外中断</strong>，CPU是在<strong>每条指令执行阶段结束前</strong>向接口<strong>发出中断查询信号</strong>，以获取IO的中断请求，也就是说<strong>CPU响应中断的时间</strong>是在每条<strong>指令执行阶段的结束时刻</strong></p><p>CPU响应中断必须满足以下3个条件：</p><ol><li>中断源有中断请求</li><li>CPU允许中断   即开中断</li><li>一条指令执行完毕，且没有更紧迫的任务</li></ol><h4 id="中断判优"><a href="#中断判优" class="headerlink" title="中断判优"></a>中断判优</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028135555822.png" alt="image-20211028135555822"></p><p>图中可知，就算是全1，但也是最高优先级先使用</p><p>处理过程</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028135838864.png" alt="image-20211028135838864"></p><p>中断服务程序：</p><ol><li><p><strong>保护现场：</strong></p><ol><li>保存程序断点（PC），由中断隐指令完成</li><li>保存通用寄存器和状态寄存器的内容，由中断服务程序完成</li></ol></li><li><p><strong>中断服务（设备服务）</strong></p><p>主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲存储器中</p></li><li><p><strong>恢复现场</strong></p><p>通过出栈指令或取数指令把之前保存的信息送回寄存器中</p></li><li><p><strong>中断返回</strong></p><p>通过中断返回指令回到原程序断点处</p></li></ol><p>在运行中断程序要做的东西之前，需要进行中断隐指令的任务</p><ol><li><strong>关中断</strong>。在中断服务中，为了保护现场（CPU主要寄存器中的内容）期间不被新的中断所大段，必须关中断，从而保证被中断的程序在中断服务程序执行完毕之后能接着正确的执行下去</li><li><strong>保存断点</strong>。为了保证在中断服务程序执行完毕后能正确的返回到原来的程序，必须将原来程序的断点（即程序计数器PC的内容）保存起来，可以引入堆栈，也可以存入指定单元</li><li><strong>引入中断服务程序</strong>。引出中断服务程序的实质就是取出中断服务程序的入口地址并传送给程序计数器（PC）</li></ol><blockquote><p>通过100…..0的中断信号，中断向量地址形成部件  计算出向量地址，找到响应的位置</p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028140502486.png" alt="image-20211028140502486"></p><p><strong>中断处理过程</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028140944281.png" alt="image-20211028140944281"></p><h4 id="多重中断"><a href="#多重中断" class="headerlink" title="多重中断"></a>多重中断</h4><p>单重中断：执行中断服务程序时不响应新的中断请求</p><p>多重中断：中断嵌套，执行中断服务程序时可响应新的中断请求（套娃）</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028141043439.png" alt="image-20211028141043439"></p><h5 id="单重与多重流程对比"><a href="#单重与多重流程对比" class="headerlink" title="单重与多重流程对比"></a>单重与多重流程对比</h5><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028141422668.png" alt="image-20211028141422668"></p><h5 id="中断屏蔽技术"><a href="#中断屏蔽技术" class="headerlink" title="中断屏蔽技术"></a>中断屏蔽技术</h5><ol><li>在中断服务程序中提前设备开中断命令</li><li>优先级别高的中断源有权中断优先级别低的中断源</li></ol><p>在原来的基础上，每个位置多加了个信号（屏蔽触发器）。</p><p>1表示屏蔽该中断源的请求，0表示可以正常申请。所有屏蔽触发器组合在一起，构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028141719091.png" alt="image-20211028141719091"></p><p>屏蔽字设置规律</p><ol><li>一般用’1’ 表示屏蔽，0表示正常申请</li><li>每个中断源对应一个屏蔽字（在处理该中断源的中断服务程序时，屏蔽寄存器中的内容为该中断源对应的屏蔽字）</li><li>屏蔽字中 ‘1’越多，优先级越高。每个屏蔽字中至少有一个 ‘1’（屏蔽自身的中断）</li></ol><p><strong>例题</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028142145789.png" alt="image-20211028142145789"></p><p><strong>例题</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028142709112.png" alt="image-20211028142709112"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028142728133.png" alt="image-20211028142728133"></p><h3 id="程序中断作用"><a href="#程序中断作用" class="headerlink" title="程序中断作用"></a>程序中断作用</h3><p>程序中断的作用如下：</p><p>① 实现CPU与I/O设备的并行工作。</p><p>② 处理硬件故障和软件错误。</p><p>③ 实现人机交互，用户干预机器需要用到中断系统。</p><p>④ 实现多道程序、分时操作，多道程序的切换需借助于中断系统。</p><p>⑤ 实时处理需要借助中断系统来实现快速响应。</p><p>⑥ 实现应用程序和操作系统（管态程序）的切换，称为“软中断”。</p><p>⑦ 多处理器系统中各处理器之间的信息交流和任务切换。</p><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028145313762.png" alt="image-20211028145313762"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028143247832.png" alt="image-20211028143247832"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028143303469.png" alt="image-20211028143303469"></p><p>DMA方式中当I/O设备需要进行数据传送时，通过DMA控制器（DMA接口）向CPU提出DMA传送请求，CPU响应之后将让出系统总线，由DMA控制器接管总线进行数据传送。主要功能是</p><ul><li>传送前<ol><li>接收外设发出的DMA请求，并向CPU发出总线请求</li><li>CPU响应此总线请求，发出总线响应信号，接管总线控制权，进入DMA操作周期</li></ol></li><li>发送时<ol><li>确定传送数据的主存单元地址及长度，并能自动修改主存地址计数和传送长度计数</li><li>规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作</li></ol></li><li>发送后<ul><li>向CPU报告DMA操作的结束</li></ul></li></ul><h4 id="DMA传送过程"><a href="#DMA传送过程" class="headerlink" title="DMA传送过程"></a>DMA传送过程</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028144016020.png" alt="image-20211028144016020"></p><p>其中数据传送过程细化如下。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028144048542.png" alt="image-20211028144048542"></p><p>其中因为CPU和DMAk控制器访问主存可能会产生冲突。所以有如下</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028144747246.png" alt="image-20211028144747246"></p><h4 id="DMA特点"><a href="#DMA特点" class="headerlink" title="DMA特点"></a>DMA特点</h4><p>主存和DMA接口之间有一条数据通路，由于DMA方式传送数据不经过CPU，因此不必中断现行程序，<strong>I/O与主机并行工作，程序和传送并行工作</strong></p><ol><li>使主存与CPU的固定联系脱钩，主存即可以被CPU访问，又可被外设访问</li><li>在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现</li><li>主存中要开辟专用缓冲区，及时供给和接收外设的数据</li><li>DMA传送速度快，CPU和外设并行工作，提高了系统效率</li><li>DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理</li></ol><p><strong>例题</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028145231356.png" alt="image-20211028145231356"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028145351157.png" alt="image-20211028145351157"></p><h3 id="DMA方式和中断方式"><a href="#DMA方式和中断方式" class="headerlink" title="DMA方式和中断方式"></a>DMA方式和中断方式</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211028144818551.png" alt="image-20211028144818551"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-第六章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><p>总线是一组多个部件<strong>分时共享</strong>的<strong>公共</strong>信息传送<strong>线路</strong></p><h2 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h2><h3 id="按数据传输格式"><a href="#按数据传输格式" class="headerlink" title="按数据传输格式"></a>按数据传输格式</h3><h4 id="串行总线-并行总线"><a href="#串行总线-并行总线" class="headerlink" title="串行总线-并行总线"></a>串行总线-并行总线</h4><ul><li>串行<ul><li>优点：只需要一条传输线，成本低，广泛用于长距离传输：应用于计算机内部时，可以节省布线空间</li><li>缺点：在数据发送和接收的时候，要进行拆卸和装配，要考虑串行-并行转换的问题</li></ul></li><li>并行<ul><li>优点：总线的逻辑时序比较简单，电路实现起来容易</li><li>缺点：信号线数量多，占用更多的布线空间；远距离传输成本高昂；由于工作频率较高时，并行的信号线之间会产生严重干扰，对每条线等长的要求也越高，所以无法持续提高工作频率。（所以并行不一定比串行更快）</li></ul></li></ul><blockquote><p>工作频率相同时，串行总线传输速度比并行总线慢。</p><p>并行总线的工作频率无法持续提高，而串行总线可以通过不断提高工作频率来提高传输速度，最终超过并行总线</p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026171133750.png" alt="image-20211026171133750"></p><h3 id="按总线功能（连接的部件）"><a href="#按总线功能（连接的部件）" class="headerlink" title="按总线功能（连接的部件）"></a>按总线功能（连接的部件）</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026171533401.png" alt="image-20211026171533401"></p><h4 id="片内总线"><a href="#片内总线" class="headerlink" title="片内总线"></a>片内总线</h4><p>片内总线是芯片内部的总线，是CPU与内部寄存器与寄存器之间，寄存器与ALU之间的公共连线</p><h4 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h4><p>系统总线是计算机系统内各功能部件（CPU，主存，I/O接口）之间互相连接的总线。按系统总线传输信息内容的不同，可以分为 数据，地址，控制总线</p><ol><li>数据总线：用来传输各功能部件之间的数据信息，<strong>双向</strong>，其<strong>位数与机器字长，存储字长有关</strong></li><li>地址总线：用来指出数据总线上的源数据或目的数据所在的主存单元或I/O端口的地址，<strong>单向</strong>，位数与<strong>主存地址空间的大小有关</strong></li><li>控制总线传输控制信息，包括<strong>CPU送出的控制命令和主存（或外设）返回CPU反馈信号</strong></li></ol><h5 id="系统总线的结构"><a href="#系统总线的结构" class="headerlink" title="系统总线的结构"></a>系统总线的结构</h5><p><strong>单总线结构</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026172137127.png" alt="image-20211026172137127"></p><p>虽然是一根线，但是根据传送的东西不同，也可以细分为上面三个基础线路。CPU，主存，IO设备都连接在一组总线上。</p><p>优点：结构简单，成本低，易于接入新的设备</p><p>缺点：带宽低，负载重，多个部件智能争用唯一的总线，且不支持并发传送操作</p><p><strong>双总线结构</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026172358153.png" alt="image-20211026172358153"></p><p>结构：其中有区别的主要是通道，通道实际可以理解为一个小型CPU，接收IO的设备信息</p><p>优点：将较低速的IO设备从单总线上分离出来，实现存储器总线和IO总线分离</p><p>缺点：需要增加通道等硬件设备</p><p><strong>三总线结构</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026172554734.png" alt="image-20211026172554734"></p><p>结构：高速外设那里，因为速度比常规的键鼠快，所以用的是特别的总线，主存和CPU专用一个总线，CPU和其他IO设备一个总线。</p><p>优点：提高IO设备的性能，使其更快的响应命令，提高系统吞吐量</p><p>缺点：系统工作效率较低</p><p><strong>四总线结构（不重要）</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026172854877.png" alt="image-20211026172854877"></p><h4 id="通信总线"><a href="#通信总线" class="headerlink" title="通信总线"></a>通信总线</h4><p>通信总线用于计算机系统之间或计算机系统与其他系统（远程通信设备，测试设备等）之间信息传送的总线，通信总线也称为外部总线。（例如网线）</p><h3 id="按时许控制方式"><a href="#按时许控制方式" class="headerlink" title="按时许控制方式"></a>按时许控制方式</h3><p>同步总线，异步总线</p><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026172809261.png" alt="image-20211026172809261"></p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><ol><li><p>总线的<strong>传输周期（总线周期）</strong></p><p><strong>一次总线操作所需的时间</strong>（包括申请，寻址，传输，结束），通常由若干个总线时钟周期构成。</p></li><li><p>总线<strong>时钟周期</strong></p><p><strong>机器的时钟周期</strong>。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制</p><blockquote><p>总线周期和总线时钟周期</p><p>大多数情况下，一个总线周期包含多个总线时钟周期。但也有如下的情况</p><p>一个总线周期就是一个总线时钟周期</p><p>一个<strong>时钟周期</strong>可包含多个<strong>总线周期</strong>（例如一个时钟周期有一个上沿一个下沿传输数据，就是一个时钟周期有两个总线周期）</p></blockquote></li><li><p>总线的<strong>工作频率</strong></p><p>总线上各种操作的频率，为<strong>总线周期的倒数</strong>。实际上指<strong>一秒内传送几次数据</strong></p></li><li><p>总线的时钟频率</p><p>机器的时钟频率，为<strong>时钟周期的倒数</strong>，实际上指<strong>一秒内有多少个时钟周期</strong></p></li><li><p><strong>总线宽度</strong></p><p>又为<strong>总线位宽</strong>，是总线上<strong>同时能够传输的数据位数</strong>，通常是指<strong>数据总线的根数</strong>，如32根称为32位(bit)</p></li><li><p><strong>总线带宽</strong></p><p>可理解为总线的<strong>数据传输率</strong>，即<strong>单位时间内总线上可传输数据的位数</strong>，通常用每秒钟传送信息的字节数来衡量，单位可用字节/秒(B/s)表示</p><p><strong>总线带宽 = 总线工作频率 * 总线宽度(bit/s) = 总线工作频率 * (总线宽度/8) (B/s) = 总线宽度 / 总线周期(bit/s) = (总线宽度/8)/总线周期(B/s)</strong></p><blockquote><p>总线带宽是指总线本身所能达到的最高传输速率，在计算实际的有效数据传输率时，要用实际传输的数据量除以耗时</p></blockquote></li><li><p>总线复用</p><p>例如数据和地址公用一个总线。用较少的线传输更多的信息</p></li><li><p>信号线数</p><p>地址总线，数据总线，控制总线，3种总线数的总和称为信号线数</p></li></ol><blockquote><p>例题</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026174450895.png" alt="image-20211026174450895"></p></blockquote><h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><p>同一时刻只能有一个设备控制总线传输操作，但是可以有多个设备从总线接收数据</p><ul><li>主设备：获得总线控制权的设备</li><li>从设备：被主设备访问的设备，只能响应从   主设备发来的各种总线命令</li></ul><p>仲裁分类</p><ul><li>链式查询方式</li><li>计数器定时查询方式</li><li>独立请求方式</li><li>分布仲裁方式</li></ul><h3 id="链式查询方式"><a href="#链式查询方式" class="headerlink" title="链式查询方式"></a>链式查询方式</h3><p>从图中可知，BG的信号线是从左到右的。所以工作流程为，设备通过BR进行总线请求，总线如果不忙，就从BG发出信号，从左到右看谁有需求，就允许。然后取消信号。BS发出总线忙的信号。后面总线控制部件就不会发出信号。直到BS取消。</p><p>所以离总线控制部件近的优先级更高。</p><ul><li>优点：链式查询方式优先级固定，只需很少几根控制线就能按一定优先次序实现总线控制，结构简单，扩充容易</li><li>缺点：对硬件电路的故障敏感，且优先级不能改变，当优先级高的部件频繁使用总线时，会使优先级低的部件长期不能使用总线</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027104052075.png" alt="image-20211027104052075"></p><h3 id="计数器查询方式"><a href="#计数器查询方式" class="headerlink" title="计数器查询方式"></a>计数器查询方式</h3><p>工作原理：</p><p>当总线控制器收到总线请求信号，判断总线空闲时，计数器开始计数，计数值通过设备地址线发向各个部件。</p><p>当地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线控制权。同时，中止计数器的计数和查询。</p><p><strong>结构特点</strong>：用一个计数器控制总线使用权，相对链式查询设备地址线，少了一根总线响应线BG。</p><ul><li>优点：计数初始值可以改变优先次序。对电路的故障没有链式敏感</li><li>缺点：<ul><li>增加了控制线数，设备地址线，若设备有n个，则需要（log2n）+2条控制线。例如8个部件需要3个二进制位才能决定。所以需要3条线。</li><li>控制相对链式查询相对复杂</li></ul></li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027104555754.png" alt="image-20211027104555754"></p><h3 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h3><p>简单来说就是，每个人有两条线，要用就从BR请求，可以用就从BG返回，否则就要排队。</p><p><strong>结构特点：</strong>每个设备都有一对总线  BR和BG</p><ul><li>优点：响应速度快，总线允许信号BG直接从控制器发送到有关设备。不需要在设备间传递或查询。对优先次序的控制灵活</li><li>缺点：控制线数量多，需要2n+1条。总线的控制逻辑更加复杂</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027105245470.png" alt="image-20211027105245470"></p><blockquote><p>总线忙的信号是由获得总线控制权的部件发送</p></blockquote><p>​    </p><h3 id="分布仲裁方式（不重要）"><a href="#分布仲裁方式（不重要）" class="headerlink" title="分布仲裁方式（不重要）"></a>分布仲裁方式（不重要）</h3><p><strong>特点：</strong>不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线。</p><p>当设备有总线请求时，它们就把各自唯一的仲裁号发送到共享的仲裁总线上；每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较；如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号；最后，获胜者的仲裁号保留在仲裁总线上。</p><h2 id="操作和定时"><a href="#操作和定时" class="headerlink" title="操作和定时"></a>操作和定时</h2><ol><li><strong>申请分配阶段</strong>：由需要使用总线的主模块（主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某申请者。也可将此阶段细分为<strong>传输请求</strong>和<strong>总线仲裁</strong>两阶段</li><li><strong>寻址阶段：</strong>获得使用权的主模块通过总线<strong>发出</strong>本次要访问的从模块的<strong>地址</strong>及有关<strong>命令</strong>，启动参与本次传输的从模块</li><li><strong>传输阶段：</strong>主模块和从模块进行<strong>数据交换</strong>，可单向或双向进行数据传送</li><li><strong>结束阶段：</strong>主模块的<strong>有关信息</strong>均从系统总线上<strong>撤除</strong>，让出总线使用权</li></ol><p><strong>总线定时</strong>是指总线在双方交换数据的过程中需要时间上配合关系的k控制，这种控制称为总线定时，实质是一种协议或规则</p><h3 id="同步定时方式"><a href="#同步定时方式" class="headerlink" title="同步定时方式"></a>同步定时方式</h3><p><strong>同步定时方式</strong>是指系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。一个总线周期中，发送方和接收方可进行一次数据传送。时钟产生相等的时间间隔，每个间隔构成一个总线周期。</p><p>优点：传送速度快，具有较高的传输速率；总线控制逻辑简单。</p><p>缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性较差。</p><p>同步通信适用于<strong>总线长度较短</strong>及总线<strong>所接部件的存取时间比较接近</strong>的系统。</p><p>上升沿：数字电平从0变为1的一瞬间</p><p>下降沿：数字电平从1变为0的一瞬间</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027112140974.png" alt="image-20211027112140974"></p><h3 id="异步定时方式"><a href="#异步定时方式" class="headerlink" title="异步定时方式"></a>异步定时方式</h3><p>优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行</p><p>信息交换，自动适应时间的配合。</p><p>缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢</p><ol><li><p>不互锁方式（速度快，可靠差）</p><p>主设备发出请求，不等从设备应答，一段时间就撤回。</p><p>从设备发出回答，不等主设备反馈，一段时间就撤回</p></li><li><p>半互锁方式</p><p>主设备发出请求，需要等从设备应答</p><p>从设备还是不等</p></li><li><p>全互锁方式（最可靠，速度慢）</p><p>两方都需要等待反馈</p></li></ol><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027113801632.png" alt="image-20211027113801632"></p><h3 id="半同步通信"><a href="#半同步通信" class="headerlink" title="半同步通信"></a>半同步通信</h3><p>实际就是在同步的情况下。如果中间有等待数据时间，启动一个等待时间。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027113919112.png" alt="image-20211027113919112"></p><h3 id="分离式通信"><a href="#分离式通信" class="headerlink" title="分离式通信"></a>分离式通信</h3><p>原理：一个操作中，一部分时间是不需要使用总线的，那时可以将总线空闲出来给其他部件使用。等到需要使用的时候再进行总线的控制（也需要申请）</p><h2 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211027114301860.png" alt="image-20211027114301860"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-第五章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><h2 id="CPU的功能和基本结构总述"><a href="#CPU的功能和基本结构总述" class="headerlink" title="CPU的功能和基本结构总述"></a>CPU的功能和基本结构总述</h2><p><strong>CPU的功能</strong></p><ul><li>指令控制，完成取指令，分析指令和执行指令的操作，即程序的顺序控制</li><li>操作控制，一条指令的功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的不见，从而控制这些部件按指令的要求进行动作</li><li>时间控制：对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号</li><li>数据加工：对数据进行算数和逻辑运算</li><li>中断处理：对计算机运行过程中出现的异常情况和特殊请求进行处理</li></ul><p>运算器和控制器的功能</p><p>运算器：对数据进行加工</p><p>控制器：协调并控制计算机各部件执行程序的指令序列，基本功能包括取指令，分析指令，执行指令</p><ul><li><p>取指令：自动形成指令地址，自动发出取指令的命令</p></li><li><p>分析指令：操作码译码（包括本条指令要完成什么操作）：产生操作数的有效地址</p></li><li><p>执行指令：根据分析指令得到的 ”操作命令“ 和 ”操作数地址“ 形成操作信号控制序列，控制运算器，存储器以及I/O设备完成相应的操作</p></li><li><p>中断处理：管理总线及输入输出：处理异常情况（如掉点）和特殊请求（如打印机请求打印一行字符）</p></li></ul><h2 id="运算器的基本结构"><a href="#运算器的基本结构" class="headerlink" title="运算器的基本结构"></a>运算器的基本结构</h2><p>算数逻辑单元：主要功能是进行算数/逻辑运算</p><p>通用寄存器组：如Ax，Bx，Cx，SP（堆栈）等，用于存放操作数（包括源操作数，目的操作数及中间结果）和各种地址信息等。SP是堆栈指针，用于指示栈顶的地址</p><ul><li><p>第一张图是直接用导线连接，相当于多个寄存器同时并且一直想ALU传输数据。（有问题）</p></li><li><p>解决方法一：图2，使用多路选择器根据控制信号选择一路输出（蓝色线路）</p><ul><li>性能较高，基本不存在数据冲突现象，但结构复杂，硬件量大，不易实现</li></ul></li><li><p>解决方法二：图3，使用三态门可以控制每一路是否输出。</p><p>如R0out为<strong>1时R0中的数据输出到A端</strong>，R0out为<strong>0时R0数据无法输出到B端</strong></p></li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021165001610.png" alt="image-20211021165001610"></p><p>另一种总线结构</p><ul><li><p>暂存寄存器：用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容。</p></li><li><p>累加寄存器：是一个通用寄存器，用于暂时存放ALU运算的结果信息，用于实现加法运算</p></li><li><p>程序状态字寄存器（PSW）：保留由算数逻辑运算指令或测试指令的结果而简历的各种状态信息，如溢出标志(OP)，符号标志(SF)，零标志(ZF)，进位标志(CF)等。PSW中的这些位参与并决定微操作的形成</p></li><li><p>移位器：对运算结果进行移位操作</p></li><li><p>计数器：控制乘除运算的操作步数</p></li></ul><p>结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。</p><blockquote><p>其中移位寄存器，实际是暂存寄存器拥有移位寄存器的功能。图中不好画出</p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021165904690.png" alt="image-20211021165904690"></p><h2 id="控制器的基本结构"><a href="#控制器的基本结构" class="headerlink" title="控制器的基本结构"></a>控制器的基本结构</h2><ul><li>程序计数器；用于指出下一条指令在主存中的存放地址。CPU就是根据PC的内容去主存中取指令的。因程序中指令（通常）是顺序执行的，所以PC有自增功能</li><li>指令寄存器：用于保存当前正在执行的那条指令</li><li>指令译码器：仅对操作码字段进行译码，向控制器提供特定的操作信号</li><li>微操作信号发生器：根据IR的内容（指令），PSW的内容（状态信息）及   时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种</li><li>时序系统：用于产生各种时序信号，他们都是由统一始终（CLOCK）分频得到</li><li>存储器地址寄存器：用于存放所要访问的主存单元的地址</li><li>存储器数据寄存器：用于存放向主存写入的信息或从主存中读出的信息</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021171245774.png" alt="image-20211021171245774"></p><h2 id="CPU的基本结构"><a href="#CPU的基本结构" class="headerlink" title="CPU的基本结构"></a>CPU的基本结构</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021172021116.png" alt="image-20211021172021116"></p><p><strong>其中橙色的是，用户可见的寄存器（可编程）</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021171901641.png" alt="image-20211021171901641"></p><h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><p><strong>指令周期</strong>：CPU从主存中每取出并执行一条指令所需的全部时间。<strong>指令周期</strong>常常用若干<strong>机器周期</strong>来表示，机器周期又叫<strong>CPU周期</strong>，一个<strong>机器周期</strong>又包含若干<strong>时钟周期</strong>（<strong>节拍、T周期或CPU时钟周期</strong>，是CPU<strong>最基本单位</strong>）</p><blockquote><p>其中T0就是时钟周期，也就是节拍。</p><p>每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等，每个机器周期内的节拍数也可以不等</p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025125410605.png" alt="image-20211025125410605"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025125824192.png" alt="image-20211025125824192"></p><p>FE，IND，EX，INT分别是取指，间址，执行和中断4个周期，以1状态表示有效</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025130334329.png" alt="image-20211025130334329"></p><h3 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025132451806.png" alt="image-20211025132451806"></p><h3 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025132601408.png" alt="image-20211025132601408"></p><h3 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h3><p>执行周期的任务是根据 <strong>IR</strong> 中的指令字的操作码和操作数通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向</p><h3 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025132740721.png" alt="image-20211025132740721"></p><p>暂停当前任务去完成其他任务。为了能够恢复当前任务，需要<strong>保存断点</strong>。一般使用堆栈来保存断点，这里用SP表示栈顶地址，假设<strong>SP指向栈顶元素</strong>，进栈操作是<strong>先修改指针，后存入数据</strong>。</p><p>CU控制将SP减1，修改后的地址送入MAR，记作：(SP)-1—&gt;SP，(SP)—&gt;MAR，本质上是将断点存入某个存储单元，假设其地址为a，可记作a—–&gt;MAR，然后3那里CU发出控制信号，启动主存<strong>写操作</strong></p><h2 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h2><ol><li><p><strong>单指令周期</strong></p><p>所有指令都选用相同的执行时间来完成，也就是一条一条的进行执行</p></li><li><p><strong>多指令周期</strong></p><p><strong>对不同类型的指令</strong>，用不同的执行步骤来完成，也还是串行执行，但可选用不同个数的时钟周期来完成不同指令的执行过程</p></li><li><p><strong>流水线</strong></p><p>在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中，指令之间<strong>并行</strong>执行</p></li></ol><h2 id="数据通路和两种结构"><a href="#数据通路和两种结构" class="headerlink" title="数据通路和两种结构"></a>数据通路和两种结构</h2><h3 id="基本单总线结构"><a href="#基本单总线结构" class="headerlink" title="基本单总线结构"></a>基本单总线结构</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021172021116.png"></p><ul><li>内部总线：是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线</li><li>系统总线：是指同一台计算机系统的各部件，如CPU，内存，通道和各类I/O接口间互相连接的总线</li></ul><p>其中通过总线进行传输。必须两个线路中，一个为out，一个为in的线路打开。才能准确传输。例如</p><ul><li>寄存器之间数据传送：PCout，MARin，就可以把PC的东西送到MAR</li><li>主存与CPU之间的数据传送：<ul><li>(PC)—&gt;BUS—-&gt;MAR</li><li>1—&gt;R   这里是CU发控制信号，通过控制总线发出（图中未画）</li><li>MEM(MAR)—&gt;MDR   内存的数据送到MDR</li><li>MDR—-&gt;Bus—IR</li></ul></li><li>执行算数或逻辑运算<ul><li>Ad(IR)→Bus→MAR</li><li>1→R</li><li>MEM(MAR)→数据线→MDR</li><li>MDR→Bus→Y</li><li>(ACC)+(Y)→Z</li><li>Z→ACC</li><li><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025142328186.png" alt="image-20211025142328186"></li></ul></li></ul><h3 id="专用数据通路结构"><a href="#专用数据通路结构" class="headerlink" title="专用数据通路结构"></a>专用数据通路结构</h3><p>以取指周期为例</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025143833413.png" alt="image-20211025143833413"></p><h2 id="硬部件控制器"><a href="#硬部件控制器" class="headerlink" title="硬部件控制器"></a>硬部件控制器</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025164006649.png" alt="image-20211025164006649"></p><p>紫色的那里是机器周期，绿色是机器状态条件。红色是发出的 “微命令”</p><p>电路是在CU内部。例如要进行一个取指PC—&gt;MAR，则将 FE*T0=C1（假设以便理解）</p><p>再一个简单的电路图</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025164721781.png" alt="image-20211025164721781"></p><p>公式的意思是，FE*T1代表的是所有公式都需要FE*T1这个操作。IND<em>T1(ADD+STA+LDA+JMP+BAN)是ADD STA这些要IND\</em>T1这个操作。且这些操作都是在T1实现的，这个电路就可以是前面CU里面的电路，当然实际的肯定更复杂，不会只有这么多功能。</p><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ol><li>分析每个阶段的微操作序列（取指，间址，执行，中断四个阶段，也就是确定哪些指令的什么阶段，在什么条件下会使用到的微操作）</li><li>选择CPU的控制方式（采用定长还是不定长，每个机器周期有几个节拍）</li><li>安排微操作时序（假设我们有3个节拍，怎么在3个节拍完成所有微操作）</li><li>电路设计（确定每个微操作命令的逻辑表达式，并实现电路）</li></ol><p><strong>1</strong>.分析</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025165326869.png" alt="image-20211025165326869"></p><p><strong>2</strong>.假设只有3个节拍</p><p><strong>3</strong>.安排微操作时序</p><blockquote><p><strong>注：如果微操作数小于节拍数，就把操作放在后面，以实现不管怎么样都是3个节拍完成</strong></p></blockquote><p>三原则</p><ul><li>微操作的<strong>先后顺序不得</strong>随意<strong>更改</strong></li><li><strong>被控对象不同</strong>的微操作，尽量安排在<strong>一个节拍</strong>内完成</li><li>占用<strong>时间较短</strong>的微操作，尽量安排在<strong>一个节拍内</strong>完成，并<strong>允许有先后顺序</strong></li></ul><p>例：取指周期</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(1)</span>pc---&gt;MAR    <span class="number">1</span></span><br><span class="line"><span class="comment">(2)</span><span class="number">1</span>----&gt;R      <span class="number">2</span></span><br><span class="line"><span class="comment">(3)</span>M<span class="comment">(MAR)</span>--&gt;MDR <span class="number">3</span></span><br><span class="line"><span class="comment">(4)</span>MDR---&gt;IR    <span class="number">4</span></span><br><span class="line"><span class="comment">(5)</span>OP<span class="comment">(IR)</span>----ID <span class="number">5</span></span><br><span class="line"><span class="comment">(6)</span><span class="comment">(PC)</span><span class="number">+1</span>---&gt;PC <span class="number">6</span></span><br><span class="line"></span><br><span class="line">变为如下</span><br><span class="line">T<span class="number">0</span> <span class="comment">(1)</span>pc---&gt;MAR     <span class="number">1</span></span><br><span class="line">T<span class="number">0</span> <span class="comment">(2)</span><span class="number">1</span>----&gt;R       <span class="number">2</span></span><br><span class="line">T<span class="number">1</span> <span class="comment">(3)</span>M<span class="comment">(MAR)</span>--&gt;MDR  <span class="number">3</span></span><br><span class="line">T<span class="number">1</span> <span class="comment">(6)</span><span class="comment">(PC)</span><span class="number">+1</span>---&gt;PC  <span class="number">4</span></span><br><span class="line">T<span class="number">2</span> <span class="comment">(4)</span>MDR---&gt;IR     <span class="number">5</span></span><br><span class="line">T<span class="number">2</span> <span class="comment">(5)</span>OP<span class="comment">(IR)</span>----ID  <span class="number">6</span></span><br></pre></td></tr></table></figure><p>其中1，2因为一个是CPU内部寄存器的操作，2是主存的操作。而且相互不影响。所以可以放在一起操作</p><p>因为3必须1走完才能操作，所以放在位置3，其中6的操作不影响其他的操作，只要PC取完数据之后就能操作，所以放在4的位置也可以。因为4的操作需要等3完成，他们不能放在一个周期，所以让4在后面一个周期。而5又需要等4的结果，所以放在4后面。又因为45是在CPU内部，操作很快，因此可以在一个节拍内完成。</p><p>例2</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CLA，clear操作，进行ACC清零</span><br><span class="line"><span class="built_in">T0</span></span><br><span class="line"><span class="built_in">T1</span></span><br><span class="line"><span class="built_in">T2</span>   <span class="number">0</span>---&gt;AC</span><br></pre></td></tr></table></figure><p>只需要一次操作就可以完成，所以放在最后</p><p><strong>4</strong>这里可以分成三个步骤 </p><p>列出操作时间表，写出微操作命令的最简表达式，画出逻辑图</p><p><strong>操作时间表</strong></p><p>取指阶段</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025171526784.png" alt="image-20211025171526784"></p><p>间址阶段</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025171604766.png" alt="image-20211025171604766"></p><p>执行周期</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025171424908.png" alt="image-20211025171424908"></p><p><strong>微操作命令的最简表达式</strong></p><p>以M(MAR)—-&gt;MDR为例</p><p>取指阶段是所有都为1都有这个操作，间址阶段CLA到STP是没有的。执行阶段只有ADD,LDA有。且所有都在T1的节拍中。所以最后公式如下</p><p>FE*T1 + IND*T1(ADD+STA+LDA+JMP+BAN) + EX*T1(ADD+LDA)，这里还要化简省略了</p><p><strong>逻辑图如下</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025172006381.png" alt="image-20211025172006381"></p><h2 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h2><p>设计思路：采用 ”存储程序“，将所有指令的 ”微程序“ 存入 ”控制器存储器“ 中</p><p>相当于，微程序包含多个微操作，微操作包含多个微命令。</p><p>指令是对<strong>程序</strong>执行步骤的描述</p><p>微指令是对<strong>指令</strong>执行步骤的描述</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">T0</span> (<span class="number">1</span>)pc---&gt;MAR     <span class="number">1</span></span><br><span class="line"><span class="attribute">T0</span> (<span class="number">2</span>)<span class="number">1</span>----&gt;R       <span class="number">2</span></span><br><span class="line"><span class="attribute">T1</span> (<span class="number">3</span>)M(MAR)--&gt;MDR  <span class="number">3</span></span><br><span class="line"><span class="attribute">T1</span> (<span class="number">6</span>)(PC)+<span class="number">1</span>---&gt;PC  <span class="number">4</span></span><br><span class="line"><span class="attribute">T2</span> (<span class="number">4</span>)MDR---&gt;IR     <span class="number">5</span></span><br><span class="line"><span class="attribute">T2</span> (<span class="number">5</span>)OP(IR)----微地址形成部件  <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>这里和硬布线不同，硬布线最后一步进入ID指令译码器，微程序这里进入的是微地址形成部件</strong>，且其中还需要加入一些其它微命令，在微程序设计那里进行讨论</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025174009279.png" alt="image-20211025174009279"></p><p>其中<strong>下地址</strong>的存放的是下一个指令的地址。下地址左边的是现在的微指令</p><p>CM控制存储器</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211025174233544.png" alt="image-20211025174233544"></p><p><strong>存放了所有的指令</strong>，左边的数字是地址信息</p><p>补充：</p><p>因为是顺序逻辑来进行的操作。所以就这个图中，取指完了之后实际是间址，但是有的指令不需要进行间址。所以图中顺序逻辑的位置实际是有个标志位进行标识。 OP那里有带标志位。间址周期完成之后，就进入到执行周期（<strong>转执行周期</strong>）</p><p>还有就是 CLK判断中断信号。如果判断带了中断信号，就进行中断操作。中断操作之后，会回到原来的取指（<strong>转取指周期</strong>）</p><p>执行周期执行玩之后，最后的下地址是0，所以就会走回到取指周期</p><p><strong>取指周期：通常是公用的，如果某指令系统中有n条机器指令（LDA，ADD等），则CM中微程序的个数至少是n+1个。间址周期和中断周期不算在计算中。</strong>因为一些早期的CPU，物联网设备的CPU可以不提供间接寻址和中断功能，因此这类CPU可以不包含间址周期，中断周期的微程序段。</p><p>在物理上看，取指周期，执行周期是两个微程序，但逻辑上他们其实是一个整体。所以<strong>一条指令对应一个微程序</strong></p><h3 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026124551152.png" alt="image-20211026124551152"></p><h3 id="微指令编码方式"><a href="#微指令编码方式" class="headerlink" title="微指令编码方式"></a>微指令编码方式</h3><h4 id="直接编码（直接控制）方式"><a href="#直接编码（直接控制）方式" class="headerlink" title="直接编码（直接控制）方式"></a>直接编码（直接控制）方式</h4><p>在微指令的操作控制字段中，<strong>每一位代表一个微操作命令</strong>，某位的”1“ 表示该控制命令有效</p><p>优点：简单，直观，执行速度快，操作并行性好</p><p>缺点：微指令字长过长，n个微命令就要求微指令的操作字段有n位，造成控存容量极大</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026125036268.png" alt="image-20211026125036268"></p><h4 id="字段直接编址方式"><a href="#字段直接编址方式" class="headerlink" title="字段直接编址方式"></a>字段直接编址方式</h4><p>将微指令的控制字段分成若干 ”段“，<strong>每段经译码后发出控制信号</strong></p><p>原则：</p><ol><li><strong>互斥性</strong>的微命令分在<strong>同一段内，相容性</strong>的微命令分在<strong>不同段内</strong></li><li><strong>每个小段</strong>中包含的<strong>信息位不能太多</strong>，否则将增加译码线路的复杂性和译码时间</li><li>一般<strong>每个小段还要留出一个状态</strong>，表示本字段不发出任何微命令。相当于当某个字段长度3位时，最多只能表示7个互斥的微命令，<strong>通常用000表示不操作</strong></li></ol><p>优点：可以缩短微指令字长</p><p>缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢</p><p>如下图，其中分段进行划分，PC—&gt;MAR 和 (PC)+1—&gt;PC是互斥的，放在同一个段</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026125646325.png" alt="image-20211026125646325"></p><blockquote><p>例题</p><p>某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码法，共有33个微命令，构成5个互斥类，分别包含7，3，12，5和6个微命令，则操作控制字段至少有多少位？</p><p>解</p><p>第一个互斥类有7个微命令，要留出1个状态表示不操作，所以需要8种不同的状态，需要两个3个二进制位。其他几个一样的算法。然后3+2+4+3+3=15位。</p></blockquote><h4 id="字段间接编码方式"><a href="#字段间接编码方式" class="headerlink" title="字段间接编码方式"></a>字段间接编码方式</h4><p>一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，故称为字段间接编码，又称<strong>隐式编码</strong></p><p>优点：可进一步缩短微指令字长</p><p>缺点：削弱了微指令的并行控制能力，故通常作为字段直接的一种辅助手段</p><p>译码之后又进行了一次译码</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026130530514.png" alt="image-20211026130530514"></p><h3 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h3><ol><li><p>微指令的<strong>下地址字段</strong>指出：微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址，<strong>断定方式</strong></p></li><li><p>根据机器指令的<strong>操作码</strong>形成：当机器指令取至指令寄存器后，微指令的地址由操作码经<strong>微地址形成部件</strong>形成</p></li><li><p>增量计数器法 （CMAR)+1—-&gt;CMAR</p></li><li><p>分支转移   转移方式：指明判别条件；   转移地址指明转移成功后的去向</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026130959621.png" alt="image-20211026130959621"></p></li><li><p>通过测试网络   </p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026131229661.png" alt="image-20211026131229661"></p></li><li><p>由硬件产生微程序入口地址，<strong>第一条微指令地址</strong>由专门的<strong>硬件产生</strong>，中断周期也由<strong>硬件</strong>产生<strong>中断周期微程序首地址</strong></p></li></ol><blockquote><p>微指令的地址形成方式，出题例题</p><p>某计算机采用微程序控制器，共有32条指令，公共的取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成，采用断定法（下地址字段法）确定下条微指令地址，则微指令中下地址字段的位数至少是多少位</p><p>解</p><p>已知公共有2条微指令，还有32条指令，32条指令每一条包含4条微指令，则应该是</p><p>2+32*2=130条微指令。标注出130位不同的位置需要 2^8=256，则下地址字段的位数至少8位</p></blockquote><h3 id="微程序控制单元设计"><a href="#微程序控制单元设计" class="headerlink" title="微程序控制单元设计"></a>微程序控制单元设计</h3><p>设计步骤</p><ol><li><p>分析每个阶段的微操作序列（这里只进行取指的分析）</p></li><li><p>写出对应机器指令的微操作命令及节拍安排</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026132334342.png" alt="image-20211026132334342"></p></li><li><p>确定微指令格式</p><p>根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数。由微指令数确定微指令的控制字段的位数，最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长</p></li><li><p>编写微指令码点</p><p>根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点</p></li></ol><h4 id="微程序设计分类"><a href="#微程序设计分类" class="headerlink" title="微程序设计分类"></a>微程序设计分类</h4><ol><li><p>静态微程序设计和动态微程序设计</p><p>静态 微程序无需改变 采用ROM</p><p>动态 通过 改变微指令  和   微程序改变机器指令，有利于仿真，采用EPROM</p></li><li><p>毫微程序设计</p><p>毫微程序设计的基本概念</p><p>微程序设计 用 微程序解释机器指令</p><p>毫微程序设计 用 毫微程序解释微程序</p><p>毫微指令与微指令的关系好比微指令与机器指令的关系</p></li></ol><h3 id="比较硬布线和微程序"><a href="#比较硬布线和微程序" class="headerlink" title="比较硬布线和微程序"></a>比较硬布线和微程序</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026133143470.png" alt="image-20211026133143470"></p><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026133303687.png" alt="image-20211026133303687"></p><h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p>一条指令的执行过程可以分成多个阶段，根据计算机的不同，具体的分法也不同。假如是  取指，分析，执行。</p><p><strong>顺序执行方式</strong></p><p>优点：控制简单，硬件代价小</p><p>缺点：执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低</p><p>耗时：T=n*3t = 3nt</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026133641492.png" alt="image-20211026133641492"></p><p><strong>一次重叠执行方式</strong></p><p>耗时：T = 3t + (n-1)*2t = (1+2n)t)</p><p>优点：程序的执行时间缩短了1/3，各功能部件的利用率明显提高</p><p>缺点：需要付出硬件上较大开销的代价，控制过程也比顺序执行复杂了</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026133832790.png" alt="image-20211026133832790"></p><p><strong>二次重叠执行方式</strong></p><p>指令的执行时间缩短2/3。是一种理想的指令执行方式，正常情况下处理机中同时有3条指令在执行</p><p>耗时：T = 3t + (n-1)*t = (2+n)t</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026134005386.png" alt="image-20211026134005386"></p><p><strong>流水线的表示方法</strong></p><p>这里时空图是把执行分为5个阶段。但是这里是理想状态</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026134352713.png" alt="image-20211026134352713"></p><h3 id="流水线的性能指标"><a href="#流水线的性能指标" class="headerlink" title="流水线的性能指标"></a>流水线的性能指标</h3><h4 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h4><p>指在单位时间内流水线所完成的任务数量，或是输出结果的数量。</p><p>任务数为n，处理n个任务所用的时间为Tk，吞吐率为TP</p><p>TP=n/Tk</p><p>例，此图是理想情况的图</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026134910109.png" alt="image-20211026134910109"></p><p>Tk=(k+n-1) △t，则 TP= n/TK</p><h4 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h4><p>完成同样一批任务，<strong>不使用流水线所用的时间</strong>与<strong>使用流水线所用的时间</strong>之比。也就是T0/Tk</p><p>就上图来说，T0=kn△t</p><h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>流水线的设备利用率称为流水线的效率，在时空图上，流水线的效率定义为<strong>完成n个任务占用的时空区有效面积</strong>与<strong>n个任务所用的时间与k个流水段所围成的时空区</strong>之比</p><p>流水线效率（E）的一般公式为  </p><p>E=n个任务占用k时空区有效面积 / n个任务所用的时间与k个流水段所围城的时空区总面积   </p><p>E=T0/kTk</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026135900185.png" alt="image-20211026135900185"></p><h3 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h3><p><strong>结构相关（资源冲突）</strong></p><p>问题</p><p>由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关</p><p>解决</p><ol><li>后一相关指令暂停一周期</li><li>资源重复配置：数据存储器+指令存储器</li></ol><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026141900701.png" alt="image-20211026141900701"></p><p><strong>数据相关（数据冲突）</strong></p><p>数据相关指在一个程序中，存在必须等前一条指令执行完才能执行h后一条指令的情况，则这两条指令为数据相关</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026142254023.png" alt="image-20211026142254023"></p><p>解决</p><ol><li><p>把遇到数据相关的指令极其后序指令都暂停 一至几个时钟周期，知道数据相关问题消失后再继续执行。可分为硬件阻塞（stall）和软件插入（NOP）</p><p>如下是NOP的图，硬件的图也差不多，把NOP变成stall就行</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026142840478.png" alt="image-20211026142840478"></p></li><li><p>数据旁路技术</p><p>简单来说就是，下面的需要r1，需要第一条指令 执行完成，但是我们可以在他计算完之后，直接从ALU把数据就取过来。不需要经过内存</p></li><li><p>编译优化：通过编译器调整指令顺序来解决数据相关</p></li></ol><p><strong>控制相关（控制冲突）</strong></p><p>当流水线遇到转移指令和其他改变PC值的指令而造成断流时，会引起控制相关</p><p>解决</p><ol><li><p>尽早判别转移是否发生，尽早生成转移目标地址</p></li><li><p>预取转移成功和不成功两个控制流方向上的目标指令</p></li><li><p>加快和提前形成条件码</p><p>例如加法器那里的，提前把进位信息取出来给出去</p></li><li><p>提高转移方向的猜准率</p></li></ol><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026143403202.png" alt="image-20211026143403202"></p><h3 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h3><ol><li><strong>部件功能级，处理机级和处理机间的级流水线</strong><ol><li><strong>部件功能级流水</strong>就是将复杂的算数逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差，对阶，尾数相加以及结果规格化等4个过程</li><li><strong>处理机级流水</strong>是把一条指令解释过程分成多个子过程，如取指，译码，执行，访存及写回5个子过程</li><li><strong>处理机间流水</strong>是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中</li></ol></li><li>单功能流水线和多功能流水线<ol><li><strong>单功能流水线</strong>指只能实现一种固定的专门功能的流水线</li><li><strong>多功能流水线</strong>指通过各段间的不同连接方式可以同时或不同时的实现多种功能的流水线</li></ol></li><li>动态流水线和静态流水线<ol><li><strong>静态流水线</strong>指同一时间内，流水线的各段只能按同一种功能的连接方式工作</li><li><strong>动态流水线</strong>指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变的很复杂</li></ol></li><li>线性流水线和非线性流水线<ol><li><strong>线性流水线</strong>，从输入到输出，每个功能只允许经过一次，不存在反馈回路。（数据回路就是例如ALU的结果又取回进行使用）</li><li><strong>非线性流水线</strong>存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线。这种流水线适合进行线性递归运算</li></ol></li></ol><h3 id="流水线的多发技术"><a href="#流水线的多发技术" class="headerlink" title="流水线的多发技术"></a>流水线的多发技术</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026144829633.png" alt="image-20211026144829633"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026144836354.png" alt="image-20211026144836354"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026144846396.png" alt="image-20211026144846396"></p><h3 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211026144859586.png" alt="image-20211026144859586"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-第四章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><p>指令（机器指令）（操作码+地址码）：指示计算机执行某种操作的命令，是计算机运行的最小功能单位。一台计算机所有指令的集合构成该机的<strong>指令系统</strong>，也成为<strong>指令集</strong></p><ul><li><p><strong>零地址指令OP：</strong>不需要操作数：如空操作，停机，关中断等指令。</p><p>堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶</p></li><li><p>一地址指令</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020165247381.png" alt="image-20211020165247381"></p><p>只需要单操作数，如 加1，减1，取反，求补等。OP（A1）—&gt;A1，完成一条指令需要 3次访存：取指–》读A1—》写A1</p><p>需要两个操作数：但其中一个操作数隐含在某个寄存器中，不需要取，例如ACC。(ACC) OP (A1)—-&gt;ACC 完成一条指令需要 2次访存：取指–》读A1</p></li><li><p>二地址指令</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020165534846.png" alt="image-20211020165534846"></p><p>常用于需要两个操作数的算数运算，逻辑运算相关指令。指令含义：(A1)OP(A2)—-A1，完成一条指令需要访存4次：取指—》读A1—》读A2—》写A1</p></li><li><p>三地址指令</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020165656426.png" alt="image-20211020165656426"></p><p>常用语需要两个操作数的算数运算，逻辑运算。指令含义：(A1)OP(A2)—&gt;A3，完成指令需要访存4次，取指—&gt;读A1—读A2—》写A3</p></li><li><p>四地址指令</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020165817834.png" alt="image-20211020165817834"></p><p>指令含义：(A1)OP(A2)—&gt;A3，A4指向下一条需要执行指令的地址，正常情况执行完操作之后，PC+1，指向下一条指令。在四地址指令中：执行指令后，将PC的值修改为A4所指的地址</p></li></ul><blockquote><p>n位地址码的直接寻址范围=2^n</p><p>若指令总长度固定不变，则d地址码数量越多，寻址能力越差</p></blockquote><p><strong>指令–按指令长度分类</strong></p><p><strong>指令字长：一条指令的总长度（可能会变）</strong></p><p>半字长指令，单字长指令，双字长指令—指令长度是机器字长的倍数，指令字长会影响取指令所需时间。如：机器字长=存储字长=16bit，则取一条双字长指令需要两次访存</p><p><strong>定长指令字结构：</strong>指令系统中所有指令的长度都相等</p><p><strong>变长指令字结构：</strong>指令系统中各种指令的长度不等</p><p><strong>按操作码长度分类</strong></p><p><strong>定长操作码</strong>：指令系统中所有指令的操作码长度都相同，n位—&gt;2^n条指令</p><p><strong>可变长操作码</strong>：指令系统中各指令的操作码长度可变</p><p>定长指令字结构+可变长操作码—-》扩展操作码指令格式</p><p><strong>按操作类型分类</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020170617716.png" alt="image-20211020170617716"></p><h2 id="扩展操作码"><a href="#扩展操作码" class="headerlink" title="扩展操作码"></a>扩展操作码</h2><p>注：不允许短码是长码的前缀，也就是短操作码不能与长操作码的前面部分的代码相同。各指令的操作码一定不能重复</p><p>通常对使用频率较高的指令，分配较短的操作码；对使用频率较低的指令，分配较长的操作码，尽可能减少指令译码和分析的时间</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021093816000.png" alt="image-20211021093816000"></p><p>另一种扩展方法</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021094157897.png" alt="image-20211021094157897"></p><p><strong>指令操作码</strong></p><p>操作码指出指令中该指令应该执行什么性质的操作和具有何种功能</p><p>分类</p><ul><li>定长操作码：在指令字的最高位部分分配固定的若干位（定长）表示操作码，一般n位操作码字段的指令系统最大能够表示2^n条指令<ul><li>优：定长操作码对于简化计算机硬件设计，提高指令译码和识别速度有利</li><li>缺：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限</li></ul></li><li>扩展操作码：全部指令的操作码字段的位数不固定，且分散的放在指令字的不同位置。指令可以具有不同长度的操作码，从而在满足需要的前提下，有效的缩短指令字长<ul><li>优：在指令字长有限的前提下保持比较丰富的指令种类</li><li>缺：增加了指令译码和分析的难度，使控制器的设计复杂化</li></ul></li></ul><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><p>顺序寻址，跳跃寻址</p><h3 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a><strong>顺序寻址</strong></h3><blockquote><p>PC+”1”,这里的1不一定真的是+1，这里的1理解为1个指令字长，实际加的值会因指令长度，编址方式而不同</p></blockquote><p>采用<strong>定长指令字结构</strong>，指令字长=存储字长=16bit=2B。</p><ul><li><strong>主存按字寻址</strong>：pc每次+1.为一个字</li><li><strong>主存按字节寻址：</strong>如果为4个字节，就是2字。所以pc需要+2</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021114345613.png" alt="image-20211021114345613"></p><h3 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a><strong>跳跃寻址</strong></h3><p><strong>由转移指令指出。</strong>例如 JMP 7，实际上不是pc+1了。实际上 JMP=无条件转移。将PC中的内容改为7的地址，类似与goto</p><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><p>这里是一地址指令，如果是二地址，后面的寻址特征和形式地址，也会相应的增加。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021115007780.png" alt="image-20211021115007780"></p><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p><strong>指令字中的形式地址A就是操作数的真实地址EA，即EA=A</strong>。直接对地址进行访存</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021115255216.png" alt="image-20211021115255216"></p><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>指令的地址字段给出的形式地址，不是操作数的真正地址，而是操作数y有效地址所在的存储单元的地址，也就是操作数地址的地址。也就是A中存放的不是真实地址，存的是主存的一个地址，主存的地址又指向其他地址。</p><ul><li><p>优：可扩大寻址范围（有效地址EA的位数大于形式地址A的位数），便于编址程序（用于间接寻址可以方便的完成子程序返回）</p></li><li><p>缺：指令在执行阶段要多次访存（一次间接寻址需要两次访存，多次寻址需要根据存储字的最高位确定几次访存）</p></li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021115509120.png" alt="image-20211021115509120"></p><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>在指令字中直接给出操作数所在的寄存器编号，即EA=Ri，其操作数在由Ri所指的寄存器中。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021141216818.png" alt="image-20211021141216818"></p><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>寄存器Ri中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=(Ri)</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021141551219.png" alt="image-20211021141551219"></p><h3 id="隐含地址"><a href="#隐含地址" class="headerlink" title="隐含地址"></a>隐含地址</h3><p>不是明显的给出操作数的地址，而是指令隐含着操作数的地址。例如上面的一地址的时候，有一个情况是，取一个操作数和ACC中的数据进行操作。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021141809437.png" alt="image-20211021141809437"></p><h3 id="基址寻址-偏移寻址"><a href="#基址寻址-偏移寻址" class="headerlink" title="基址寻址-偏移寻址"></a>基址寻址-偏移寻址</h3><p>将CPU中基址寄存器（BR）或者是由通用寄存器 的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA=(BR)+A</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021142217997.png" alt="image-20211021142217997"></p><blockquote><p>基址寄存器是<strong>面向操作系统</strong>的，其<strong>内容由操作系统或管理程序确定</strong>。在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。</p><p>当采用通用寄存器作为基址寄存器时，可由<strong>用户决定哪个寄存器作为基址寄存器</strong>，但其<strong>内容仍由操作系统确定</strong></p></blockquote><p>优点：可扩大寻址范围（基址寄存器的位数大于形式地址A的位数）；用户不必考虑自己程序存于主存的哪一空间，<strong>有利于多道程序设计</strong>，以及编制浮动程序（整个程序在内存里浮动）</p><p>例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里一个循环程序，基址寄存器存程序的地址，假如要用到其中的数组，只需要程序基址加上偏移量即可。不需要考虑程序地址位置</span></span><br></pre></td></tr></table></figure><h3 id="变址寻址-偏移寻址"><a href="#变址寻址-偏移寻址" class="headerlink" title="变址寻址-偏移寻址"></a>变址寻址-偏移寻址</h3><p>有效地址EA等于指令字中的形式地址A与<strong>变址寄存器IX</strong>的内容相加之和。即EA=(IX)+A，其中<strong>IX可变为变址寄存器（专用）</strong>，也<strong>可用通用寄存器作为变址寄存器</strong></p><p><strong>变址寄存器是面向用户的，</strong>在程序执行过程中，变址寄存器的**内容可由用户改变（作为偏移量），形式地址A不变（作为基地址），如果没看懂就看下面的例子。</p><p>优点：在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别<strong>适合编制循环程序</strong></p><p><strong>注：右边的那个是基址寻址的图</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021143740973.png" alt="image-20211021143740973"></p><p>例，还是上面的那个C语言程序。变址寄存器存放IX，A存放数组的a[0]，然后A每次加上IX偏移量。IX每次循环都会对应 i++，所以正好实现地址偏移。这样省去了直接寻址a数组需要 10个空间。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021144355262.png" alt="image-20211021144355262"></p><h4 id="变址-基址进行复合编址"><a href="#变址-基址进行复合编址" class="headerlink" title="变址+基址进行复合编址"></a>变址+基址进行复合编址</h4><p>在一个程序中，先进行基址，后进行变址。来进行寻址。EA = (IX) + ((BR)+A)。具体思路就是，A还是存的数组初始地址a[0]，基址寻址+A为上面图中的变址寻址的位置，然后再加上IX的偏移量，就可以得到a的数组后面的数据。</p><h3 id="相对寻址-偏移寻址"><a href="#相对寻址-偏移寻址" class="headerlink" title="相对寻址-偏移寻址"></a>相对寻址-偏移寻址</h3><p>把<strong>程序计数器PC</strong>的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA=(PC)+A，其中<strong>A是相对于PC</strong>所指地址的<strong>位移量</strong>可正可负，<strong>补码表示</strong></p><blockquote><p>A可正可负，所以PC的偏移量可以向前也可以向后。而且如果按照一字 pc+1，那么如果A占了2字，PC就会直接+2；</p></blockquote><p>优点：操作数的地址不是固定的，他随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值，因此<strong>便于程序浮动</strong>（一段代码在程序内部的浮动），相对寻址<strong>广泛用于转移指令</strong>。</p><p>例如C语言中的 if语句，如果成功就运行一些东西，而这些东西地址不一定跟if相连。所以可以相对寻址直接跳转。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021150306322.png" alt="image-20211021150306322"></p><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><p>操作数存放在堆栈中，隐含使用堆栈指针（SP）作为操作数地址。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021154430575.png" alt="image-20211021154430575"></p><p>当前指针指向01，假如进行一个加法操作。R1先出栈进入ACC中，Sp+1，指向R2，R2再出栈。与ACC中的数据进行增加。然后将加出来的结果再入栈</p><ul><li><p>硬堆栈：在硬件中弄一个专用的寄存器</p></li><li><p>软堆栈：在主存中用一部分地址来作为堆栈（缺点是每次操作需要访存，硬堆栈不用）</p></li></ul><h2 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h2><p><strong>CISC:Complex Instruction Set Computer</strong></p><p>设计思路：一条指令完成一个复杂的基本功能（x86架构，主要用于笔记本，台式机）</p><p>例如可以设计一套整数，矩阵的加减乘运算。</p><p>一条指令由一个专门的电路完成</p><p><strong>RISC:Reduced Instruction Set Computer</strong></p><p>设计思路：一条指令完成一个基本 “动作”；多条指令组合完成一个复杂的基本功能（ARM架构，主要用于手机，平板）</p><p>只提供整数的加减乘指令，一条指令一个电路，电路设计相对简单，功耗更低。“并行”，“流水线”</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211021155326300.png" alt="image-20211021155326300"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-第三章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020085556746.png" alt="image-20211020085556746"></p><p>主存带宽（Bm）：<strong>又称数据传输率</strong>，表示每秒从主存进出信息的最大数量，单位为 字/秒，字节/秒（B/s)或位/秒(b/s)</p><h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020090432859.png" alt="image-20211020090432859"></p><p>这里的原理是：8个存储元组成一个字节，当红色总线为高电平时，所有mos管导通，使其数据导出到绿色线，导入MDR</p><p><strong>存储芯片基本结构</strong></p><p>片选线：CS或CE（高电平有效，如果画一横就是低电平有效）</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020090643045.png" alt="image-20211020090643045"></p><p><strong>寻址</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020090910640.png" alt="image-20211020090910640"></p><p>如图4位一个字，如果按字寻址，第一个字偏移量0，第二个字左移两位就到了偏移量为4的位置</p><blockquote><p>还可按字节，半字，双字寻址</p></blockquote><h2 id="SRAM和DRAM"><a href="#SRAM和DRAM" class="headerlink" title="SRAM和DRAM"></a>SRAM和DRAM</h2><ul><li><p>DRAM用于主存，使用<strong>栅极电容</strong>存储信息</p><p>因为是电容放电信息被破坏才能读出（<strong>破坏性读出</strong>），读出后应有<strong>重写</strong>操作，也称“再生”。读写速度慢</p></li><li><p>SRAM用于Cache，使用<strong>双稳态触发器</strong>存储信息</p><p>读出数据，触发器状态保持稳定，是<strong>非破坏性读出，无须重写</strong>。读写速度快</p></li></ul><p><strong>双稳态触发器</strong></p><p>1：A高B低（输入1）</p><p>0：A低B高</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020094741786.png" alt="image-20211020094741786"></p><h3 id="DRMA刷新"><a href="#DRMA刷新" class="headerlink" title="DRMA刷新"></a>DRMA刷新</h3><p>刷新周期：一般2ms</p><p>以行为单位，每次刷新一行存储单元。用行列地址减少选通线的数量</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020095731169.png" alt="image-20211020095731169"></p><p>每次刷新一个存储单元，通过选中一行选中一列，来选中存储单元（必须行列都选中）。然后进行刷新（其中行列地址线可以共用，所以只需要一半的线路，芯片引脚数目也减少）</p><p>刷新思路</p><ul><li>分散刷新：每次读写完都刷新一行，系统存取时间变为1us，前半时间用于正常读写，后半用于刷新</li><li>集中刷新：2ms内几种安排时间全部刷新，存取周期0.5us，有一段时间专用与刷新，无法访问存储器，称为访存“死区”</li><li>异步刷新：2ms内每行刷新一次即可，2ms内需要产生128次刷新请求，每隔2ms/128=15.6us一次。每15.6us内有0.5us的 “死时间”</li></ul><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>MROM（Mask Read-Only Memory)—掩模式制度存储器（<strong>任何人不可重写）</strong></p><p>PROM（Programmable Read-Only Memory)–可编程只读存储器，<strong>写一次之后不可更改</strong></p><p>EPROM（Erasable Programmable Read-Only Memory）—-可擦除可编程只读存储器<strong>可进行多次重写</strong></p><p>Flash Memory—-闪速存储器（注：u盘，sd卡），<strong>可进行多次快速擦除重写，闪存的 写速度，比读速度慢</strong></p><p>SSD====固态  控制单元+FLASH芯片</p><p>ROM芯片：虽然名字为Read—Only，但很多ROM也可以“写”，ROM也具有“随机存取”的特性</p><blockquote><p>其中BIOS也是ROM，CPU将其和主存统一编址。所以有时主存也包括 内存条+BIOS</p></blockquote><h2 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h2><p>上面这张图中，就是译码器，控制电路与主存的连接。下面的图是整体结构。其中读写控制线（WE/WR，还是一样有一横为低电平有效反之高电平有效）</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020090643045.png" alt="image-20211020090643045"></p><h3 id="增加主存的存储字长-位扩展"><a href="#增加主存的存储字长-位扩展" class="headerlink" title="增加主存的存储字长-位扩展"></a>增加主存的存储字长-位扩展</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020105422663.png" alt="image-20211020105422663"></p><p>具体是扩展数据总线连接的芯片。这里只有两个芯片分别连接 D0，D1，还空出来2-7，可以再增加几个芯片进行位扩展。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020105603876.png" alt="image-20211020105603876"></p><p>8片 8k<em>1位的存储芯片—–&gt;变为1位 8k\</em>8位的存储器，容量8KB</p><h3 id="增加主存的存储字数-字扩展"><a href="#增加主存的存储字数-字扩展" class="headerlink" title="增加主存的存储字数-字扩展"></a>增加主存的存储字数-字扩展</h3><p><strong>线选法</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020110033811.png" alt="image-20211020110033811"></p><p>数据总线的位置每个芯片已经包含了所有。地址总线A13-15并没有进行使用。</p><p>其中第一块芯片和第二块芯片连接A13。其中第二块的线位置进行了一次取反（不取反会两个芯片都为1/0，在数据总线位置会发生冲突，取反后两个接收信号不相同，避免冲突）</p><p><strong>译码片选法</strong></p><p>先对译码器进行解释</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020111036953.png" alt="image-20211020111036953"></p><p>整体图</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020111110530.png" alt="image-20211020111110530"></p><table><thead><tr><th>线选法</th><th>译码片选法</th></tr></thead><tbody><tr><td>n条线–&gt;n个选片信号</td><td>n条线–&gt;2^n个选片信号</td></tr><tr><td>电路简单</td><td>电路复杂</td></tr><tr><td>地址空间不连续</td><td>地址空间可连续，可增加逻辑设计</td></tr></tbody></table><h3 id="字位同时扩展"><a href="#字位同时扩展" class="headerlink" title="字位同时扩展"></a>字位同时扩展</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020111319651.png" alt="image-20211020111319651"></p><p>拿红色框起来的两个芯片来说，两个芯片数据线分别占CPU数据线的一半，字扩展的线两个芯片公用同一条线，进行同时计算</p><h2 id="双口RAM多模块存储器"><a href="#双口RAM多模块存储器" class="headerlink" title="双口RAM多模块存储器"></a>双口RAM多模块存储器</h2><p><strong>存取周期=存取时间+恢复时间</strong></p><h3 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020131704983.png" alt="image-20211020131704983"></p><h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><p>可分为  单体多字存储器，多体并行存储器（又分为高位交叉编址存储器 和 低位交叉编址存储器）</p><p>其中单体多字存储器，如果要读两行不同的数据，需要读两次。而多体并行存储器，只需要一次就可以解决</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020131946454.png" alt="image-20211020131946454"></p><p><strong>高位编址，低位编址存储器</strong></p><p>下面的高位和低位存储器。每个四个内存条。</p><p>高位编址中，每个内存条是连续编址，所以如果访问连续的数据(在一个内存条内)，则需要存取时间+恢复时间进行完之后，才能继续访问下一个。所以需要5T的时间才能访问5个。</p><p>低位编址中，地址按照从左到右的连续编址，连续的地址在不同内存条中，访问连续的地址，只需要存取时间进行访问，在其中一个内存条在恢复时间的时候，另一个内存条可以继续进行读取。具体如下图。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020132451927.png" alt="image-20211020132451927"></p><blockquote><p>在低位存储中，应设置 模块数m&lt;=T/r，可以充分利用资源</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020133111990.png" alt="image-20211020133111990"></p></blockquote><h2 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h2><p>因为主存和CPU速度差距过大，Cache是用来过度的，且成本大，一个Cache不会特别大。</p><h3 id="Cache工作原理"><a href="#Cache工作原理" class="headerlink" title="Cache工作原理"></a>Cache工作原理</h3><p>当一个应用启动，会将数据代码等文件从辅存读入主存。而Cache会将主存使用的数据放到Cache中，加速读取的速度。</p><p>局部性原理</p><ul><li>空间局部性：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在<strong>存储空间上是邻近</strong>的（数据元素，顺序执行的指令代码）</li><li>时间局部性：在最近的未来要用到的信息，很可能是<strong>现在正在使用的信息</strong>（循环结构的指令代码）</li></ul><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a><strong>性能分析</strong></h3><p>分为两种情况，一种是先查Cache中是否有这个信息。另一种是Cache和主存一起查找，如果Cache中查到了，则马上停止主存的查找信息，未查找到，则主存继续查找。后一种的速度更快</p><p>命中率H，缺失（未命中）率M=1-H，Tc访问Cache耗时，Tm访问主存耗时，则访问时间 </p><ul><li><p>非同时的情况  t=HTc = (1-H)(Tc+Tm)</p></li><li><p>同时的情况    t=HTc+ (1-H)Tm</p></li></ul><h3 id="Cache存储"><a href="#Cache存储" class="headerlink" title="Cache存储"></a>Cache存储</h3><p>Cache存储是按照分块进行处理的。主存和Cache之间以 “块”为单位进行数据交换，例如1KB为一块。按照  （块号+块内地址）为一块</p><p>一个块 也称为一个 页/页面/页框，Cache中的“块”也称为 “行”</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020142600459.png" alt="image-20211020142600459"></p><h3 id="主存和Cache的映射方式"><a href="#主存和Cache的映射方式" class="headerlink" title="主存和Cache的映射方式"></a>主存和Cache的映射方式</h3><p>全部相联映射，直接映射，组相联映射</p><p><strong>全相联映射</strong></p><p>访存的流程</p><ul><li>主存地址的 块号对比Cache中的标记</li><li>如果标记匹配，且有效位为1，则Cache命中，访问块内地址。</li><li>如果未命中或者有效位为0，则正常访问主存</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020143617157.png" alt="image-20211020143617157"></p><p><strong>直接映射</strong></p><p>取块号后三位，或者主存块号%Cache总块数，可以得到Cache 的位置，存放在这个位置。但是如果这个位置已经存储了信息，则直接替换（下一节会介绍）。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020143914950.png" alt="image-20211020143914950"></p><p><strong>组相联映射</strong></p><p>所属分组=主存块号%分组数，相当于 块号取最后两位数。而其中确定组之后，组内存储可以像全相联映射一样，随便存储。</p><p>这里分为4组，两块一组。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211020144257335.png" alt="image-20211020144257335"></p><h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h3><ul><li><p>随机算法（RAND）：随机的确定替换的Cache块。实现简单，但没有依据程序访问的局部性原理，可能命中率较低</p></li><li><p>先进先出算法（FIFO）：选择最早调入的行进行替换。比较容易实现，没有依据程序访问的局部性原理，可能会把一下需要经常使用的程序块（如循环程序）也作为最早进入Cache的块替换掉</p></li><li><p><strong>近期最少使用算法（LRU）</strong>：依据程序访问的局部性原理，选择近期内最长久未访问过的存储行作为替换的行，平均命中率比FIFO高，是堆栈类算法）</p><p>具体思路：对每行设置一个计数器，Cache命中一次，把命中的计数器置为0，其他的块每个计数器+1。需要替换时就把最大计数器的块替换</p></li><li><p>最不经常使用算法（LFU）：将一段时间内被访问次数最少的存储行换出。每行设置一个计数器，新行建立后从0开始计数，被访问的行计数器+1。需要替换时，最小计数器的行被替换。</p><blockquote><p>这个算法的问题是，假如微信视频，一段时间内一直使用。但是未来不一定会使用这个。在很长一段时间就会导致块没被访问</p></blockquote></li></ul><p>使用最多的也就是LRU算法。如果是 直接映射，就直接进行替换。不需要使用上面的算法</p><h3 id="Cache-写策略"><a href="#Cache-写策略" class="headerlink" title="Cache 写策略"></a>Cache 写策略</h3><p>分为 写命中的情况和未命中的情况</p><ul><li><p>写命中</p><ul><li><p>全写法（写直通法）</p><p>当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲（访存次数增加，速度变慢，但能保证数据一致性）</p><blockquote><p>使用写缓冲，CPU写的速度很快，若写操作不频繁，则效果很好。若写操作很频繁，可能会因为写缓冲饱和而发生阻塞</p></blockquote></li><li><p>写回法</p><p>当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时，才写回主存（存在数据不一致的隐患）</p></li></ul></li><li><p>写不命中</p><ul><li><p>写分配法</p><p>当CPU对Cache<strong>写不命中时</strong>，把主存中的块调入Cache，在Cache中修改。通常<strong>搭配写回法</strong>使用</p></li><li><p>非写分配法</p><p>当CPU对Cache<strong>写不命中</strong>时只写入主存，不调入Cache，搭配全写法使用</p></li></ul></li></ul><p>多级Cache：现代计算机通常采用多级Cache结构，各级Cache间常采用“全写法+非写分配法” ， Cache和主存间采用 “写回法+写分配法”</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-第二章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018081735509.png" alt="image-20211018081735509"></p><h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><h3 id="8421（加法）"><a href="#8421（加法）" class="headerlink" title="8421（加法）"></a>8421（加法）</h3><blockquote><p><strong>加法超过1-9的表示范围需要加6来表示</strong></p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018082549357.png" alt="image-20211018082549357"></p><h3 id="余3码"><a href="#余3码" class="headerlink" title="余3码"></a>余3码</h3><p><strong>在8421码基础上加上一个3</strong></p><h3 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h3><p>2421分别为每一位的权值，表示0-4时最高位为0，5-9时最高位为1</p><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018083836835.png" alt="image-20211018083836835"></p><h2 id="汉字的表示和编码"><a href="#汉字的表示和编码" class="headerlink" title="汉字的表示和编码"></a>汉字的表示和编码</h2><p><strong>GB2312-80</strong></p><p>+80H为了高位为1，与ASCII码进行区分</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018084425246.png" alt="image-20211018084425246"></p><p><strong>输入：输入编码</strong></p><p><strong>输出：汉字字形码</strong></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>大端模式：将数据的最高有效字节存放在低地址单元中</p><p>小端模式：将数据的最高有效字节存放在高地址单元中</p><p>字符串：计算机按字节编址，以 “\0” 结尾，在所有计算机中，<strong>多字节数据</strong>都被<strong>存放在连续的字节序列中</strong></p><p>例如 “abc啊”，B0H A1H表示为啊，这里是大端模式</p><table><thead><tr><th>61H</th><th>62H</th><th>63H</th><th>B0H</th><th>A1H</th><th>00H</th></tr></thead></table><h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><p>原理</p><p>若干位代码组成的一个字叫<strong>码字</strong>，将两个码字逐位进行对比，具有不同的位的个数称为<strong>两个码字j间的距离</strong>，各合法码字间的最小距离称为<strong>码距（d）</strong></p><p>d=1时，无检错能力。d=2时，有检错能力。d&gt;=3时，设计合理，可能具有检错纠错能力</p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>奇校验码：整个校验码（有效信息位和校验位）中”1“的个数为奇数，偶校验码类似</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018091039245.png" alt="image-20211018091039245"></p><p>例：奇校验，给出1001101和1010111的两个二进制数</p><p>设最高位是校验位，7位是信息位。1001101—&gt;<strong>1</strong>1001101，1010111—-&gt;<strong>0</strong>1010111。也就是用校验位保证为1为奇数个，当发送数据时，如果发生数据跳变，其中一个位变化，就会变成偶数个，就可以看到是否有出错。</p><blockquote><p>但是如果有偶数个bit发生跳变，是无法发现错误</p></blockquote><p>计算机中的实现，各信息进行异或，算出是否需要校验位。如下</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018091638976.png" alt="image-20211018091638976"></p><h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><p>思路：将信息位分组进行偶校验，将数据进行分组，每个分组都设置校验位，多个校验位标注出错位置</p><p>其中分组按照2的n次方来计算的。四位是2的3次方，所以分为3个组。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018094018035.png" alt="image-20211018094018035"></p><p>校验原理是：按照数据存放的位置，例如H3（011）其中两个1，对应1位和2位，所以与校验码 p1,p2进行对应</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018095035901.png" alt="image-20211018095035901"></p><p>数据存放方法，上面为从大到小。如下是从小到大</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018094218710.png" alt="image-20211018094218710"></p><blockquote><p>补充</p><p>无法确定是一位出错还是两位出错，如果p1,p2同时出错，就为110，但是实际不是那个位置出错。</p><p>所以需要加上<strong>全校验位</strong>，也就是在加上一个最高位为全校验位，进行偶校验。</p><p>000=无错误</p><p>不为000就代表有错误，如果校验失败，就纠错。</p><p>如果校验成功，有两位错，需重传。</p></blockquote><h3 id="CRC码（循环冗余校验码）"><a href="#CRC码（循环冗余校验码）" class="headerlink" title="CRC码（循环冗余校验码）"></a>CRC码（循环冗余校验码）</h3><p>基本思想：数据接收方和发送方约定一个 ”<strong>除数</strong>“，且给   k个信息位+R个校验位作为 ”<strong>被除数</strong>“，添加校验位后<strong>保证除法的余数为0</strong>。</p><p>收到数据后，进行除法检查余数是否为0，如果为0是为出错，非0表示出错。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018103751182.png" alt="image-20211018103751182"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018103910642.png" alt="image-20211018103910642"></p><blockquote><p>这里010表示C2出错，是有依据的。但是也不完全正确。如果2^R &gt;= K+R+1，则CRC码可纠错一位的错误。如果不是，则010可能不是表示2的位置，也可能表示9（按照上题）</p><p>001001 001，余数为010，实际是9位出错。101001 011 余数010 ，2位出错。</p></blockquote><h2 id="定点数的表示"><a href="#定点数的表示" class="headerlink" title="定点数的表示"></a>定点数的表示</h2><p>定点数：小数点的位置固定    996.007</p><p>浮点数：小数点的位置不固定    9.96007*10^3</p><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><blockquote><p>无符号数通常只表示整数</p></blockquote><p>所有位数都是数值，没有符号位。N位无符号数表示范围：0-2^(n-1)</p><h3 id="有符号数的定点表示"><a href="#有符号数的定点表示" class="headerlink" title="有符号数的定点表示"></a>有符号数的定点表示</h3><blockquote><p>0有+0和-0</p></blockquote><p>正（0）负（1）</p><p>可用<strong>原码，补码，反码</strong>三种方式来表示定点整数和定点小数。还可用<strong>移码</strong>表示定点整数</p><p>若真值为x，则用[x]原，[x]反，[x]补，[x]移分别表示真值所对应的原码反码……</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018104904524.png" alt="image-20211018104904524"></p><p><strong>原码整数</strong>的表示范围：-(2^n-1) &lt;= x &lt;= 2^n-1</p><p><strong>原码小数</strong>的表示范围：-(1-2^-n) &lt;= x &lt;= 1-2^-n</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><blockquote><p>0有+0和-0</p></blockquote><p>若符号位为0，则反码与原码相同</p><p>若符号位为1，则数值位全部取反</p><p>表示范围与原码的表示范围一致</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>补码：解决计算机中的减法操作。两个原码相减，将减数转为补码，就可以转为加法运算。</p><p>正数的补码=原码。负数的补码=反码末位+1（要考虑进位）</p><blockquote><p>补码的真值0只有一种表示形式</p><p><strong>原码补码相互转换方法一样</strong></p></blockquote><p>表示范围</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018110254156.png" alt="image-20211018110254156"></p><h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><p>补码的基础上将符号位取反。或者移码=真值+偏置值（计算机中的设定）<strong>移码只能用于整数</strong></p><p>表示范围与补码一致</p><p>移码作用：移码表示的整数很方便对比大小</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><p>通过改变各个数码位的小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法，除法</p><h5 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h5><p><strong>原码的算数移位</strong>—-符号位保持不变，仅对数值位进行移位</p><p>右移：高位补0，低位舍弃。若舍弃的位=0，相当于 /2 ；舍弃的位不为0，则会丢失精度</p><p>左移：低位补0，高位舍弃。舍弃的位=0，相当于*2。舍弃的位不为0，会出现<strong>严重误差</strong></p><p>反码算数移位</p><ul><li>正数高位为0，与原码移位一样。补0</li><li>负数高位为1，高位低位补1。</li></ul><p>补码算数移位</p><ul><li>正数与原码相同</li><li>负数：最右边的1的右边，用原码的规律。最右边的1的左边，用反码的规律<ul><li>右移（同反码）：高位补1，低位舍弃</li><li>左移（同原码）：低位补0，高位舍弃</li></ul></li></ul><h5 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h5><p>可以看作对无符号数的移位，右移,高位补0，低位舍弃。左移，低位补0，高位舍弃</p><h5 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h5><p>例如左移，会把移出去的那移位，放到最末位。右移类似</p><p>带  进位  位的循环左移：</p><p>例：有8bit位的数值，在前面再加一个位。当左移的时候，将最高位放到进位 位。将进位 位的数值放到末位。</p><h4 id="加减运算"><a href="#加减运算" class="headerlink" title="加减运算"></a>加减运算</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018143143114.png" alt="image-20211018143143114"></p><p>原码进行加减需要太多机制，而且可能会出错。所以用补码进行加减运算。<strong>补码运算如下</strong></p><p>例：A=15,B=-24</p><p>[A+B]补=[A]补+[B]补=0,0001111+1,1101000=1,1110111（再转换为原码）</p><p>[A-B]补=[A]补+[-B]补=0,0001111+1,0011000=0,0100111（转换原码即可）</p><p>其中A-B 那里是将B进行按位取反再+1。也就是转为补码的补码（这里要连同符号位）</p><h4 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h4><blockquote><p>双符号位补码又称：模4补码</p><p>单符号位补码又称：模2补码</p></blockquote><p>正+正=负（上溢）</p><p>负+负=正（下溢）</p><p><strong>方法一</strong></p><p>采用一位符号位。设A的符号为As,B的符号为Bs，运算结果的符号为Ss,则溢出逻辑表达式为<img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018141531037.png" alt="image-20211018141531037"></p><p>若V=0，表示无溢出，反之溢出</p><p>例：A=15,C=124</p><p>A+C=0,0001111+0,1111100=1,0001011  等于-117 肯定溢出了</p><p>其中计算时   A的符号位0，C符号位0，S符号位1。进行计算。V=000+111=1(溢出)</p><p><strong>方法二</strong></p><p>采用一符号位，根据数据位进位情况判断溢出，符号位的进位Cs，最高数值位的进位C1</p><table><thead><tr><th></th><th>Cs</th><th>C1</th></tr></thead><tbody><tr><td>上溢</td><td>0</td><td>1</td></tr><tr><td>下溢</td><td>1</td><td>0</td></tr></tbody></table><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018142104328.png" alt="image-20211018142104328"></p><p><strong>方法三</strong></p><blockquote><p>双符号位，实际存储只存储1个符号位，运算时会复制一个符号位</p></blockquote><p>采用双符号位，正数符号为00，负数符号为11</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018142256958.png" alt="image-20211018142256958"></p><h4 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a><strong>符号扩展</strong></h4><p>8位—》16位</p><p>整数在最高位前面补数字，原码补0反码补码补1。小数就是在后面补0/1，反码补1，原码补码补0</p><h4 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h4><p>直接上实例。其中X和MQ中存的是他们的<strong>绝对值</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018144552008.png" alt="image-20211018144552008"></p><p>这里已经是算完的状态，也就是已经都移位完了。如果没有算的状态，ACC里面是全0的状态，每次取灰色的位置，乘以X，放入ACC，然后MQ和ACC统一逻辑右移移位。移到最后一位就可以不用进行运算(灰色的0不参与)。然后进行异或符号，放入最高位的位置。</p><h4 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h4><p>进行n+1轮加法，移位。每次加法可能是 +0，+[x]补，+[-x]补。且每次移位是补码的<strong>算数右移</strong>，符号位参与运算（原码使用的是绝对值，符号位不参加运算）</p><p>红色的为辅助位，X位置的辅助位是双符号位。算法与原码类似。</p><p><strong>有一点不同的是，+0，+[x]补，+[-x]补。具体实现是，辅助位-最低位获得的数字。为0，1，-1来进行对应</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018145357424.png" alt="image-20211018145357424"></p><h4 id="原码除法"><a href="#原码除法" class="headerlink" title="原码除法"></a>原码除法</h4><p><strong>恢复余数法</strong></p><p>ACC初始存被除数，当计算开始后存相减之后的余数。</p><p>计算方法：<strong>因为计算机不会判断大小，他会先取1进MQ的位置，然后让 ACC-除数，如果算出来的数字出错（符号位为1），就会将减掉的数字再加上去，将MQ的低位换为0。然后进行逻辑左移右边补0，ACC移出去的数字丢弃。</strong>最后得到的商在MQ中，余数在ACC中，但是余数需要乘以 2^-n次方才是最终余数。然后符号位异或</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018150955305.png" alt="image-20211018150955305"></p><p><strong>加减交替法</strong></p><p>和恢复余数法很类似，但是优化了其中的过程。具体如下，<strong>但当最后余数为负，则需商0，并+[Y]补得到正确的余数</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211018152409858.png" alt="image-20211018152409858"></p><h4 id="补码除法"><a href="#补码除法" class="headerlink" title="补码除法"></a>补码除法</h4><p>符号位参与运算，被除数/余数，除数，采用双符号位</p><p>余数和除数<strong>同号</strong>，商<strong>1</strong>，<strong>余数左移一位减去除数</strong></p><p>余数和除数异号，商<strong>0</strong>，<strong>余数左移一位加上除数</strong></p><blockquote><p>最后结果，需要末位恒置为1。精度误差不超过2^(-n)</p></blockquote><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>无符号数与有符号数：不改变数据内容，改变解释方式</p><p>都是补码的形式。长整数变短整数，高位截断保留低位。</p><p>例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> x = <span class="number">-4321</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> y = (<span class="keyword">unsigned</span> <span class="keyword">short</span>)x;</span><br><span class="line"><span class="comment">// x=1110 1111 0001 1111（-4321）   y=1110 1111 0001 1111 （61215）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = x;</span><br><span class="line"><span class="comment">//m=1111 1111 1111 1111 1110 1111 0001 1111(-4321)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">165537</span>;</span><br><span class="line"><span class="keyword">short</span> c=(<span class="keyword">short</span>)a;</span><br><span class="line"><span class="comment">//a=0x000286a1(61215) , c=0x86a1(-31071)</span></span><br></pre></td></tr></table></figure><h3 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h3><p>大端，小端模式</p><p>大端：将数据最高位存在低位的位置（可以理解为从左往右，从大到小）</p><p>小端：将数据最低位存在低位的位置（从左往右，从左到大，主要是为了理解，实际并不一定是从左往右）</p><p><strong>边界模式</strong></p><p>现代计算机通常字节编址，每个字节对应一个地址。通常按字，半字，字节寻址。如下图</p><blockquote><p>注：其中填充是因为要边界对齐</p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211019115407404.png" alt="image-20211019115407404"></p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点数的真值：N=r^e * M，r通常为2和2的倍数，M为尾数</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211019130619281.png" alt="image-20211019130619281"></p><p>例：</p><p>a=0,01;1.1001     b=0,10;0.01001</p><p>a的表示为：00111001。但是b的表示 有9位，超出了8bit。所以需要进行规格化</p><p>b的尾数是0.01001，将小数点后面的0去掉，左移1。使小数点第一位是1。最后面补0（如果满了就不用管）。得到01001001。</p><p><strong>规格化</strong></p><p>规定<strong>尾数的最高数值位必须是一个有效值</strong></p><p><strong>左规：</strong>当浮点数运算的结果为非规格化时要进行规格化处理，将<strong>尾数算数左移移位，阶码减1</strong></p><p><strong>右规：</strong>当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将<strong>尾数算数右移一位，阶码加1</strong></p><blockquote><p>采用双符号位，当溢出发生时，可以挽救。更高的符号位是正确的符号位。</p><p>右规的情况，例如两个数字相加  出现了符号位两个数字不同。就是溢出，所以需要纠正</p></blockquote><p>用原码表示的尾数进行规格化</p><ul><li>正数为0.1xxxx（小数点后第一位需要为1，如果是0就丢弃然后左移，直到有1），则其最大值表示为0.11……1；最小值表示为0.10…….0。尾数的表示范围为  1/2 &lt;=M&lt;=(1-2^(-n))</li><li>负数为1.1xxx，其最大值为1.10….0；最小值为1.11…..1。尾数表示范围为  -(1-2^(-n)) &lt;=M&lt;= -1/2</li></ul><p>用补码表示的尾数进行规格化</p><ul><li>正数为0.1xxx，其最大值表示为0.1….1；最小值为0.10….0。尾数表示范围 1/2 &lt;=M&lt;=(1-2^(-n))</li><li>负数为1.0xxx，其最大值表示为1.01….1（这里小数点后面需要一个1，然后才是1）；最小值为1.0…0。尾数的表示范围 -1&lt;= M &lt;= -(1/2+2^(-n))</li></ul><h3 id="IEEE754"><a href="#IEEE754" class="headerlink" title="IEEE754"></a>IEEE754</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211019142430106.png" alt="image-20211019142430106"></p><blockquote><p>阶码全0，全1用作特殊用途</p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211019142524479.png" alt="image-20211019142524479"></p><p>由浮点数确定真值（阶码不是全0和全1）</p><ol><li>根据 “某浮点数” 确定数符，阶码，尾数的分布</li><li>确定尾数1.M（需要补充最高的隐含位1）</li><li>确定阶码的  真值 = 移码-偏置值</li><li>(-1)^s * 1.M = 2^(E-偏置值)</li></ol><p>最小绝对值：尾数全为0，阶码真值最小 -126，对应移码机器数0000 0001，整体的真值为 (1.0) * 2^(-126)</p><p>最大绝对值：尾数全为1，阶码真值最大127，对应移码机器数为1111 1110，整体真值为 (1.11….11) * 2^127</p><p>特殊的：</p><p>当<strong>阶码全为0</strong></p><ul><li>尾数不全为0时，表示<strong>非规格化小数</strong>  ±(0.xx.xxxx)+2^(-126)</li><li>尾数全为0时，表示<strong>真值 ±0</strong></li></ul><p><strong>当阶码全为1</strong></p><ul><li>尾数全为0，表示 <strong>±无穷</strong></li><li>尾数不全为0，表示<strong>非数值 “NaN”</strong></li></ul><h4 id="浮点数加减运算"><a href="#浮点数加减运算" class="headerlink" title="浮点数加减运算"></a>浮点数加减运算</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211019150600241.png" alt="image-20211019150600241"></p><p><strong>舍入</strong></p><p><strong>“0” 舍 “1” 入法：</strong>在尾数右移时，被移去的最高数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1.（但是可能会让尾数溢出，需要再做右规）</p><p><strong>恒置 ”1“ 法：</strong>尾数右移时，不论丢掉的最高数值位是 ”1“ 还是 “0” 都使右移后的尾数末位恒置 “1”，（可能会使尾数变大或变小）</p><h3 id="浮点数参与的强制类型转换"><a href="#浮点数参与的强制类型转换" class="headerlink" title="浮点数参与的强制类型转换"></a>浮点数参与的强制类型转换</h3><p>char-&gt; int -&gt; long -&gt; double（long32位时无精度丢失，但如果long是64位时转到double会有精度丢失）</p><p>32位</p><p>int：表示整数，范围是 -2^31—2^(31-1)，有效数字32位</p><p>float：表示整数及小数，范围 [ 2^(-126)—— 2^127(2-2^(-23)) ]</p><p>如果是int转float肯定会有精度丢失，因为int有31个数值位，float只有24个尾数位。float转int一样会有精度丢失，int会把小数点之后的数字丢失。</p><h2 id="算数逻辑单元ALU"><a href="#算数逻辑单元ALU" class="headerlink" title="算数逻辑单元ALU"></a>算数逻辑单元ALU</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211019163305455.png" alt="image-20211019163305455"></p><h3 id="一位全加器"><a href="#一位全加器" class="headerlink" title="一位全加器"></a>一位全加器</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211019172231738.png" alt="image-20211019172231738"></p><h3 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211019172429386.png" alt="image-20211019172429386"></p><p>进位触发器存放进位的值，每次运算的时候将进位的值加进去运算（0/1）</p><p>只有一个全加器，数据逐位串行送入加法器中jji进行运算。进位触发器用来寄存进位信号，以便下一次运算（操作数为n，那么就要加n次）</p><h3 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211019172636212.png" alt="image-20211019172636212"></p><p><strong>串行进位的并行加法器</strong>：把n个全加器串接起来，就可以j进行两个n位数的相加。不过，虽然输入可以n个进行输入，但是还是要等低位的进行运算，然后将进位送到下一个运算器，才能进行下一次计算。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-第一章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211014153140336.png" alt="image-20211014153140336"></p><h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211014154114854.png" alt="image-20211014154114854"></p><h3 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211014160713514.png" alt="image-20211014160713514"></p><ul><li>MAR：地址寄存器，MDR：数据寄存器</li><li><strong>存储单元</strong>：每个存储单元存放一串二进制代码</li><li><strong>存储字</strong>（word）：存储单元中二进制代码的组合</li><li><strong>存储字长</strong>：存储单元中二进制代码的位数</li><li>存储元：存储二进制的电子元件，每个存储元可存1bit</li></ul><h3 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211014161045566.png" alt="image-20211014161045566"></p><ul><li>ACC：累加器，用于存放操作数，或运算结果</li><li>MQ：乘商寄存器，在乘，除运算时，用于存放操作数或运算结果</li><li>X：通用的操作数寄存器，用于存放操作数</li><li><strong>ALU</strong>：算术逻辑单元，通过内部复杂的电路实现算数运算，逻辑运算</li></ul><h3 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211014161512386.png" alt="image-20211014161512386"></p><ul><li><strong>CU：</strong>控制单元，分析指令，给出控制信号</li><li>IR：指令寄存器，存放当前执行的指令</li><li>PC：程序计数器，存放下一条指令地址，有自动加1功能</li></ul><p>取指令（PC）—-&gt;分析指令（IR）—-&gt;执行指令(CU)</p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>初始：指令，数据存入主存，PC指向第一条指令。从主存中取指令放入IR，PC自动加1，CU分析指令，CU指挥其他部件执行指令</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211014163156292.png" alt="image-20211014163156292"></p><h3 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211014170343989.png" alt="image-20211014170343989"></p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211014172800820.png" alt="image-20211014172800820"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(自顶向下)第六章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="链路层和局域网"><a href="#链路层和局域网" class="headerlink" title="链路层和局域网"></a>链路层和局域网</h2><blockquote><p>网络层解决一个网络到达另一个网络的路由问题</p><p>链路层：网络内部如何由一个节点（主机或路由器）到达另一个相邻节。（点到点连接，多点连接）</p><p>wan：网络形式采用点到点链路</p><p>LAN：一般采用多点连接方式</p></blockquote><h3 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h3><p>术语</p><ul><li>主机和路由器：nodes（节点）</li><li>沿着通信路径，连接相邻节点通信信道的是<strong>链路</strong>：links（无线，有线，局域网，共享性链路）</li><li>第二层协议数据单元帧frame，封装数据报</li></ul><blockquote><p><strong>数据链路层负责从一个节点通过链路将数据报发送到相邻的物理节点</strong></p></blockquote><p><strong>链路层：上下文</strong></p><p>数据报在不同链路上以不同的链路协议传送：</p><ol><li>第一跳：以太网</li><li>中间链路：帧中继链路</li><li>最后一跳：802.11</li></ol><p>传输类比</p><ul><li>从A到B<ul><li>有不同交通工具</li></ul></li><li>旅行者=数据报datagram</li><li>交通段=通信链路communication link</li><li>交通模式=链路层协议：数据链路层和局域网protocol</li><li>票务代理=路由算法routing algorithm</li></ul><p><strong>链路层服务</strong></p><p>流量控制，错误检测，差错纠正，半双工和全双工</p><p>成帧，链路接入：</p><ul><li><p>将数据报封装在帧中，加上帧头、帧尾部</p></li><li><p>如果采用的是共享性介质，信道接入获得信道访问权</p></li><li><p>在帧头部使用“MAC”（物理）地址来标示源和目的 ，不同于IP地址</p></li></ul><p><strong>相邻节点内完成可靠数据传输</strong></p><p>低差错的链路上很少使用（光纤，一些双绞线）</p><p>高差错链路上需要进行可靠数据传送（无线链路）</p><p><strong>链路层的实现位置</strong></p><ul><li><p>主机</p></li><li><p>”适配器“（aka network interface and NIC)或者在一个芯片组上</p><ul><li>以太网卡，802.11网卡，以太网芯片组</li><li>实现链路层和响应的物理层功能</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211016155954402.png" alt="image-20211016155954402"></p></li><li><p>接到主机的系统总线上</p></li><li><p>硬件，软件，固件的综合体</p></li></ul><h3 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h3><p>EDC=差错检测和纠正位（冗余位），D =数据由差错检测保护，可以包含头部字段</p><blockquote><p>错误检测不是100%可靠，会漏检一些错误，但是错误更少。更长的EDC字段可以得到更好的检测和纠正效果</p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017092217140.png" alt="image-20211017092217140"></p><p><strong>奇偶校验</strong></p><p><strong>单bit奇偶校验（检测耽搁bit级错误），2维奇偶校验（检测和纠正单个bit错误）</strong></p><p><strong>Internet校验和</strong></p><p>目标：检测在传输报文段时的错误（如位翻转）且仅用在传输层</p><p><strong>发送方</strong></p><ul><li>将报文段看成16-bit整数</li><li>报文段和校验和：和（1‘的补码和）</li><li>发送方将checksum的值放在’UDP校验和‘字段</li></ul><p><strong>接收方</strong></p><ul><li><strong>计算</strong>接收到的报文段的校验和</li><li>检查是否与携带校验和字段值一致<ul><li>不一致：有错误</li><li>一致：没有检出错误，但可能有错</li></ul></li></ul><p><strong>检验和：CRC</strong>（循环冗余校验）</p><ul><li><p>强大的差错检测码</p></li><li><p>将数据比特 D, 看成是二进制的数据</p></li><li><p>生成多项式G：双方协商r+1位模式（r次方） ，生成和检查所使用的位模式</p></li></ul><p>目标：选择r位 CRC附加位R，使得</p><ul><li>&lt;D,R&gt;正好被G整除（modulo 2）</li><li>接收方知道G，将&lt;D,R&gt;除以G，如果非0余数：检查出错误</li><li>能检出所有少于r+1位的突发错误</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017095037279.png" alt="image-20211017095037279"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017095103093.png" alt="image-20211017095103093"></p><h3 id="多点访问协议"><a href="#多点访问协议" class="headerlink" title="多点访问协议"></a>多点访问协议</h3><p><strong>多路访问链路和协议</strong></p><ul><li>点对点（拨号访问的PPP，以太网交换机和主机间的点对点链路）</li><li>广播（共享链路或媒体）传统以太网，HFC上行链路，802.11无线局域网</li></ul><p><strong>协议</strong></p><p>单个共享的广播型链路，2个或更多的站点同时发送会<strong>冲突（collision）</strong></p><p><strong>多路访问协议（介质访问控制协议：MAC）</strong></p><p>MAC（媒体访问控制）协议：分类</p><ul><li>信道划分<ul><li>把信号分成小片（时间TDMA，频率FDMA，编码CDMA）</li><li>分配片个每个节点专用</li></ul></li><li>随机访问<ul><li>信号不划分，允许冲突</li><li>冲突后恢复</li></ul></li><li>依次轮流<ul><li>节点依次轮流</li><li>但是有很多数据传输的节点可以获得较长的信道使用权</li></ul></li></ul><h4 id="随机存取协议"><a href="#随机存取协议" class="headerlink" title="随机存取协议"></a><strong>随机存取协议</strong></h4><p>当节点有帧要发送时，以<strong>信道带宽的全部R bps</strong>发送，没有节点间的预先协调。</p><p>两个或更多节点同时传输，会发生冲突（collision）</p><p>随机存取协议规定了，如何检测冲突，如何从冲突中恢复。还有随机MAC协议（时隙ALOHA，ALOHA，CSMA，CSMA/CD，CSMA/CA）</p><h5 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h5><p>假设：所有帧是等长的，时间被划分成相等的<strong>时隙</strong>，每个时隙可发送一帧。节点只在时隙开始时发送帧，节点在时钟上是同步的，如果两个或多个节点在一个时隙传输，所有站点都能检测到冲突。</p><p>运行</p><ul><li>当节点获取心的帧，在下一个时隙传输</li><li>传输时没有检测到冲突，成功，节点能够在下一时隙发送帧</li><li>检测到冲突，失败，节点在每一个随后的时隙以概率p重传帧直到成功</li></ul><blockquote><p>优点：节点可以以信道带宽全速连续传输。高度分布，仅需要节点之间在时隙上同步。</p><p>缺点：存在冲突，浪费时隙。即使有帧要发送仍然有可能存在空闲的时隙。节点检测冲突的时间&lt;帧传输的时间。且必须传完，需要时钟同步</p></blockquote><p>最好的情况：效率利用率37%</p><h5 id="纯ALOHA（非时隙）"><a href="#纯ALOHA（非时隙）" class="headerlink" title="纯ALOHA（非时隙）"></a>纯ALOHA（非时隙）</h5><p>无时隙ALOHA：简单，无须节点间在时间上同步。当有帧需要传输：马上传输。冲突的概率增加。</p><p>效率相比时隙ALOHA更差</p><h5 id="CSMA（载波侦听多路访问）"><a href="#CSMA（载波侦听多路访问）" class="headerlink" title="CSMA（载波侦听多路访问）"></a><strong>CSMA（载波侦听多路访问）</strong></h5><p>在传输前先侦听信道，如果信道空闲，传送整个帧。信道忙，推迟传送</p><p>冲突：仍然可能发生，由传播延迟造成，两个节点可能侦听不到正在进行的传输。整个冲突帧的传输时间都被浪费，是无效传输。传播延迟决定冲突的概率。</p><h5 id="CSMA-CD（冲突检测）"><a href="#CSMA-CD（冲突检测）" class="headerlink" title="CSMA/CD（冲突检测）"></a>CSMA/CD（冲突检测）</h5><p>载波侦听CSMA：和在CSMA中一样发送前侦听信道，没有传完一个帧就可以在短时间内检测到冲突，冲突发生时则传输终止，减少对信道的浪费</p><p><strong>冲突检测CD技术</strong>，有线局域网中容易实现：检测信号强度，比较传输与接收到的信号是否相同，通过周期的过零点检测</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017103404876.png" alt="image-20211017103404876"></p><p><strong>CSMA/CD算法</strong></p><ol><li><p>适配器获取数据报，创建帧</p></li><li><p>发送前：侦听信道CS</p><p>1)闲：开始传送帧</p><p>2)忙：一直等到闲再发送</p></li><li><p>发送过程中，冲突检测CD</p><p>1)没有冲突:成功</p><p>2)检测到冲突:放弃,之后尝试重发</p></li><li><p>发送方适配器检测到冲突，除放弃外，还发送一个Jam信号，所有听到冲突的适配器也是如此</p><p><strong>强化冲突：让所有站点都知道冲突</strong></p></li><li><p>如果放弃，适配器进入指数退避状态</p><p>第m次失败后，适配器随机选择一个{ 0 到  2^(m-1) }为k，等待k*512位时间，然后转到步骤2（指数退避）</p></li></ol><p><strong>指数退避</strong></p><p>首次碰撞：在{0，1}选择K；延迟K*512位时，第2次碰撞：在{0，1，2，3}选择K，第10次碰撞：在{0，1，2，3，……，1023}选择K</p><p><strong>效率：比ALOHA更好的性能，简单，廉价，分布式</strong></p><h5 id="无线局域网：CSMA-CA"><a href="#无线局域网：CSMA-CA" class="headerlink" title="无线局域网：CSMA/CA"></a>无线局域网：CSMA/CA</h5><p><strong>发送方</strong></p><p>1 如果站点侦测到信道空闲持续**DIFS长，则传输整个帧 **(no CD)</p><p>2 如果侦测到信道忙碌，那么 选择一个随机回退值，并在信道空闲时递减该值；如果信道忙碌，回退值不会变化到数到0时（只生在信道闲时）发送整个帧如果没有收到ACK, 增加回退值，重复2</p><p><strong>802.11接收方</strong></p><p>如果帧正确，则在SIFS后发送ACK</p><p>IEEE 802.11 MAC协议：CSMA/CA</p><p>在count down时，侦听到了信道空闲为什么不发送，而要等到0时在发送</p><ul><li><p>2个站点有数据帧需要发送，第三个节点正在发送</p></li><li><p>LAN CD：让2者听完第三个节点发完，立即发送</p></li><li><p>冲突：放弃当前的发送，避免了信道的浪费于无用冲突帧的发送。代价不昂贵</p></li></ul><p>无法完全避免冲突，例如AB都要等C发送完，但是AB的值很接近。可能会冲突等等</p><p><strong>WLAN：CA</strong></p><p>无法CD，一旦发送必须发完，冲突就会导致信道浪费。</p><p><strong>冲突避免</strong></p><p>允许发送方“预约”信道，而不是随机访问该信道: 避免长数据帧的冲突（可选项）</p><ul><li><p>发送方首先使用CSMA向BS发送一个小的RTS分组，RTS可能会冲突（但是由于比较短，浪费信道较少）</p></li><li><p>BS广播 clear-to-send CTS，作为RTS的响应</p></li><li><p>CTS能够被所有涉及到的节点听到，发送方发送数据帧，其它节点抑制发送</p></li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017110306509.png" alt="image-20211017110306509"></p><h5 id="线缆接入网络"><a href="#线缆接入网络" class="headerlink" title="线缆接入网络"></a>线缆接入网络</h5><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017111405264.png" alt="image-20211017111405264"></p><p><strong><em>多个</em></strong>40Mbps 下行(广播)信道,FDM </p><p>​    下行：通过FDM分成若干信道，互联网、数字电视等 </p><p>​    互联网信道：只有1个CMTS在其上传输</p><p><strong><em>多个</em></strong>30 Mbps上行的信道,FDM </p><p>​    <strong>多路访问</strong>：所有用户使用；接着TDM分成微时隙</p><p>​    部分时隙：分配；部分时隙：竞争；</p><h4 id="轮流（Taking-Turns）MAC协议"><a href="#轮流（Taking-Turns）MAC协议" class="headerlink" title="轮流（Taking Turns）MAC协议"></a>轮流（Taking Turns）MAC协议</h4><p>信道划分MAC协议：</p><ul><li>共享信道在高负载时是有效和公平的</li><li>在低负载时效率地下，只能等到自己的时隙开始发送或者利用1/N的信道频率发送。当只有一个节点有帧传时，也只能够得到1/N个带宽分配</li></ul><p>随机访问MAC协议</p><ul><li>在低负载时效率高，单个节点完全可以利用信道全部带宽</li><li>高负载时，冲突开销较大，效率极低，时间很多浪费在冲突中</li></ul><p>轮流协议：有两者优点</p><p>轮流询问:</p><p>主节点邀请从节点依次传送，从节点一般比较 “dumb”</p><p>缺点: </p><ul><li><p>轮询开销：轮询本身消耗信道带宽 </p></li><li><p>等待时间：每个节点需等到主节点轮询后开始传输，即使只有一个节点，也需要等到轮询一周后才能够发送 </p></li><li><p>单点故障：主节点失效时造成整个系统无法工作</p></li></ul><p><strong>令牌传递</strong>: </p><p>控制令牌( token)循环从一个节点到下一个节点传递</p><p>令牌报文：特殊的帧</p><p>缺点: </p><ul><li><p>令牌开销：本身消耗带宽 </p></li><li><p>延迟：只有等到抓住令牌，才可传输 </p></li><li><p>单点故障 (token)： </p><ul><li>令牌丢失系统级故障，整个系统无法传输 </li><li>复杂机制重新生成令牌</li></ul></li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017112508792.png" alt="image-20211017112508792"></p><h3 id="LANs"><a href="#LANs" class="headerlink" title="LANs"></a>LANs</h3><h4 id="addressing，ARP"><a href="#addressing，ARP" class="headerlink" title="addressing，ARP"></a>addressing，ARP</h4><p>MAC地址和ARP</p><p>32位 bit IP地址</p><ul><li>网络层地址</li><li>前n-1跳：用于使数据报到达目的IP子网</li><li>最后一条：到达子网中的目标节点</li></ul><p>LAN（MAC/物理/以太网）地址：</p><ul><li>用于使帧从一个网卡传递到与其物理连接的另一个网卡（在同一个物理网络中）</li><li>48bit MAC地址固化在适配器的ROM，有时也可以通过软件设定，理论上全球任何一个网卡MAC都不同</li></ul><p><strong>网络地址和物理地址分离</strong></p><p>IP地址是分层的，一个子网所有站点网络号一致，路由聚集，减少路由表。IP地址完成网络到网络的交付</p><p>mac地址是平面的：网卡在生产时给一个唯一标识，用于区分一个网络内部不同的网卡即可。可以完成一个物理网络内部的节点到节点的数据交付</p><blockquote><p>局域网上每一个适配器都有一个唯一的<strong>LAN</strong>地址</p></blockquote><p>MAC地址有IEEE管理和分配，制造商购入MAC地址空间（保证唯一性），MAC地址可以进行移动，不影响IP地址，IP地址有层次，不能移动</p><p><strong>Address Rseolution Protocol（ARP)</strong></p><p>在LAN上的每个IP节点都有一个ARP表（包括一些LAN节点IP/MAC地址的映射 《IP,MAC，TTL》）</p><p>同一个网络中</p><p>A要发送帧给B，B的MAC地址不在A的ARP表中，A广播包含B的ip地址的ARP查询包，B接收到ARP包，恢复A自己的MAC地址，A在ARP中缓存B的mac地址。</p><p>不同网络中，用iP先到那个路由表，然后该地方的路由器会找到要传送的MAC地址</p><h4 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h4><p>以太网：目前最主流的LAN技术：98的占有率，最早广泛应用的LAN技术，比令牌网和ATM网络简单，廉价</p><p><strong>物理拓扑</strong></p><p>总线</p><p>星形（目前最主流），使用hub或switch，现在一般是交换机在中心。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017123355782.png" alt="image-20211017123355782"></p><p><strong>以太帧结构</strong></p><p>发送方适配器在以太网帧中封装IP数据报或其他玩路过层协议数据单元</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017123433548.png" alt="image-20211017123433548"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017123509472.png" alt="image-20211017123509472"></p><p>以太网：无连接，不可靠</p><p>无连接：帧传输前，发送方和接收方之间没有握手</p><p>不可靠：接收方适配器不发送ACKs或NAKs给发送方，递交给网络层的数据报流可能有gap</p><p>以太网的MAC协议，采用<strong>二进制退避的CSMA/CD介质访问控制形式</strong></p><p><strong>Hubs</strong></p><p>Hubs 本质上是物理层的中继器: </p><ul><li><p>从一个端口收，转发到所有其他端口</p></li><li><p>速率一致</p></li><li><p>没有帧的缓存</p></li><li><p>在hub端口上没有CSMA/CD机制:适配器检测冲突</p></li><li><p>提供网络管理功能</p></li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017124014124.png" alt="image-20211017124014124"></p><p><strong>Manchester编码</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017124149266.png" alt="image-20211017124149266"></p><p>在10BaseT中使用，每一个bit的位时中间有一个信号跳变，允许在接收方和发送方节点之间进行时钟同步</p><p><strong>100baseT使用4b5b编码</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017124326145.png" alt="image-20211017124326145"></p><p>千兆以太网</p><ul><li>采用标准的以太帧格式</li><li>允许点对点链路和共享广播信道</li><li>物理编码：8b10b编码</li><li>在共享模式，继续使用CSMA/CD MAC技术，节点间需要较短距离以提高利用率</li><li>交换模式：全双工千兆可用于点对点链路<ul><li>站点使用专用信道，基本不会冲突，除非发往同一个节点</li></ul></li><li>10 Gbps</li></ul><h4 id="802-11-WLAN"><a href="#802-11-WLAN" class="headerlink" title="802.11 WLAN"></a>802.11 WLAN</h4><p>802.11b，802.11a，802.11g，802.11n等，所有802.11标准都是CSMA/CA进行多路访问，都有基站模式和自组织网络模式</p><p><strong>802.11LAN 体系结构</strong></p><p>无线主机与基站通信，**基站（base station） = 接入点（access point（AP)）</p><p>基础设施模式下的<strong>基本服务集Basic Service Set（BSS）</strong></p><ul><li>无线主机</li><li>接入点（AP）：基站</li><li>自组织模式下：只有无线主机</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017141158756.png" alt="image-20211017141158756"></p><p><strong>802.11：信道与关联</strong></p><p>802.11b：2.4GHz-2.485GHz频谱被分为11个相互不同的但是部分重叠的频段</p><ul><li>AP管理员为AP选择一个频率</li><li>可能的干扰：邻居AP可能选择同样一个信道</li></ul><p>主机：必须在通信之前和AP建立<strong>associate</strong></p><ul><li>扫描所有的信道，侦听包含AP SSID和MAC地址的信标帧<ul><li>主动扫描：主机发送真的，接收AP的响应</li><li>被动扫描</li></ul></li><li>选择希望关联的AP</li><li>可能需要执行鉴别（认证），基于MAC，用户名口令，通过AP的中继，使用RADIUS鉴别服务器进行身份鉴别</li><li>将会执行DHCP获得IP地址和AP所在的子网前缀</li></ul><p>主动扫描–被动扫描</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017142228001.png" alt="image-20211017142228001"></p><p><strong>802.11地址</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017142343269.png" alt="image-20211017142343269"></p><p>duration：预约传输时间的持续期(RTS/CTS)</p><p>seq control：帧序号（for RDT)</p><p><strong>frame control中</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017142609921.png" alt="image-20211017142609921"></p><h4 id="switches"><a href="#switches" class="headerlink" title="switches"></a>switches</h4><p><strong>Hub:集线器</strong></p><p>网段（LAN segments）：可以允许一个站点发送的玩路过范围。通常拥有相同的前缀，比IP子网更详细的前缀。在一个碰撞域，同时只允许一个站点在发送，如果有两个节点同时发送，则会碰撞。</p><p>所有以Hub连到一起的站点，处在一个网段，一个碰撞域</p><p>通过hub可扩展节点之间的最大距离，但是不能将10BaseT和100BaseT的网络连接在一起</p><p><strong>Switches</strong>（交换机）</p><p>链路层设备：扮演主动角色（端口执行以太网协议）</p><ul><li>对帧进行存储和转发，对于过来的帧，检查帧头，根据目标MAC地址进行选择性转发。</li><li>当帧需要向某个网段进行转发，使用CSMA/CD进行接入控制。但通常一个交换机端口一个独立网段</li></ul><p><strong>多路同时传输</strong></p><p>因为是端口连接，所以只要A—B，C—D，这样不会互相影响。每条链路都是独立的碰撞域。</p><p>其中交换机都有一个转发表，知道每个表项。</p><p><strong>自学习</strong></p><p>当接收到帧时，交换机就会记录到发送站点所在的端口（网段），记录发送方MAC地址进入端口映射关系，在交换表中</p><p><strong>交换机和路由器</strong></p><p>都是存储转发设备，层次不同</p><ul><li>交换机：链路层设备（检查链路层头部）</li><li>路由器：网络层设备（检查网络层的头部）</li></ul><p>都有转发表</p><ul><li>交换机：维护交换表，按照MAC地址转发</li><li>路由器：维护路由表，执行路由算法</li></ul><h4 id="VLANs"><a href="#VLANs" class="headerlink" title="VLANs"></a>VLANs</h4><p>基于端口的VLAN：交换机端口成组（通过交换机管理软件），以至于<strong>单个的</strong>交换机可以分成若干虚拟LANs。（一个物理LAN基础的设置，虚拟成多个LANs）</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211017145353221.png" alt="image-20211017145353221"></p><p>流量隔离：从/到1-8端口的流量只会设计到1-8</p><p>动态成员：成员可以在VLANs之间动态分配</p><p>在VLANs间转发：通过路由器进行转发</p><h3 id="链路虚拟化：MPLs"><a href="#链路虚拟化：MPLs" class="headerlink" title="链路虚拟化：MPLs"></a>链路虚拟化：MPLs</h3><p>建立基于标签的转发表-信令协议：支持逐跳和显示路由：路由信息传播，路由计算（基于Qos，基于策略的），标签分发。</p><ul><li><p>从IP网络来看，将一组支持MPLS的网络虚拟成链路的技术</p></li><li><p>纯IP网络是按照IP地址对分组进行转发的，前缀匹配，转发的方法固定，无法控制IP分组的路径，无法支持流连工程，也无法对一个IP分组流进行资源分配，性能无法保证</p></li><li><p>MPLs网络按照标签label进行分组的转发，类似与VC，有基于标签的<strong>转发表</strong>，基于虚电路表，IP vs 线路交换</p></li></ul><p><strong>标签交换的过程</strong></p><ol><li>入口路由器：LER对进入的分组按照EFC的定义打上标签</li><li>在MPLS网络中（虚拟成了链路）对分组按照标签进行交换</li><li>到了出口路由器，在将标签摘除</li><li>支持MPLS的路由器组构成的网络，从IP网络的角度来看虚拟成了链路</li></ol><p><strong>优点</strong></p><p>路由弹性：基于Qos，基于策略的</p><p>充分利用已有的硬件ATM快速转发，支持流连工程，VPN…..</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(自顶向下)第五章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="网络控制平面"><a href="#网络控制平面" class="headerlink" title="网络控制平面"></a>网络控制平面</h2><h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><h4 id="路由概念"><a href="#路由概念" class="headerlink" title="路由概念"></a>路由概念</h4><p>按照某种指标（站数，延迟，费用，队列长度等，或者是一些单纯指标的加权平均）找到一条从源节点到目标节点的较好路径（按照某种指标较小的路径）</p><p>以<strong>网络</strong>为单位进行路由（计算机网络 到其他网络怎么走），路由器—路由器之间的路由。</p><blockquote><p>在一个网络中：路由器—主机之间的通信，链路层解决。其他的就是到路由器，到了路由器就是到了这个网络，里面有很多主机。</p></blockquote><p><strong>网络的图抽象</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211015110859673.png" alt="image-20211015110859673"></p><p>路由的输入：拓扑，边的代价，源节点</p><p>输出的输出：源节点的汇集树</p><p>最优化原则：算法可以参考图里面的最短路径算法</p><h4 id="路由的原则"><a href="#路由的原则" class="headerlink" title="路由的原则"></a>路由的原则</h4><p>正确性：算法必须<strong>正确</strong>和<strong>完整</strong>的。</p><p>简单性：算法在计算机上实现简单。</p><p>健壮性：算法应能适应<strong>通信量</strong>和网络拓扑的变化。例如不向很挤的链路发数据，不向断了的链路发数据</p><p>稳定性：产生的路由不应该摇摆</p><p>公平性：对每个站点公平</p><p>最优性：某一个指标的最优，或者综合最优。</p><h4 id="路由算法分类"><a href="#路由算法分类" class="headerlink" title="路由算法分类"></a>路由算法分类</h4><p>全局：所有路由器拥有完整的拓扑和边的代价的信息。Linkstate算法</p><p>分布式：路由器只知道与他有物理连接关系的领居路由器，distance vector算法</p><p>静态或动态</p><p>静态：路由随时间变化缓慢</p><p>动态：路由变化很快，周期性更新，根据链路代价的变化而变化</p><h4 id="Link-state算法"><a href="#Link-state算法" class="headerlink" title="Link state算法"></a>Link state算法</h4><p><strong>LS路由选择算法</strong>的路由工作过程</p><ul><li>各点通过各种渠道获得<strong>整个网络拓扑</strong>，网络中所有链路<strong>代价</strong>等信息（协议和实现）</li><li>使用<strong>LS路由算法</strong>，计算本站点到其他站点的最优路径（汇集树），得到路由表</li><li>按照此路由表转发分组（datagram方式），分发到输入端口的网络层（不能算一个步骤）</li></ul><p><strong>Link state routing链路状态路由选择</strong></p><p>LS路由的基本工作过程</p><ol><li><p>发送相邻节点，获知对方网络地址</p><ul><li>一个路由器接上电，向所有线路发送HELLO分组</li><li>其他路由器收到HELLO分组，回送应答，在应答分组中稿纸自己的名字（全局唯一）</li><li>在LAN中，通过广播HELLO分组，获得其他路由器的信息</li></ul></li><li><p>测量到相邻节点的代价（延迟，开销）</p><ul><li>实测法，发送一个分组要求对方立即响应，回送一个ECHO分组，通过测量时间估算出延迟情况</li></ul></li><li><p>组装一个分组，描述相邻节点的情况</p><ul><li>发送者名称，序号，年龄</li><li>列表：给出他相邻节点，和它到相邻节点的延迟</li></ul></li><li><p>将分组通过扩散的方法发到所有其他路由器</p><ul><li><p>设置顺序号：防止无穷的扩散，每个路由器都记录（源路由器，顺序号），发现重复的或老的就不扩散。</p><p>生成一个分组，设置一个年龄字段/顺序号，不为0，每过一个路由器，顺序号减1，当顺序号为0时分组被抛弃</p></li><li><p>分组的数据结构</p><ul><li>Source：从哪个节点收到LS分组</li><li>Seq，Age：序号，年龄</li><li>Send flags：发送标记，必须向指定的那些相邻站点转发LS分组</li><li>ACK flags：本站点必须向哪些站点发送应答</li><li>DATA：来自source站点的LS分组</li></ul></li></ul></li><li><p>通过Dijkstra算法找出最短路径</p><ul><li>路由器获得各站点LS分组和整个网络拓扑。通过Dijkstra算法计算出到其他各路由器的最短路径（汇集树）</li><li>将计算结果安装到路由表中</li></ul></li></ol><p><strong>链路状态路由选择算法工作原理</strong></p><p>符号标记:</p><ul><li><p>c(i,j): 从节点i 到j链路代价(初始状态下非相邻节点之间的</p><p>链路代价为∞)</p></li><li><p>D(v): 从源节点到节点V的当前路径代价(节点的代价)</p></li><li><p>p(v): 从源到节点V的路径前序节点</p></li><li><p>N’: 当前已经知道最优路径的的节点集合(永久节点的集合)</p></li></ul><p><strong>工作原理</strong></p><p>节点标记：每一个节点使用（D(v) , p(v)) 如(3,B)，Dv从源节点由已知的最优路径到达本节点的距离，pv为前序节点</p><p>分为两类节点</p><p>临时节点（tentative node）还没有找到从源节点到此节点的最优路径的节点</p><p>永久节点（permanent node）N’：已经找到了从源节点到此节点的最优路径的节点</p><blockquote><p>初始化</p><ul><li><p>除了源节点外,所有节点都为临时节点</p></li><li><p>节点代价除了与源节点代价相邻的节点外,都为∞ </p></li></ul><p>从所有临时节点中找到一个节点代价最小的临时节点,将之变成永久节点(当前节点)W</p><p>对此节点的所有在临时节点集合中的邻节点(V) </p><ul><li><p>如 D(v)&gt;D(w) + c(w,v), 则重新标注此点, (D(W)+C(W,V), W) </p></li><li><p>否则，不重新标注</p></li></ul><p>开始一个新的循环</p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211015201158511.png" alt="image-20211015201158511"></p><h4 id="distance-vector算法"><a href="#distance-vector算法" class="headerlink" title="distance vector算法"></a>distance vector算法</h4><p><strong>距离矢量路由选择（distance vector routing）</strong></p><p>基本思想</p><p>各路由器维护一张路由表（如图），各路由器与相邻路由器交换路由表，根据获得的路由信息，更新路由表</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211015202014231.png" alt="image-20211015202014231"></p><p>路由信息的更新（定期测量）</p><ol><li>根据实测，得到本节点A到相邻节点的代价（如：延迟）</li><li>根据各相邻节点声称他们到B节点的代价</li><li>计算出A经过相邻站点到达B的代价，选择最小的代价和相应下一个节点。</li></ol><p><strong>距离矢量算法</strong></p><p>核心思路：</p><p>每个节点将自己的距离矢量估计值传送给邻居，定时或者DV有变化时，让对方算。当x从邻居收到DV时，自己计算，更新他自己的距离矢量</p><p><strong>异步式，迭代</strong>，本地链路代价变化，从邻居来了DV的更新消息</p><p><strong>分布式：</strong>每个节点在自己的DV改变后向邻居通告，然后邻居在有必要的时候再通知他们其他的邻居</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211015203614861.png" alt="image-20211015203614861"></p><p>DV的特点</p><p>好消息传的快，坏消息传的慢。好消息的传播以每一个交换周期的速度进行。</p><p>坏消息的传播速度非常慢，例如 A&lt;———B&lt;———-C，C有个坏消息要传A，他会传给B，B又给C，这样循环往复，到A的距离不可达</p><p><strong>水平分裂（split horizon）算法</strong></p><p>对无穷计算问题的解决方案</p><blockquote><p>注：某些拓扑形式下会失败（存在环路）</p></blockquote><p>例：</p><p>A，B到D的距离为2，C到D的距离为1，如果C-D失败，C知道到D是INF，A，B从C知道到D是INF，但是A从B以为到D可达，A就会从B走（B也有类似的问题），经过无限次之后，A和B都知道D不可到</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211015221220033.png" alt="image-20211015221220033"></p><h4 id="LS和DV算法的比较"><a href="#LS和DV算法的比较" class="headerlink" title="LS和DV算法的比较"></a>LS和DV算法的比较</h4><p>两种算法都有优缺点。</p><p>消息复杂度（DV胜出）</p><p>收敛时间（LS胜出）</p><p>健壮性（LS胜出）</p><h3 id="因特网中自治系统内部的路由选择"><a href="#因特网中自治系统内部的路由选择" class="headerlink" title="因特网中自治系统内部的路由选择"></a>因特网中自治系统内部的路由选择</h3><h4 id="RIP（Routing-Information-Protocol）"><a href="#RIP（Routing-Information-Protocol）" class="headerlink" title="RIP（Routing Information Protocol）"></a>RIP（Routing Information Protocol）</h4><p>DV算法</p><ul><li>距离矢量：每条链路cost=1，# of hops (max= 15hops) 跳数</li><li>DV每隔30秒和邻居交换DV，通告</li><li>每个通告包括：最多25个目标子网</li><li>通告：DV：在邻居之间每30秒交换通告报文<ul><li>定期，而且在改变路由的时候发送通告报文</li><li>在对方的请求下也可发送通告报文</li></ul></li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211015224223020.png" alt="image-20211015224223020"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211015224349738.png" alt="image-20211015224349738"></p><p><strong>RIP：链路失效和恢复</strong></p><p>如果180秒没有收到通告信息—&gt;邻居或者链路失效</p><p>发现经过这个邻居的路由失效，新的通告报文会传递给邻居，邻居因此会发出新的通告（如果路由发生变化），链路失效快速的在整网中传输，使用<strong>毒性逆转</strong>阻止ping-pong回路（不可达的距离：跳数无线=16段）</p><p><strong>RIP：进程处理</strong></p><p>RIP以应用进程方式实现：route-d（daemon），通告报文通过UDP报文传送，周期性重复，网络层的协议使用了传输层的服务，以应用层实体的方式实现</p><h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><p>Open Shortest Path First</p><p>open：标准可公开获得</p><p>使用LS算法，LS分组在网络中（一个AS内部）分发，全局网络在拓扑，代价在每一个节点中保持，路由计算采用Dijkstra算法</p><p>OSPF通告信息中携带：每一个邻居路由器的一个表项，通告信息会传遍AS全部（通过泛洪）（在IP数据报上直接传送OSPF报文，而不是通过UDP和TCP）</p><p><strong>IS-IS路由协议</strong>：几乎和OSPF一样</p><p>—<strong>“高级特性”</strong>（在RIP中没有的）</p><p><strong>安全</strong>：所有的OSPF报文都是经过认证的</p><p>允许有<strong>多个代价相同的</strong>路径存在（RIP只有一个），对于每一个链路，对不同的TOS有<strong>多重代价矩阵</strong>。对单播和多播集成支持Multicast OSPF。在大型网络中支持<strong>层次性</strong>OSPF</p><p><strong>层次性OSPF</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211016132602160.png"></p><p>2个级别的层次性：本地，骨干</p><p>链路状态通告仅仅在本地Area范围内进行，每一个节点拥有本地区域的拓扑信息</p><p><strong>区域边界路由器：</strong>“汇总“到自己区域内网络的距离，向其他区域边界路由器通告</p><p><strong>骨干路由器：</strong>仅仅在骨干区域内，运行OSPF路由</p><p>边界路由器：连接其他的AS’s</p><h3 id="ISP之间的路由选择：BGP"><a href="#ISP之间的路由选择：BGP" class="headerlink" title="ISP之间的路由选择：BGP"></a><strong>ISP之间的路由选择：BGP</strong></h3><p><strong>层次路由</strong>：将互联网分成一个个AS（路由器区域）</p><p>某个区域内的路由器集合 autonomous systems（AS），一个AS用AS Number（ASN）唯一标识，且一个ISP内可能有多个AS</p><p><strong>AS内部路由</strong>：在同一个AS内，路由器运行相同的路由协议。不同的AS可能运行不同的内部网关协议</p><p>AS间运行<strong>AS间路由协议</strong></p><p><strong>优点</strong></p><p>AS内部<strong>数量有限</strong>的路由器相互到达的问题，AS<strong>内部规模可控</strong></p><p>AS之间的路由，增加一个AS也只是增加一个节点，AS内部的多少不影响AS间路由</p><h4 id="AS间路由：BGP"><a href="#AS间路由：BGP" class="headerlink" title="AS间路由：BGP"></a>AS间路由：BGP</h4><p>Border Gateway Protocol：自治区域间路由协议，将互联网各个AS连接在一起的胶水</p><p>BGP方法：</p><ul><li><p>eBGP：从相邻的ASes那里获得子网可达信息</p></li><li><p>iBGP：将获得的子网可达信息传遍到AS内部的所有路由器</p></li><li><p>根据子网可达信息和策略来决定到达子网的好路径</p></li></ul><p>基于距离矢量算法，允许子网向互联网通告”我在这里“</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211016143409789.png" alt="image-20211016143409789"></p><p><strong>BGP会话</strong>：2个BGP路由器在一个半永久的TCP连接上交换BGP报文</p><p>如当AS3网关路由器3a向AS2的网关路由器2c通告路径：AS3.X</p><p>通告的时候，通告包含BGP属性</p><ul><li>prefix+attributes=”route“</li><li>重要属性<ul><li>AS-PATH：前缀通告所经过的AS列表</li><li>NEXT-HOP：从当前AS下吓一跳AS有多少个链路</li></ul></li></ul><p><strong>BGP报文</strong></p><p>使用TCP协议交换BGP报文</p><ul><li>OPEN：打开TCP连接，认证发送方</li><li>UPDATE：通告新路径（或者撤销原路径）</li><li>KEEPALIVE：在没有更新时保持连接，也用于对OPEN请求确认</li><li>NOTIFICATION：报告以前消息的错误，也用来关闭连接</li></ul><p>路由器转发表项</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211016144742050.png" alt="image-20211016144742050"></p><p><strong>BGP路径选择</strong></p><p>路由器可能获得一个网络前缀的多个路径，路由器必须进行路径的选择，路由选择可以基于：</p><ol><li><p>本地偏好值属性: 偏好策略决定</p></li><li><p>最短AS-PATH ：AS的跳数</p></li><li><p>最近的NEXT-HOP路由器:热土豆路由</p><ul><li><strong>热土豆策略</strong>：选择具备最小内部区域代价的网关作为往X的出口（如：2d选择2a，即使往X可能有比较多的AS跳数）：不要操心域间的代价！</li></ul></li><li><p>附加的判据：使用BGP标示</p></li></ol><p><strong>通过路径通告执行策略</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211016145139366.png" alt="image-20211016145139366"></p><p>例如A通知BC路径Aw，B可以选择不向C通知路径BAw</p><p>策略: </p><ul><li><p>Inter-AS: 管理员需要控制通信路径，谁在使用它的网络进行数据传输；</p></li><li><p>Intra-AS: 一个管理者，所以无需策略; </p><ul><li>AS内部的各子网的主机尽可能地利用资源进行快速路由</li></ul></li></ul><p>规模: </p><ul><li><p>AS间路由必须考虑规模问题，以便支持全网的数据转发</p></li><li><p>AS内部路由规模不是一个大的问题 </p><ul><li>如果AS 太大，可将此AS分成小的AS；规模可控</li><li>AS之间只不过多了一个点而已</li><li>或者AS内部路由支持层次性，层次性路由节约了表空间, 降低了更新的数据流量</li></ul></li></ul><p>性能: </p><ul><li><p>Intra-AS: 关注性能</p></li><li><p>Inter-AS: 策略可能比性能更重要</p></li></ul><h3 id="ICMP：因特网控制报文协议"><a href="#ICMP：因特网控制报文协议" class="headerlink" title="ICMP：因特网控制报文协议"></a>ICMP：因特网控制报文协议</h3><p>由主机，路由器，网关用于传达网络层控制信息（错误报告，Echo请求和回复）</p><p>ICMP处在网络层，但是是在IP协议的上面，ICMP消息由IP数据报承载</p><p><strong>ICMP报文</strong></p><ul><li>类型</li><li>编码</li><li>加上IP数据报的头 8B，第一个导致该ICMP报文的IP数据报</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211016150646484.png" alt="image-20211016150646484"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(自顶向下)第四章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="网络层：数据平面"><a href="#网络层：数据平面" class="headerlink" title="网络层：数据平面"></a>网络层：数据平面</h2><h3 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h3><p><strong>网络层服务</strong></p><p>在发送主机和接收主机对之间传送<strong>段(segment)**，在发送端将段封装到数据报中，在接收端，将段 上交给传输层实体。网络层协议存在于</strong>每一个**主机和路由器。路由器检查每一个经过它的IP数据报的头部。</p><p><strong>网络层的功能</strong></p><ul><li>转发：将分组从路由器的输入接口转发到合适的输出接口</li><li>路由：使用路由算法来决定分组从发送主机到目标接收主机的路径<ul><li>路由选择算法</li><li>路由选择协议</li></ul></li></ul><p><strong>数据平面导论</strong></p><p>本地，每个路由器的功能。决定从路由器输入端口到达的分组，如何转发到输出端口</p><p>转发功能</p><ul><li>传统方式：基于目标地址+转发表</li><li>SDN方式：基于多个字段+流表</li></ul><p><strong>控制平面导论</strong></p><p>网络范围内的逻辑，决定数据报如何在路由器之间路由，决定数据报 从源到目标主机之间的端到端路径</p><p>控制平面方法</p><ul><li>传统的路由算法：在路由器中被实现</li><li>SDN（software-defined networking）：在远程的服务器中实现</li></ul><p>传统方式：在<strong>每一个路由器</strong>中的单独路由器算法元件，在控制平面进行交互</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011150523420.png" alt="image-20211011150523420"></p><p>SDN模式</p><p>远程控制器计算和分发转发表以供每台路由器使用。控制平面和数据平面是物理分开的。也就是<strong>软件定义网络</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011151111494.png" alt="image-20211011151111494"></p><p><strong>网络服务模型</strong>可能包括</p><ul><li>确保交互</li><li>有序分组交互</li><li>确保最小带宽</li><li>安全性</li><li>具有时延上界的确保交付</li></ul><p>因特网提供单一的服务，尽力而为服务</p><h3 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h3><p>路由器体系结构</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011151944542.png" alt="image-20211011151944542"></p><ul><li><p><strong>输入端口</strong>：根据数据报头部的信息，在输入端口内存中的转发表查找合适的输出端口（匹配+行动）</p><ul><li><p><strong>基于目标的转发</strong>：仅仅依赖于IP数据报的目标IP地址（传统方法）</p><p>全球有40多亿节点，不可能每个都弄在表中。所以可以用前缀来进行区分。相同前缀的在一起，前缀后面的数字不同而已。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011160839745.png" alt="image-20211011160839745"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011160913313.png" alt="image-20211011160913313"></p></li><li><p><strong>通用转发</strong>：基于头部字段的任意集合进行转发</p></li></ul></li></ul><p><strong>输入端口缓存</strong></p><p>因为交换结构有多个输入端口和输出端口。当交换结构的速率小于输入端口的汇聚起来的速率时，输入端口需要排队。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011161157439.png" alt="image-20211011161157439"></p><p><strong>交换结构</strong></p><p>将分组从输入缓冲区传输到合适的输出端口</p><p>交换速率：分组按照交换速率在其中进行传输。N个输入接口，交换速率就是输入端口的N倍</p><p><strong>3种典型的交换结构</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011161357751.png" alt="image-20211011161357751"></p><p><strong>memory通过内存交换</strong>，在cpu直接控制下的交换。</p><p>分组被拷贝到系统内存，CPU从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口。</p><p>缺点：转发速率被内存的带宽限制（数据报需要通过bus总线两次），一次只能转发一个分组</p><p><strong>bus通过总线交换</strong></p><p>数据报通过共享总线，从输入端口转发到输出端口。一次处理一个分组</p><p>总线竞争：交换速度受限于总线带宽</p><p><strong>crossbar通过互联网络的交换</strong></p><p>同时转发多个分组。</p><p><strong>输出端口</strong></p><p>也有缓冲区，交换机构的达到速度比传输速率块，需要输出端口缓存。</p><p>且有<strong>调度机制</strong>。</p><p><strong>调度机制</strong></p><p>机制有很多。</p><ul><li>可以像队列一样先进先出</li><li>按照优先权来进行调度</li><li>循环发同类分组，一类分组发完发另外的。或者按照类的权重进行分配服务时间</li></ul><h3 id="Internet-Protocol"><a href="#Internet-Protocol" class="headerlink" title="Internet Protocol"></a>Internet Protocol</h3><p>网络层功能</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011163006390.png" alt="image-20211011163006390"></p><h4 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011163109738.png" alt="image-20211011163109738"></p><p><strong>IP分片和重组（Fragmentation &amp; Reassembly）</strong></p><p>因为网络链路有MTU（最大传输单元）（链路层帧所携带的最大数据长度）</p><p>大的IP数据报在网络上被分片，一个数据报被分割成若干个小的数据报。头部相同，重组在目标主机进行。头部信息用于标识，排序相关分片，通过数据偏移量（offset）来进行排序。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011163655528.png" alt="image-20211011163655528"></p><h3 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h3><p>32位二进制标识，一个ip跟一个接口相关联</p><p><strong>子网</strong></p><p>判断方法：将每个接口从主机或者路由器上分开，构成一个个网络孤岛。每个孤岛就是子网subnet。如</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011164146760.png" alt="image-20211011164146760"></p><p><strong>IP地址分类</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011164309052.png" alt="image-20211011164309052"></p><p><strong>IP编址：CIDR</strong></p><p>Classless InterDomain Routing（无类域间路由）</p><p>子网部分可以在任意的位置a.b.c.d/x，其中x是地址中子网号的长度。例如下面x是23，也就是前面长度23为固定地址。不用像abcd类那样分类</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011164920563.png" alt="image-20211011164920563"></p><p><strong>子网掩码</strong></p><p>32bits，0表示主机部分，1表示子网部分。A类是前8为1，B类前16。或者像上面按照需要的位数来进行表示</p><p><strong>转发表和转发算法</strong></p><p>按照子网来进行转发，例如110.10.20.x，在x之前的前缀都由一个路由器接收。那么就转发到这个路由器。如果没找到，就按照默认表项（<strong>路由聚集</strong>）</p><p><strong>获得一个IP地址</strong></p><ul><li>系统管理员将地址配置在一个文件中</li><li>DHCP（Dynamic Host Configuration Protocol）：从服务器中动态获得一个IP地址<ul><li> plug-and-play</li></ul></li></ul><p><strong>DHCP</strong></p><p>工作概述：主机广播 ”DHCP discover”—&gt;DHCP服务器用 “DHCP offer” 提供报文响应—–&gt;主机请求IP地址(发送 DHCP request报文)—–&gt;DHCP服务器发送地址(DHCP ack报文)</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011171542540.png" alt="image-20211011171542540"></p><p>DHCP返回：ip地址，第一段路由器的IP地址（默认网关），DNS服务器的域名和IP地址，子网掩码（指示地址部分的网络号和主机号）</p><p>一个ISP如何获得一个地址块</p><p>ICANN：Internet Corporation for Assigned Names and Numbers</p><ul><li>分配地址</li><li>管理DNS</li><li>分配域名，解决冲突</li></ul><p><strong>NAT：Network Address Translation</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011180005372.png" alt="image-20211011180005372"></p><p>动机：本地网络只有一个有效IP地址</p><ul><li>不需要从ISP分配一块地址，可用一个IP地址用于所有的（局域网）设备（省钱）</li><li>可以在局域网改变设备的地址情况下而无须通知外界</li><li>可以改变ISP（地址变化）而不需要改变内部的设备地址</li><li>局域网内部的设备没有明确的地址，对外是不可见的（安全）</li></ul><p>实现要求：</p><ul><li>外出数据包：替换<strong>源地址和端口号</strong>为<strong>NAT IP</strong>地址和新的端口号，目标IP和端口不变。目标端传回来数据，会将NAT IP地址，新端口号作为目标地址</li><li>记住每个转换替换对（在NAT转换表中）。源IP，端口 <strong>VS</strong> NAT IP，新端口</li><li>从服务器到NAT里面后：替换<strong>目标IP地址和端口号</strong>，<strong>采用存储在NAT表中的mapping表项</strong>，用（源IP，端口）</li></ul><p>有16-bit端口字段，有6w多个同时连接，在一个局域网</p><blockquote><p><strong>对NAT是有争议的</strong></p><p>路由器只应该对第三层做信息处理，而这里对端口号做了处理，是第四层</p><p>违反了end-to-end原则，因为端到端原则中，复杂性的东西应该放到网络边缘，无需借助中转和变换，就可以直接传送到目标主机</p></blockquote><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>为了解决32-bit地址空间用完问题。还有头部格式改变帮助加速处理和转发（TTL-1，头部checksum，分片）。头部格式改变帮助Qos</p><p><strong>IPv6数据报格式</strong></p><ul><li>固定的40字节头部</li><li>数据报传输过程中，不允许分片</li></ul><p><strong>IPv6头部</strong></p><p>Pri（priority）：标示流中数据报的优先级</p><p>Flow Label：标示数据报在一个“flow” （flow的概念没有被严格的定义）</p><p>Next hdr（header）：标示上层协议</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011182540805.png" alt="image-20211011182540805"></p><p>和IPv4的变化</p><p>Checksum：被移除，降低在每一段中的处理速度</p><p>Options：允许，但是头部之外，被Next header字段标示</p><p>ICMpv6：ICMP的新版本，附加了报文类型，Packet Too Big，多播组管理功能</p><h3 id="SDN"><a href="#SDN" class="headerlink" title="SDN"></a>SDN</h3><p>逻辑上集中的控制平面，一个不同的控制器和CA交互，控制器决定分组转发的逻辑（可编程），CA所在设备执行逻辑。（CA为路由器）</p><p><strong>主要思路</strong></p><p>网络设备数据平面和控制平面分离</p><p>数据平面-分组交换机</p><ul><li>将路由器，交换机和目前大多数网络设备的功能进一步<strong>抽象</strong>成：按照流表（由控制平面设置的控制逻辑）进行PDU（帧，分组）的动作（包括转发，丢弃，拷贝，泛洪，阻塞）</li><li><strong>统一化</strong>设备功能：SDN交换机（分组交换机），执行控制逻辑</li></ul><p>控制平面-控制器+网络应用</p><p>分离，集中，计算和下发控制逻辑：流表</p><blockquote><p><strong>优势</strong></p><p><strong>水平集成</strong>控制平面的<strong>开放实现</strong>（而非私有实现），创造出好的产业生态。</p><p><strong>集中</strong>实现控制逻辑，网络<strong>管理容易</strong></p><p>基于流表的<strong>匹配+行动</strong>的工作方式允许“可编程的”分组交换机</p></blockquote><p>传统路由<strong>流量工程</strong>困难</p><p>如果要自定义流量走的路由器，需要去定义链路，然后流量路由以此算法运算。但是如果要将A到B的流量分两路就不可实现。还有等等</p><p>SDN架构：数据平面交换机</p><p>流表被控制器计算和安装，基于南向API（如OpenFlow），SDN控制器访问基于流的交换机，也定义了和控制器的协议</p><p><strong>SDN控制器（网络OS）</strong></p><p>维护网络状态信息，通过上面的北向API和网络控制应用交互，通过下面的南向API和网络交换机交互，逻辑上集中，但是在实现上通常由于性能，可扩展性，容错性以及鲁棒性采用分布式方法</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011194742269.png" alt="image-20211011194742269"></p><p><strong>SDN控制应用</strong></p><p>采用下层提供的服务（SDN控制器提供的API），实现网络功能（路由器，交换机，接入控制，防火墙，负载均衡等）。可以被第三方提供，与控制器厂商不同，与交换机厂商也可以不同</p><h3 id="OpenFlow例子（数据平面抽象）"><a href="#OpenFlow例子（数据平面抽象）" class="headerlink" title="OpenFlow例子（数据平面抽象）"></a>OpenFlow例子（数据平面抽象）</h3><p>流：由分组（帧）头部字段所定义</p><p>通用转发：简单的分组处理规则</p><ul><li>模式：将分组头部字段和流表进行匹配</li><li>行动：对于匹配上的分组，可以丢弃，转发，修改，将匹配的分组发送给控制器</li><li>优先权：几个模式匹配了，优先采用哪个</li><li>计数器：#bytes以及#packets</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011195417472.png" alt="image-20211011195417472"></p><p>这里第一个，表示 src源1-*，目的地址是3-*</p><p>OpenFlow流表的表项结构</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011195518498.png" alt="image-20211011195518498"></p><p><strong>例</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211011195536823.png" alt="image-20211011195536823"></p><p><strong>OpenFlow抽象</strong></p><p>match+action：统一化各种网络设备提供的功能</p><ul><li>路由器，match（最长前缀匹配），action（通过一条链路转发）</li><li>交换机，match（目标MAC地址），action（转发或者泛洪）</li><li>防火墙，match（ip地址和TCP/UDP端口号），action（允许或者禁止）</li><li>NAT，match（IP地址和端口号），action（重写地址）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础排序算法</title>
      <link href="2021/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>2021/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>都是伪码描述，且用 C 实现</p></blockquote><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_Sort</span><span class="params">(ElementType a[],<span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(p=Length<span class="number">-1</span>;p&gt;=<span class="number">0</span>;p--)&#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;p;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[i+<span class="number">1</span>])&#123;</span><br><span class="line">                Swap(A[i],A[i+<span class="number">1</span>]);</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag=<span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//已经完全顺序了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insertion_Sort</span><span class="params">(ElementType a[],<span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(p=<span class="number">1</span>; p&lt;length; p++)&#123;<span class="comment">//假设已经有一个数字，所以从1开始</span></span><br><span class="line">        Tmp = a[p];<span class="comment">//取出一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(i=p; i&gt;<span class="number">0</span> &amp;&amp; a[i<span class="number">-1</span>]&gt;tmp ;i--)</span><br><span class="line">            a[i]=a[i<span class="number">-1</span>];<span class="comment">//如果tmp小于其中的数字，就会移动出空位</span></span><br><span class="line">        a[i]=tmp;<span class="comment">//赋值到移出来的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">( ElementType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 希尔排序 - 用Sedgewick增量序列 */</span></span><br><span class="line">     <span class="keyword">int</span> Si, D, P, i;</span><br><span class="line">     ElementType Tmp;</span><br><span class="line">     <span class="comment">/* 这里只列出一小部分增量 */</span></span><br><span class="line">     <span class="keyword">int</span> Sedgewick[] = &#123;<span class="number">929</span>, <span class="number">505</span>, <span class="number">209</span>, <span class="number">109</span>, <span class="number">41</span>, <span class="number">19</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> ( Si=<span class="number">0</span>; Sedgewick[Si]&gt;=N; Si++ ) </span><br><span class="line">         ; <span class="comment">/* 初始的增量Sedgewick[Si]不能超过待排序列长度 */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> ( D=Sedgewick[Si]; D&gt;<span class="number">0</span>; D=Sedgewick[++Si] )&#123;</span><br><span class="line">         <span class="keyword">for</span> ( P=D; P&lt;N; P++ ) &#123; <span class="comment">/* 插入排序*/</span></span><br><span class="line">             Tmp = A[P];</span><br><span class="line">             <span class="keyword">for</span> ( i=P; i&gt;=D &amp;&amp; A[i-D]&gt;Tmp; i-=D )</span><br><span class="line">                 A[i] = A[i-D];</span><br><span class="line">             A[i] = Tmp;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>算法1-利用最小堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_Sort</span><span class="params">(ElementType a[],<span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line">    BuildHeap(A);<span class="comment">//构建最小堆</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;Length; i++)</span><br><span class="line">        Tmp[i] = DeleteMin(A);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;Length; i++)</span><br><span class="line">        a[i]=Tmp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法2-利用最大堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_Sort</span><span class="params">(ElementType a[], <span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=Length/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        PercDown(a,i,Length);<span class="comment">//buildHeap</span></span><br><span class="line">    <span class="keyword">for</span>(i=length<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">        Swap(&amp;A[<span class="number">0</span>], &amp;a[i]); <span class="comment">//删除（取出）最大值</span></span><br><span class="line">        PercDown(a,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><strong>递归实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* L = 左边起始位置, R = 右边起始位置, RightEnd = 右边终点位置*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">( ElementType A[], ElementType TmpA[], <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> RightEnd )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 */</span></span><br><span class="line">     <span class="keyword">int</span> LeftEnd, NumElements, Tmp;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     </span><br><span class="line">     LeftEnd = R - <span class="number">1</span>; <span class="comment">/* 左边终点位置 */</span></span><br><span class="line">     Tmp = L;         <span class="comment">/* 有序序列的起始位置 */</span></span><br><span class="line">     NumElements = RightEnd - L + <span class="number">1</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">while</span>( L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd ) &#123;</span><br><span class="line">         <span class="keyword">if</span> ( A[L] &lt;= A[R] )</span><br><span class="line">             TmpA[Tmp++] = A[L++]; <span class="comment">/* 将左边元素复制到TmpA */</span></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             TmpA[Tmp++] = A[R++]; <span class="comment">/* 将右边元素复制到TmpA */</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>( L &lt;= LeftEnd )</span><br><span class="line">         TmpA[Tmp++] = A[L++]; <span class="comment">/* 直接复制左边剩下的 */</span></span><br><span class="line">     <span class="keyword">while</span>( R &lt;= RightEnd )</span><br><span class="line">         TmpA[Tmp++] = A[R++]; <span class="comment">/* 直接复制右边剩下的 */</span></span><br><span class="line">         </span><br><span class="line">     <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; NumElements; i++, RightEnd -- )</span><br><span class="line">         A[RightEnd] = TmpA[RightEnd]; <span class="comment">/* 将有序的TmpA[]复制回A[] */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Msort</span><span class="params">( ElementType A[], ElementType TmpA[], <span class="keyword">int</span> L, <span class="keyword">int</span> RightEnd )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 核心递归排序函数 */</span> </span><br><span class="line">     <span class="keyword">int</span> Center;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> ( L &lt; RightEnd ) &#123;</span><br><span class="line">          Center = (L+RightEnd) / <span class="number">2</span>;</span><br><span class="line">          Msort( A, TmpA, L, Center );              <span class="comment">/* 递归解决左边 */</span> </span><br><span class="line">          Msort( A, TmpA, Center+<span class="number">1</span>, RightEnd );     <span class="comment">/* 递归解决右边 */</span>  </span><br><span class="line">          Merge( A, TmpA, L, Center+<span class="number">1</span>, RightEnd );  <span class="comment">/* 合并两段有序序列 */</span> </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">( ElementType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 归并排序 */</span></span><br><span class="line">     ElementType *TmpA;</span><br><span class="line">     TmpA = (ElementType *)<span class="built_in">malloc</span>(N*<span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> ( TmpA != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">          Msort( A, TmpA, <span class="number">0</span>, N<span class="number">-1</span> );</span><br><span class="line">          <span class="built_in">free</span>( TmpA );</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="built_in">printf</span>( <span class="string">&quot;空间不足&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>顺序实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这里Merge函数在递归版本中给出 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* length = 当前有序子列的长度*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_pass</span><span class="params">( ElementType A[], ElementType TmpA[], <span class="keyword">int</span> N, <span class="keyword">int</span> length )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 两两归并相邻有序子列 */</span></span><br><span class="line">     <span class="keyword">int</span> i, j;</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">for</span> ( i=<span class="number">0</span>; i &lt;= N<span class="number">-2</span>*length; i += <span class="number">2</span>*length )</span><br><span class="line">         Merge( A, TmpA, i, i+length, i+<span class="number">2</span>*length<span class="number">-1</span> );</span><br><span class="line">     <span class="keyword">if</span> ( i+length &lt; N ) <span class="comment">/* 归并最后2个子列*/</span></span><br><span class="line">         Merge( A, TmpA, i, i+length, N<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="comment">/* 最后只剩1个子列*/</span></span><br><span class="line">         <span class="keyword">for</span> ( j = i; j &lt; N; j++ ) TmpA[j] = A[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_Sort</span><span class="params">( ElementType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     <span class="keyword">int</span> length; </span><br><span class="line">     ElementType *TmpA;</span><br><span class="line">     </span><br><span class="line">     length = <span class="number">1</span>; <span class="comment">/* 初始化子序列长度*/</span></span><br><span class="line">     TmpA = <span class="built_in">malloc</span>( N * <span class="keyword">sizeof</span>( ElementType ) );</span><br><span class="line">     <span class="keyword">if</span> ( TmpA != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">          <span class="keyword">while</span>( length &lt; N ) &#123;</span><br><span class="line">              Merge_pass( A, TmpA, N, length );</span><br><span class="line">              length *= <span class="number">2</span>;</span><br><span class="line">              Merge_pass( TmpA, A, N, length );</span><br><span class="line">              length *= <span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">free</span>( TmpA );</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="built_in">printf</span>( <span class="string">&quot;空间不足&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取中间，首位，尾部的中间数来当pivot</span></span><br><span class="line"><span class="function">ElementType <span class="title">Median3</span><span class="params">( ElementType A[], <span class="keyword">int</span> Left, <span class="keyword">int</span> Right )</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> Center = (Left+Right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( A[Left] &gt; A[Center] )</span><br><span class="line">        Swap( &amp;A[Left], &amp;A[Center] );</span><br><span class="line">    <span class="keyword">if</span> ( A[Left] &gt; A[Right] )</span><br><span class="line">        Swap( &amp;A[Left], &amp;A[Right] );</span><br><span class="line">    <span class="keyword">if</span> ( A[Center] &gt; A[Right] )</span><br><span class="line">        Swap( &amp;A[Center], &amp;A[Right] );</span><br><span class="line">    <span class="comment">/* 此时A[Left] &lt;= A[Center] &lt;= A[Right] */</span></span><br><span class="line">    Swap( &amp;A[Center], &amp;A[Right<span class="number">-1</span>] ); <span class="comment">/* 将基准Pivot藏到右边*/</span></span><br><span class="line">    <span class="comment">/* 只需要考虑A[Left+1] … A[Right-2] */</span></span><br><span class="line">    <span class="keyword">return</span>  A[Right<span class="number">-1</span>];  <span class="comment">/* 返回基准Pivot */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qsort</span><span class="params">( ElementType A[], <span class="keyword">int</span> Left, <span class="keyword">int</span> Right )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 核心递归函数 */</span> </span><br><span class="line">     <span class="keyword">int</span> Pivot, Cutoff, Low, High;</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">if</span> ( Cutoff &lt;= Right-Left ) &#123; <span class="comment">/* 如果序列元素充分多，进入快排 */</span></span><br><span class="line">          Pivot = Median3( A, Left, Right ); <span class="comment">/* 选基准 */</span> </span><br><span class="line">          Low = Left; High = Right<span class="number">-1</span>;</span><br><span class="line">          <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">/*将序列中比基准小的移到基准左边，大的移到右边*/</span></span><br><span class="line">               <span class="keyword">while</span> ( A[++Low] &lt; Pivot ) ;</span><br><span class="line">               <span class="keyword">while</span> ( A[--High] &gt; Pivot ) ;</span><br><span class="line">               <span class="keyword">if</span> ( Low &lt; High ) Swap( &amp;A[Low], &amp;A[High] );</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          Swap( &amp;A[Low], &amp;A[Right<span class="number">-1</span>] );   <span class="comment">/* 将基准换到正确的位置 */</span> </span><br><span class="line">          Qsort( A, Left, Low<span class="number">-1</span> );    <span class="comment">/* 递归解决左边 */</span> </span><br><span class="line">          Qsort( A, Low+<span class="number">1</span>, Right );   <span class="comment">/* 递归解决右边 */</span>  </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> InsertionSort( A+Left, Right-Left+<span class="number">1</span> ); <span class="comment">/* 元素太少，用简单排序 */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">( ElementType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 统一接口 */</span></span><br><span class="line">     Qsort( A, <span class="number">0</span>, N<span class="number">-1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>次位优先</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxDigit 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Radix 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 桶元素结点 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 桶头结点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeadNode</span> &#123;</span></span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeadNode</span> <span class="title">Bucket</span>[<span class="title">Radix</span>];</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDigit</span> <span class="params">( <span class="keyword">int</span> X, <span class="keyword">int</span> D )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 默认次位D=1, 主位D&lt;=MaxDigit */</span></span><br><span class="line">    <span class="keyword">int</span> d, i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=D; i++) &#123;</span><br><span class="line">        d = X % Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LSDRadixSort</span><span class="params">( ElementType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 基数排序 - 次位优先 */</span></span><br><span class="line">     <span class="keyword">int</span> D, Di, i;</span><br><span class="line">     Bucket B;</span><br><span class="line">     PtrToNode tmp, p, List = <span class="literal">NULL</span>; </span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;Radix; i++) <span class="comment">/* 初始化每个桶为空链表 */</span></span><br><span class="line">         B[i].head = B[i].tail = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123; <span class="comment">/* 将原始序列逆序存入初始链表List */</span></span><br><span class="line">         tmp = (PtrToNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">         tmp-&gt;key = A[i];</span><br><span class="line">         tmp-&gt;next = List;</span><br><span class="line">         List = tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 下面开始排序 */</span> </span><br><span class="line">     <span class="keyword">for</span> (D=<span class="number">1</span>; D&lt;=MaxDigit; D++) &#123; <span class="comment">/* 对数据的每一位循环处理 */</span></span><br><span class="line">         <span class="comment">/* 下面是分配的过程 */</span></span><br><span class="line">         p = List;</span><br><span class="line">         <span class="keyword">while</span> (p) &#123;</span><br><span class="line">             Di = GetDigit(p-&gt;key, D); <span class="comment">/* 获得当前元素的当前位数字 */</span></span><br><span class="line">             <span class="comment">/* 从List中摘除 */</span></span><br><span class="line">             tmp = p; p = p-&gt;next;</span><br><span class="line">             <span class="comment">/* 插入B[Di]号桶尾 */</span></span><br><span class="line">             tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">             <span class="keyword">if</span> (B[Di].head == <span class="literal">NULL</span>)</span><br><span class="line">                 B[Di].head = B[Di].tail = tmp;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 B[Di].tail-&gt;next = tmp;</span><br><span class="line">                 B[Di].tail = tmp;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/* 下面是收集的过程 */</span></span><br><span class="line">         List = <span class="literal">NULL</span>; </span><br><span class="line">         <span class="keyword">for</span> (Di=Radix<span class="number">-1</span>; Di&gt;=<span class="number">0</span>; Di--) &#123; <span class="comment">/* 将每个桶的元素顺序收集入List */</span></span><br><span class="line">             <span class="keyword">if</span> (B[Di].head) &#123; <span class="comment">/* 如果桶不为空 */</span></span><br><span class="line">                 <span class="comment">/* 整桶插入List表头 */</span></span><br><span class="line">                 B[Di].tail-&gt;next = List;</span><br><span class="line">                 List = B[Di].head;</span><br><span class="line">                 B[Di].head = B[Di].tail = <span class="literal">NULL</span>; <span class="comment">/* 清空桶 */</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 将List倒入A[]并释放空间 */</span></span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        tmp = List;</span><br><span class="line">        List = List-&gt;next;</span><br><span class="line">        A[i] = tmp-&gt;key;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主位优先</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxDigit 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Radix 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 桶元素结点 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 桶头结点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeadNode</span> &#123;</span></span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeadNode</span> <span class="title">Bucket</span>[<span class="title">Radix</span>];</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDigit</span> <span class="params">( <span class="keyword">int</span> X, <span class="keyword">int</span> D )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 默认次位D=1, 主位D&lt;=MaxDigit */</span></span><br><span class="line">    <span class="keyword">int</span> d, i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=D; i++) &#123;</span><br><span class="line">        d = X%Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSD</span><span class="params">( ElementType A[], <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> D )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 核心递归函数: 对A[L]...A[R]的第D位数进行排序 */</span></span><br><span class="line">     <span class="keyword">int</span> Di, i, j;</span><br><span class="line">     Bucket B;</span><br><span class="line">     PtrToNode tmp, p, List = <span class="literal">NULL</span>; </span><br><span class="line">     <span class="keyword">if</span> (D==<span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">/* 递归终止条件 */</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;Radix; i++) <span class="comment">/* 初始化每个桶为空链表 */</span></span><br><span class="line">         B[i].head = B[i].tail = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=L; i&lt;=R; i++) &#123; <span class="comment">/* 将原始序列逆序存入初始链表List */</span></span><br><span class="line">         tmp = (PtrToNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">         tmp-&gt;key = A[i];</span><br><span class="line">         tmp-&gt;next = List;</span><br><span class="line">         List = tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 下面是分配的过程 */</span></span><br><span class="line">     p = List;</span><br><span class="line">     <span class="keyword">while</span> (p) &#123;</span><br><span class="line">         Di = GetDigit(p-&gt;key, D); <span class="comment">/* 获得当前元素的当前位数字 */</span></span><br><span class="line">         <span class="comment">/* 从List中摘除 */</span></span><br><span class="line">         tmp = p; p = p-&gt;next;</span><br><span class="line">         <span class="comment">/* 插入B[Di]号桶 */</span></span><br><span class="line">         <span class="keyword">if</span> (B[Di].head == <span class="literal">NULL</span>) B[Di].tail = tmp;</span><br><span class="line">         tmp-&gt;next = B[Di].head;</span><br><span class="line">         B[Di].head = tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 下面是收集的过程 */</span></span><br><span class="line">     i = j = L; <span class="comment">/* i, j记录当前要处理的A[]的左右端下标 */</span></span><br><span class="line">     <span class="keyword">for</span> (Di=<span class="number">0</span>; Di&lt;Radix; Di++) &#123; <span class="comment">/* 对于每个桶 */</span></span><br><span class="line">         <span class="keyword">if</span> (B[Di].head) &#123; <span class="comment">/* 将非空的桶整桶倒入A[], 递归排序 */</span></span><br><span class="line">             p = B[Di].head;</span><br><span class="line">             <span class="keyword">while</span> (p) &#123;</span><br><span class="line">                 tmp = p;</span><br><span class="line">                 p = p-&gt;next;</span><br><span class="line">                 A[j++] = tmp-&gt;key;</span><br><span class="line">                 <span class="built_in">free</span>(tmp);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">/* 递归对该桶数据排序, 位数减1 */</span></span><br><span class="line">             MSD(A, i, j<span class="number">-1</span>, D<span class="number">-1</span>);</span><br><span class="line">             i = j; <span class="comment">/* 为下一个桶对应的A[]左端 */</span></span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSDRadixSort</span><span class="params">( ElementType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 统一接口 */</span></span><br><span class="line">    MSD(A, <span class="number">0</span>, N<span class="number">-1</span>, MaxDigit); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(自顶向下)第三章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="概述传输层（TCP-UDP）"><a href="#概述传输层（TCP-UDP）" class="headerlink" title="概述传输层（TCP/UDP）"></a>概述传输层（TCP/UDP）</h2><p>为运行在不同主机上的应用进程提供<strong>逻辑通信</strong></p><p>传输协议运行在端系统，发送方将应用层的报文分成<strong>报文段</strong>，传递给网络层。接收方将报文段重组成报文，然后传递给应用层</p><p><strong>传输层和网络层的差别</strong></p><p>网络层服务：主机之间的逻辑通信</p><p>传输层服务，进程间的逻辑通信，且依赖于网络层的服务（延时，带宽），并对网络层的服务进行增强（数据丢失，顺序混乱，加密）</p><p><strong>Internet传输层协议</strong></p><p>TCP：可靠的，保序的传输，多路复用解复用，拥塞控制，流量控制，建立连接</p><p>UDP：不可靠，不保序的传输，没有给ip服务添加更多的服务</p><p>都不提供延时保证，带宽保证</p><h2 id="多路复用-解复用"><a href="#多路复用-解复用" class="headerlink" title="多路复用/解复用"></a>多路复用/解复用</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008154118576.png" alt="image-20211008154118576"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>主机收到ip数据报，每个数据报有源IP地址和目标地址，承载一个传输层报文段，有一个源端口号和目标端口号（UDP只有目标端口号）</li><li>服务器联合使用<strong>IP地址</strong>和<strong>端口号</strong>将报文段发送给合适的套接字</li></ul><h2 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：UDP</h2><p>User Datagram Protocol</p><p>”尽力而为式的服务“，报文段可能丢失，可能乱序。但是在应用层进行增加可靠性可以实现可靠传输。</p><p><strong>无连接</strong>：UDP发送端和接收端之间无握手，每个UDP报文段都被独立处理</p><p>应用：流媒体，DNS，SNMP</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008155135484.png" alt="image-20211008155135484"></p><h3 id="UDP校验和"><a href="#UDP校验和" class="headerlink" title="UDP校验和"></a>UDP校验和</h3><p>目标：检测在被传输报文段中的差错</p><p><strong>发送方</strong></p><ul><li>将报文段的内容视为16比特的整数</li><li>检验和：报文段的加法和（1的补运算）</li><li>发送放将检验和放在UDP的 校验和 字段</li></ul><p><strong>接收方</strong></p><ul><li>计算接收到的报文段的检验和</li><li>检查计算出的 校验和 与 校验和 字段的内容是否相等：<ul><li>不相等-检测到差错</li><li>相等–可能无差错</li></ul></li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008155721874.png" alt="image-20211008155721874"></p><h2 id="可靠数据传输-rdt-的原理"><a href="#可靠数据传输-rdt-的原理" class="headerlink" title="可靠数据传输(rdt)的原理"></a>可靠数据传输(rdt)的原理</h2><p>rdt在应用层，传输层和数据链路层都重要，是网络TOP10问题之一。信道的不可靠特点决定了可靠数据传输协议的复杂性</p><p>先看以下四种运行状态</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008161156148.png" alt="image-20211008161156148"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008161227419.png" alt="image-20211008161227419"></p><p>具体原理为</p><p>发送方</p><ul><li>发送的数据分组，进行编号。发送出去之后进行超时计时</li><li>收到0就发1，如果发了1之后还是收到0。就发0</li></ul><p>接收方</p><ul><li>接收数据分组。接收到0之后返回收到了0，发送方就会发1。</li><li>如果1发送错了。或者没发过来。发送方超时就会重发</li></ul><p>具体看图。就能理解</p><p><strong>性能</strong></p><p>虽然这个rdt能工作，但是链路容量大的话。性能很差。链路容量大，但是我们一次只发一个PDU，浪费的链路容量。</p><p>设 15ms端到端延迟-分组大小为1kB</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008162022117.png" alt="image-20211008162022117"></p><h3 id="流水线：提高链路利用率"><a href="#流水线：提高链路利用率" class="headerlink" title="流水线：提高链路利用率"></a>流水线：提高链路利用率</h3><p>流水线：允许发送方在<strong>未得到对方确认</strong>的情况下，一次发送<strong>多个</strong>分组</p><ul><li>但是需要增加序号的范围，用多个bit表示分组序号</li><li>在发送方/接收方要有缓冲区<ul><li>发送方缓冲，未得到确认，可能需要重传</li><li>接收方缓冲，上层用户取用的速率 和 接收数据速率不等，接受的数据可能乱序，缓冲实现排序交付</li></ul></li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008162237506.png" alt="image-20211008162237506"></p><p>两种通用的流水线协议：回退N步（GBN），选择重传（SR）</p><h4 id="回退N步GBN—-选择重传SR"><a href="#回退N步GBN—-选择重传SR" class="headerlink" title="回退N步GBN—-选择重传SR"></a>回退N步GBN—-选择重传SR</h4><p>也称为 滑动窗口（slide window)协议</p><p><strong>发送窗口</strong>-发送缓冲区</p><blockquote><p>这里虽然已经把绿色的部分全画出来了。实际工作是，没有数据时，后沿等于前沿。有一个分组进来，前沿+1。后沿的不动。等到低序号的确认到来，后沿再+1；</p></blockquote><p>允许发送方发送多个分组而不需要确认。但是不允许超过最大允许数N</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008163353238.png" alt="image-20211008163353238"></p><p>在这里，绿色框起来的就是最大允许数的内容。0之前的是已经发送且确认了的。绿色中的是发送了未确认，或一部分是空的。4之后就是未发送的内容。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008163543798.png" alt="image-20211008163543798"></p><p>像这样就是0已经确认，1234发送了未确认，5还没数据发送，等待数据来进行发送。</p><p><strong>接收窗口</strong>-接收缓冲区</p><p>只有收到的分组序号落入接收窗口才允许接收，若序号在接收窗口之外，则丢弃。</p><p>接收窗口尺寸Wr=1只能顺序接收，&gt;1可以乱序接收</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008164333168.png" alt="image-20211008164333168"></p><p>低序号到来，就移动。如果高序号先到，位置不动，要等最低的来了才动</p><p><strong>正常情况下的互动</strong></p><p><strong>发送窗口</strong></p><ul><li>新的分组落入发送缓冲区，发送，前沿移动</li><li>来了低序号的确认，后沿向前移动</li></ul><p><strong>接收窗口</strong></p><ul><li>收到分组，落入到接收窗口范围内，接收。</li><li>低序号，发送确认给对方</li></ul><p><strong>异常情况的互动</strong></p><p><strong>GBN</strong></p><p>发送窗口</p><ul><li>新分组落入发送缓冲区范围，发送-&gt;前沿滑动</li><li><strong>超时重发机制让发送端将发送窗口中的所有分组发送出去</strong></li><li>来了老分组的重复确认，后沿不动。新分组无法落入发送缓冲区的范围</li></ul><p>接收窗口</p><ul><li>收到乱序分组，没有落入到接收窗口范围内，抛弃</li><li>（重复）发送老分组的确认，累计确认</li></ul><p><strong>SR</strong></p><p>发送窗口</p><ul><li>新分组落入发送缓冲区范围，发送前沿滑动</li><li><strong>超时重发机制让发送端将超市的分组重新发出去</strong></li><li>来了乱序分组的确认，后沿不动，新的分组无法落入发送缓冲区的范围</li></ul><p>接受窗口</p><ul><li>收到乱序分组，落入到接收窗口范围内，接收</li><li>发送该分组的确认，单独确认</li></ul><p><strong>GBN协议和SR协议的异同</strong></p><p>相同</p><ul><li>发送窗口&gt;1</li><li>一次能够发送多个未经确认的分组</li></ul><p>不同</p><ul><li>GBN：接收窗口尺寸=1，接收端只能顺序接收。发送端一旦一个分组没有发送成功，其他的所有都发一次。一共只有一个定时器，在最低序号的位置</li><li>SR：接收窗口尺寸&gt;1，接收端可以乱序接收。发送端只发送没有收到的确认。也就是每个分组都有一个定时器</li></ul><h2 id="TCP-面向连接的传输"><a href="#TCP-面向连接的传输" class="headerlink" title="TCP-面向连接的传输"></a>TCP-面向连接的传输</h2><p><strong>概述</strong></p><ul><li>点对点</li><li>可靠的，按顺序的字节流。没有报文边界</li><li>管道化（流水线），TCP拥塞控制和流量控制设置窗口大小</li><li>发送和接收缓存</li><li>全双工数据：在同一连接中数据流双向流动。MSS：最大报文段大小</li><li>面向连接：在数据交换之前，通过握手（交换控制报文）初始化发送方、接收方的状态变量</li><li>有流量控制：发送方不会淹没接收方</li></ul><h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008215034655.png" alt="image-20211008215034655"></p><ul><li>序号：报文段首字节的在字节流的编号</li><li>确认号：期望从另一方收到的下一个字节的序号</li></ul><p><strong>TCP往返延迟和超时</strong></p><p>估计RTT：测量从报文段发出到收到确认的时间，如果有重传就忽略此次测量。对几次测量的样本取平均</p><p>TCP超市：设置的比RTT长，太早超时，会有不必要的重传。太长，报文段的丢失反应太慢。具体视情况定</p><h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>TCP在IP不可靠服务的基础上建立rdt</p><ul><li>管道化的报文段（GBN/SR）</li><li>累计确认（类似GBN）</li><li>单个重传定时器（类似GBN）</li></ul><p>通过超时，重复的确认来触发重传</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008225738753.png" alt="image-20211008225738753"></p><p><strong>快速重传</strong></p><p>问题：超时的周期往往很长（在重传丢失报文段之前的延时太长），发送方通常连续发送大量报文段，如果报文段丢失，会引起多个重复的ACK</p><p><strong>快速重传：</strong>在定时器过时之前重发报文段</p><p>假设在被确认的数据后面的数据丢失了。第一个ACK正常，第二个段的丢失，收到第三第四段的确认，大概率第二个ACK丢失。进行重传</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008230145503.png" alt="image-20211008230145503"></p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>接收方控制发送方，不让发送方发送的太多太快，以至于让接收方缓冲区溢出</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008230356531.png" alt="image-20211008230356531"></p><ul><li>接收方在其发送方的TCP段头的rwnd字段，告知其空闲buffer大小</li><li>发送方限制字节个数 &lt;=接收方发送来的rwnd值</li><li>保证接收方不会被淹没</li></ul><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>发送方和接收方握手建立通信关系，如下是同一连接参数</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008230752402.png" alt="image-20211008230752402"></p><p><strong>TCP可以两次握手吗？</strong></p><p><strong>两次握手有失败的场景</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008231008820.png" alt="image-20211008231008820"></p><p><strong>这个问题在三次握手中解决掉了</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008231042227.png" alt="image-20211008231042227"></p><p><strong>三次握手的建立方式</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008231118918.png" alt="image-20211008231118918"></p><p><strong>TCP关闭连接</strong></p><ul><li>客户端，服务器分别关闭它自己这一侧的连接，发送FIN bit=1 的TCP段</li><li>一旦接收到FIN，用ACK回应，ACK中带着FIN段一起发送。</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211008231300897.png" alt="image-20211008231300897"></p><h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><p>也是网络TOP10中的问题</p><p>简单来说就是，发的数据包超过了网络的处理能力。（不一定是我们一个人发的）</p><p>拥塞带来的问题就是，分组丢失，分组经历比较长的延迟（在路由器中排队）</p><p>例如：有两个主机，一个路由器，两个服务器。两个主机往服务器发送数据。都通过一个路由器，那如果路由器的缓冲区满了之后，其他的分组就会丢失了。虽然会重传数据。但是其中也浪费了时间。还有其他的一些例子</p><p><strong>解决方案</strong>，两个常用的拥塞控制方法</p><p><strong>端到端拥塞控制（TCP采用的方法）</strong>：没有来自网络的显示反馈，段系统根据延迟和丢失事件判断是否有拥塞</p><p><strong>网络辅助的拥塞控制</strong>：路由器提供给段系统以反馈信息，单个bit置位，显示有拥塞，显示提供发送端可以采用的速率。</p><h3 id="扩展ATM-ABR拥塞控制"><a href="#扩展ATM-ABR拥塞控制" class="headerlink" title="扩展ATM ABR拥塞控制"></a>扩展ATM ABR拥塞控制</h3><p><strong>ABR：available bit rate</strong></p><p>弹性服务，如果发送端的路径 “轻载”，发送方增加使用可用带宽。如果路径拥塞了，发送方限制发送速率到最小保障速率上。</p><p><strong>RM（资源管理）信元</strong></p><p>由发送端发送，在数据信元中间隔插入</p><p>RM信元中的比特被交换机设置（“网络辅助”）</p><ul><li>NI bit（no increase in rate）轻微拥塞，速率不要增加了</li><li>CI bit（congestion indication）拥塞指示</li></ul><p>在RM信元中的2个字节ER（explicit rate）字段，拥塞的交换机可能会降低信元中ER的值，发送端发送速度是最低的可支持速率</p><p>如果管理信元RM前面的数据信元EFCI被设置为1，接收端返回的RM信元中设置CI bit</p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p><strong>端到端的拥塞控制机制</strong></p><p>路由器不向主机发送有关拥塞的反馈信息，路由器负担较轻，符合网络核心简单的TCP/IP架构原则，端系统根据自身得到的信息，判断是否发生拥塞，从而采取动作</p><p><strong>拥塞感知</strong></p><ul><li>某个段丢失<ul><li>网络拥塞（某个路由器缓冲没空间，被丢弃）大概率</li><li>出错被丢弃（各级错误，没有通过校验，被丢弃）小概率</li></ul></li><li>收到某个段3次重复的ACK（轻微拥塞）<ul><li>第一个ACK1正常</li><li>收到第二个重复ACK，第三个重复的ACK1。大概率ACK2丢失。</li></ul></li></ul><p><strong>速率控制方法</strong></p><p>维持一个拥塞窗口的值：CongWin，发送端限制发送的数据量。CongWin’动态改变</p><ul><li>超时：CongWin降为1MSS，进入 SS阶段 然后再倍增到CongWin/2，从而进入CA阶段</li><li>3个重复ACK，CongWin降为CongWin/2，CA阶段</li></ul><p><strong>SS阶段：加倍增加</strong></p><p><strong>CA阶段：线性增加</strong></p><p><strong>具体策略概述</strong></p><ul><li>慢启动</li><li>AIMD：线性增，乘性减少</li><li>超时事件后的保守策略</li></ul><p><strong>慢启动</strong></p><p>连接刚建立CongWIn=1 MSS，连接开始时指数性增加发送速率，直到有丢失事件。</p><ul><li>每一个RTT，CongWin加倍</li><li>每收到一个ACK时，CongWin加1</li><li>慢启动阶段只要不超时或有3个重复ack，一个RTT，CongWin加倍</li></ul><p><strong>AIMD阶段</strong></p><ul><li>当收到<strong>3个重复的ACKs</strong><ul><li>CongWin减半</li><li>窗口（缓冲区大小）线性增长</li></ul></li><li>当超时事件发生时<ul><li>CongWin被设置成1MSS，进入SS阶段</li><li>之后窗口指数增长，增长到一个阈值（上次发生拥塞的窗口的一半）时，再线性增加。</li></ul></li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211009102302495.png" alt="image-20211009102302495"></p><h3 id="TCP公平性"><a href="#TCP公平性" class="headerlink" title="TCP公平性"></a>TCP公平性</h3><p>两个竞争的TCP会话</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211009103218507.png" alt="image-20211009103218507"></p><p>但是互联网中不只有TCP，还有UDP（没有拥塞控制）。这样就没办法公平</p><p>或者两个主机间，有一个主机有多个TCP并行连接，他获取的资源就不止R/2，而是大于R/2。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(自顶向下)第二章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="1-应用层协议原理"><a href="#1-应用层协议原理" class="headerlink" title="1.应用层协议原理"></a>1.应用层协议原理</h2><p><strong>可能的应用架构</strong></p><ul><li><p>客户-服务器模式（C/S：client/server）</p><ul><li>服务器：一直运行，固定的 Ip 地址和周知的端口号（约定），扩展性差</li><li>客户端：主动与服务器通信，与互联网有间歇性的连接，可能是动态Ip地址，不直接与其他客户端通信</li></ul></li><li><p>对等模式（P2P：Peer To Peer）</p><ul><li>（几乎）没有一直运行的服务器，任意端系统之间可以进行通信，每一个节点既是客户端又是服务器</li><li>自扩展性-新peer节点带来新的服务能力，也带来新的服务请求</li><li>参与的主机间歇性连接且可以改变Ip地址，但是难以管理</li></ul></li><li><p>混合体：客户-服务器和对等体系结构，C/S和P2P体系结构的混合体</p><ul><li><p>Napster：文件搜索：集中，主机在中心服务器上注册其资源，在中心服务器查询资源位置。</p><p>文件传输P2P：任意Peer节点之间</p></li><li><p>即时通信：在线检测：集中，当用户上线向服务器注册ip地址，用户与中心服务器连接，找到在线好友位置。</p><p>两个用户聊天：P2P</p></li></ul></li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程：在主机上运行的应用程序。分为客户端和服务器</p><ul><li>客户端：发起通信的进程</li><li>服务器：等待连接的进程</li></ul><p>同一个主机内，使用进程间的通信机制进行通信</p><p>不同主机，通过交换<strong>报文（Message）</strong>来通信</p><ul><li>使用OS提供的通信服务</li><li>按照应用协议交换报文，借助传输层提供的服务</li></ul><p><strong>但是这样进行通信，会有通信的问题需要解决</strong></p><ol><li>进程标示和寻址问题（服务用户）</li><li>传输层-应用层提供服务是如何（服务）<ul><li>位置：层间界面的SAP（TCP/IP：socket）</li><li>形式：应用程序接口API（TCP/IP：socket API）</li></ul></li><li>如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用（用户使用服务）<ul><li>定义应用层想协议：报文格式，解释，时序等</li><li>编制程序，使用OS提供的API，调用网络基础设施提供通信服务传报文，实现应用时序等；</li></ul></li></ol><p><strong>解决</strong></p><ol><li><p><strong>标识（Ip+Port）每个主机都有IP地址，和端口号，IP地址找到主机，端口号找到具体进程</strong></p></li><li><p><strong>传输层提供的服务-需要穿过层间的信息</strong></p><ul><li><p>层间接口必须携带各种信息</p><p>要传输的报文，谁传的，对方的IP+TCP/UDP端口，传给谁：对方的IP+TCP(UDP）端口号。传输层实体根据信息进行TCP报文段UDP数据报封装。等等</p></li></ul><p>每次传输这么多信息很麻烦。可以用socket代号标示双方或单方。用一个整数表示两个应用实体之间的通信关系，放在本地进行标示。</p><p><strong>TCP之上的套接字</strong>：对于TCP而言，套接字是4元组（源ip，源port，目标ip，目标port）的一个具有本地意义的标示，唯一的指定一个会话，应用只需要使用这个标示就可以进行通信。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210924144012076.png" alt="image-20210924144012076"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210924144035137.png" alt="image-20210924144035137"></p><p><strong>UDP socket</strong></p><p>UDP服务是不需要建立连接的。每个报文都独立传输，可以只用一个整数就可以标示本应用实体的标示，socket只需要IP+本端口，传输报文时，需要对方的IP+Port</p><p>所以使用的是2元组具有本地意义的标示</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210924144435203.png" alt="image-20210924144435203"></p><blockquote><p>套接字的发送和接收进程都在传输层的设施中</p></blockquote></li><li><p><strong>如何使用传输层提供的服务实现应用</strong></p><ul><li>定义应用层协议：报文格式，解释，时序等</li><li>编制程序，通过API调用网络基础设施提供通信服务传报文，解析报文，实现应用时序等</li></ul></li></ol><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p><strong>定义了：运行在不同端系统上的应用进程，如何交换报文</strong>。如HTTP协议，SMTP等</p><p>分为公开协议和专用（私有）协议</p><p><strong>应用需要传输层提供的服务</strong></p><p>延迟，吞吐，数据丢失率，安全性等的要求</p><p><strong>传输层提供的服务</strong></p><ul><li><p>TCP服务</p></li><li><p>UDP服务</p><p>UDP必要性，能够区分不同的进程，IP服务不能。无需建立连接。不做可靠性的工作，应用能够按照设定的速度发送数据。</p></li></ul><p><strong>TCP安全</strong></p><p>TCP和UDP都是不加密的协议，明文传输密码等</p><p>SSL协议可以解决此问题，采用SSL库，在TCP上实现，提供加密的TCP连接。</p><h2 id="Web-and-HTTP"><a href="#Web-and-HTTP" class="headerlink" title="Web and HTTP"></a>Web and HTTP</h2><p>术语</p><ul><li>Web页：由一些对象组成</li><li>对象可以是HTML文件，JPEG图像，Java小程序，声音剪辑文件等</li><li>web页有一个基本的HTML文件，该基本HTMl文件又包含若干对象的引用（链接）</li><li>URL格式</li></ul><p><a href="https://user%40psw@blog.yvenxx.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html">https://user@psw@blog.yvenxx.cn/计算机网络.html</a> : port</p><p>协议名://用户:口令@主机名/路径名 : port</p><h3 id="HTTP-概括"><a href="#HTTP-概括" class="headerlink" title="HTTP 概括"></a>HTTP 概括</h3><p>HTTP：超文本传输协议</p><ul><li>Web的应用层协议</li><li>客户/服务器模式</li></ul><blockquote><p>HTTP是无状态的</p><p>服务器并不维护关于客户的任何信息</p></blockquote><p><strong>使用TCP</strong></p><ol><li>客户发起一个与服务器的TCP连接（建立套接字）80端口</li><li>服务器接手客户的TCP连接</li><li>在浏览器（HTTP客户端）与Web服务器交换HTTP报文（应用层协议报文）</li><li>TCP连接关闭</li></ol><p><strong>HTTP连接</strong></p><p>分为，非持久HTTP，持久HTTP</p><p>区别就是，持久HTTP多个对象可以在一个TCP连接上传输（HTTP/1.1默认使用持久连接）</p><p>非持久HTTP的 缺点 ，每个对象要2个RTT，操作系统必须为每个TCP连接分配资源。但浏览器通常并行的打开TCP连接，以获取资源。</p><p>持久化HTTP，在服务器发送响应后，保持TCP连接。之后的通信都用这个连接。分为流水和非流水</p><ul><li>流水方式的持久HTTP：HTTP/1.1默认模式，客户端遇到一个引用对象就立即产生一个请求，所有引用对象只花费一个RTT是可能的</li><li>非流水方式的持久HTTP：客户端只能在收到前一个响应后才能发出新的请求，每个引用对象话费一个RTT</li></ul><p><strong>HTTP具体笔记暂未写  后续放连接</strong></p><p><strong>Web缓存（代理服务器）</strong></p><p>不访问原始服务器，就满足客户的请求</p><p>具体实现</p><ol><li>用户设置浏览器：通过缓存访问Web</li><li>浏览器将所有的HTTP请求发给缓存<ul><li>在缓存中的对象：缓存直接返回对象</li><li>若对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端</li></ul></li></ol><p><strong>好处</strong></p><p>降低客户端的请求响应时间，减少一个机构内部网络与Internet接入链路上的流量，使用了缓存之后，较弱的ICP也能够有效提供内容</p><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>文件传输协议，端口号21。向远程服务器传输文件或下载文件</p><p><strong>控制连接与数据连接分开</strong></p><p>有状态的连接。</p><p>一个连接保持控制状态，一个连接进行传输文件。</p><p><strong>FTP返回码样例</strong></p><p>状态码和状态信息（同HTTP）</p><ul><li>331 Username OK, password required</li><li>125 data connection already open; transfer starting</li><li>425 Can’t open data connection</li><li>452 Error writing file</li></ul><h2 id="EMail"><a href="#EMail" class="headerlink" title="EMail"></a>EMail</h2><p>三个主要组成部分</p><ul><li>用户代理<ul><li>又名 邮件阅读器</li><li>输出和输入邮件保存在服务器</li></ul></li><li>邮件服务器<ul><li>邮箱中管理和维护发送给用户的邮件</li><li>输出报文队列保持待发送的报文</li><li>邮件服务器之间的SMTP协议：发送email报文。客户（发送方邮件服务器），服务器（接收端邮件服务器）</li></ul></li><li>简单邮件传输协议：SMTP<ul><li>使用TCP在客户端和服务器之间传送报文，端口为25。直接传输</li><li>三个阶段：握手-》传输报文-》关闭</li><li>命令/响应交互：命令（ASCII文本），响应（状态码和状态信息）</li><li>报文必须七位ASCII码</li><li>服务器使用，CRLF.CRLF决定报文的尾部</li></ul></li></ul><p>多媒体扩展：MIME多媒体邮件扩展</p><p>在报文首部使用额外的行申明MIME内容类型</p><p>SMTP与HTTP比较</p><ul><li><p>HTTP：拉（pull）</p></li><li><p>SMTP：推（push）</p></li><li><p>二者都是ASCII形式的命令/响应交互，状态码</p></li><li><p>HTTP：每个对象封装在各自的响应报文中</p></li><li><p>SMTP：多个对象包含在一个报文中</p></li></ul><p>邮件访问协议</p><p>用户代理<strong><strong>smtp</strong></strong>&gt;发送方邮件服务器<strong><strong>smtp</strong></strong>&gt;接收方邮件服务器____pop3、IMAP、HTTP_______&gt;用户代理</p><p>SMTP：传送到接收方的邮件服务器</p><p>邮件访问协议：从服务器访问邮件</p><ul><li>POP：邮局访问协议，用户身份确认（代理&lt;—&gt;服务器）并下载</li><li>IMAP：Internet邮件访问协议<ul><li>更多特性（更复杂），在服务器上处理存储的报文</li></ul></li><li>HTTP：Hotmail,Yahoo! Mail等<ul><li>方便</li></ul></li></ul><p>POP3（续）与 IMAP</p><p>POP3（续）本地管理文件夹</p><ul><li>下载并删除 模式，看完之后删除，改变了客户机，就不能访问了</li><li>下载并保留 模式，不同客户机上为报文的拷贝</li><li>POP3在会话中是无状态</li></ul><p>IMAP  远程管理文件夹</p><ul><li>IMAP服务器将每个报文与一个文件夹联系起来</li><li>允许用户用目录来组织报文</li><li>允许用户读取报文组件</li><li>IMAP在会话过程中保留用户状态，目录名，报文ID与目录名之间映射</li></ul><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>必要性</p><ul><li>IP地址标识主机，服务器。由于数字不好记，所以就定义一些有意义的字符串来标识Internet上的设备</li><li>存在着“字符串”—-IP地址转换的必要性，由DNS负责转换成为二进制的网络地址</li></ul><h3 id="DNS总体思路和目标"><a href="#DNS总体思路和目标" class="headerlink" title="DNS总体思路和目标"></a>DNS总体思路和目标</h3><p><strong>DNS主要思路</strong></p><ul><li><strong>分层</strong>的，基于域的命名机制</li><li>若干分布式的数据库完成名字到IP地址的转换</li><li>运行在UDP之上端口号为53的<strong>应用</strong>服务</li><li>核心的Internet功能，但以应用层协议实现，在网络边缘处理复杂性</li></ul><p>DNS<strong>主要目的</strong></p><ul><li>实现主机名-IP地址的转黄</li><li>主机别名到规范名字的转换，邮件服务器别名到邮件邮件服务器的正规名字的转换，负载均衡</li></ul><p><strong>DNS域名结构</strong></p><p>DNS采用层次树状结构的命名方法，Internet根被划分为几百个顶级域，分为通用的和国家的。每个子域下面可划分为若干子域，树叶是主机。</p><p>域名的管理</p><p>一个域管理其下的子域(.cn 可以划分为edu.cn  ,   com.cn)，域遵从组织界限，不是物理网络</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210928143223926.png" alt="image-20210928143223926"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210928143204644.png" alt="image-20210928143204644"></p><p>根服务器下面还有很多其他的二级服务器，二级服务器往下还有下级等</p><p>TLD服务器：负责顶级域名和所有国家级顶级域名</p><p><strong>区域名字服务器维护资源记录</strong></p><p>资源记录：维护域名-ip地址的映射关系</p><p>RR格式（domain_name，ttl，type，class，value）</p><ul><li><p>domain_name:域名</p></li><li><p>TTL: time to live 生存时间（权威，缓冲记录）决定了资源记录应当从缓存中删除的时间</p></li><li><p>Class类别：对于Internet，值为In</p></li><li><p>Value值：可以是数字，域名或ASCII串</p></li><li><p>Type类别：</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210928153000820.png" alt="image-20210928153000820"></p></li></ul><p>DNS大致工作过程</p><p>应用调用解析器（resolver），解析器为客户 向Name Server发出查询报文（封装在UDP），Name Server 返回响应报文</p><p>本地名字服务器（Local Name Server）</p><p>其实并不严格属于层次结构，每个ISP都有一个本地DNS服务器，当一个主机发送DNS查询时，查询被送到DNS服务器。当本地服务器不能解析时，就顺着根-TLD找到权威名字服务器</p><p>有两种查询方法</p><ul><li><p>递归查询：</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210928153710375.png" alt="image-20210928153710375"></p></li><li><p>迭代查询：根服务器返回的不是查询结果，而是下一个DNS的地址，最后由名字服务器给出解析结果</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210928153737545.png" alt="image-20210928153737545"></p></li></ul><h3 id="DNS协议，报文"><a href="#DNS协议，报文" class="headerlink" title="DNS协议，报文"></a>DNS协议，报文</h3><p>DNS协议：查询和响应报文的报文格式相同</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210928153951029.png" alt="image-20210928153951029"></p><ul><li>identification：标识符（ID）16位</li><li>flags：查询/应答，希望递归……</li><li>questions：一个查询的Name，type字段</li><li>answers：对应查询的RR记录</li><li>authority：权威服务器的记录</li><li>additional info：附加的有用信息</li></ul><h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2><p>每一个Peer节点都可以当客户端和服务器。</p><h3 id="P2P文件分发：BitTorrent"><a href="#P2P文件分发：BitTorrent" class="headerlink" title="P2P文件分发：BitTorrent"></a>P2P文件分发：BitTorrent</h3><p>文件被分为一个个块，网络中的这些peers发送接收文件块，相互服务</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210928154612096.png" alt="image-20210928154612096"></p><p>Peer加入torrent：</p><ul><li>一开始没有块，但是将会通过其他节点处积累文件块</li><li>向跟踪服务器注册，获得peer节点列表，和部分peer节点构成邻居关系</li><li>当peer下载时，该peer可以同时向其他节点提供上载服务，peer可能会变换用于交换块的节点。</li><li>一旦一个peer拥有整个文件，他会离开或者保留在torrent中</li></ul><p><strong>请求块</strong></p><ul><li>在任何给定时间，不同peer节点拥有一个文件块的子集</li><li>周期性的，Alice节点向邻居询问它们拥有哪些块的信息。</li><li>Alice向peer节点请求它希望的块，稀缺的块。</li></ul><p><strong>发送块</strong></p><ul><li>Alice向4个peer发送块，这些服务向她提供过最大带宽服务。（其他的peer被Alice阻塞，不会从Alice处获得服务，每10秒评估一个前四位）</li><li>每隔30秒，随机选择其他peer节点，向这个节点发送块。</li><li>谁帮过我，我就优先帮谁（tit-for-tat)</li></ul><h3 id="P2P文件共享"><a href="#P2P文件共享" class="headerlink" title="P2P文件共享"></a>P2P文件共享</h3><p><strong>查询洪泛Gnutella</strong>（协议）</p><ul><li>全分布式，没有中心服务器</li><li>开放文件共享协议</li><li>许多Gnutella客户端实现了Gnutella协议。利用图来覆盖网络</li></ul><p><strong>Gnutella：协议</strong></p><p>在已有的TCP连接上发送查询报文，对等发转发查询报文，如果查到由最终的服务器返回。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210928161023284.png" alt="image-20210928161023284"></p><p><strong>利用不匀称性：KaZaA</strong></p><ul><li>每个对等方要么是一个组长，要么隶属一个组长。对等方与组长之间有TCP连接，组长对之间有TCP连接</li><li>组长跟踪所有的孩子的内容</li><li>组长与其他组长联系。转发查询到其他组长，活的其他组长的数据拷贝。</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210928161211361.png" alt="image-20210928161211361"></p><ol><li>每个文件有一个散列标识码和一个描述符，客户端向其组长发送关键字查询。</li><li>组长用匹配进行响应（元数据，散列标识码，IP地址）</li><li>如果组长将查询发送给其他组长，其他组长以匹配进行响应。</li><li>客户端选择要下载的文件（向拥有文件的对等方发送一个带散列标识符的HTTP请求）</li></ol><h2 id="CDN和视频"><a href="#CDN和视频" class="headerlink" title="CDN和视频"></a>CDN和视频</h2><p>视频编码</p><p>CBR（constant bit rate）：以固定速率编码</p><p>VBR（variable bit rate）：视频编码速率随时间变化而变化</p><h3 id="多媒体流化服务：DASH"><a href="#多媒体流化服务：DASH" class="headerlink" title="多媒体流化服务：DASH"></a>多媒体流化服务：DASH</h3><p>DASH：Dynamic，Adaptive Streaming over HTTP</p><p>服务器：</p><ul><li>将视频文件分隔为多个块</li><li>每个块独立存储，编码于不同码率</li><li>告示文件（manifest file）：提供不同块的URL</li></ul><p>客户端：客户端自适应决定</p><ul><li>先获取告示文件</li><li>周期性的测量服务器到客户端的带宽</li><li>查询告示文件，在一个时刻请求一个块，HTTP头部指定字节范围</li></ul><p>CDN，全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验。两种方式</p><ul><li>enter deep：将CDN服务器深入到许多接入网。更接近用户，数量多。离用户近，管理困难。</li><li>bring home ：部署在少数关键位置。采用租用线路，将服务器连接起来</li></ul><p>CDN：在CDN节点中存储内容的拷贝。用户从CDN请求内容。</p><p>案例Netflix</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210928172552365.png" alt="image-20210928172552365"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-图-笔记</title>
      <link href="2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE-%E7%AC%94%E8%AE%B0/"/>
      <url>2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>图：表示“多对多”的关系</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210925094453444.png" alt="image-20210925094453444"></p><p>顶点：通常用 V（Vertex）表示顶点集合</p><p>边：通常用E(Edge)表示边的集合</p><ul><li>边是顶点对 :无向边 (a,b)  a——b</li><li>有向边 &lt;a,b&gt; 表示从a指向b的边  （单行线） a—-&gt;b</li></ul><blockquote><p>不考虑重边（例如有向边两个顶点只有一条）和自回路（不会有自己到自己的边）</p></blockquote><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>利用<strong>邻接矩阵</strong>，来用一维数组存储图，就可以只用存储红色的部分。</p><p>在下面的图里，我们要找的是3列6行的元素。在数组中对应的下标为</p><p>(i * ( i + 2 ) ) / 2 + j ) </p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210925134051486.png" alt="image-20210925134051486"></p><p>邻接矩阵的优点</p><ol><li>直观，简单，方便检查任意一对顶点间是否存在边</li><li>方便找任一顶点的所有“邻接点”（有边直接相连的顶点）</li><li>方便计算任一节点的 “度” （从该点出发的边数为“出度”，指向该点的边数为“入度”<ul><li>无向图：对应行（列）的非0元素的个数</li><li>有向图：对应行非0元素的个数是“出度”，对应列非0元素的个数是“入度”</li></ul></li></ol><p><strong>缺点</strong></p><ul><li>浪费空间—存储稀疏的时候，有大量无效元素，但是如果稠密的话，就不会有这个问题</li><li>浪费时间—统计稀疏图中一共有多少边</li></ul><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>G[n]为指针数组，对应矩阵每行一个链表，存非零元素</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210925135626928.png" alt="image-20210925135626928"></p><p>方便找任一顶点所有的“邻接点”</p><p>节约稀疏图的空间</p><p>无向图：方便计算度</p><p>有向图：只能计算“出度”，入度需要构造“逆邻接表”来计算入度</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先搜索（Depth-First-Search，DFS）"><a href="#深度优先搜索（Depth-First-Search，DFS）" class="headerlink" title="深度优先搜索（Depth First Search，DFS）"></a>深度优先搜索（Depth First Search，DFS）</h3><p><strong>时间复杂度</strong>(N为顶点个数，E为边的个数)</p><ul><li>用邻接表存储图，有o(N+E)</li><li>用邻接矩阵存储图，有O(N^2)</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210925142830720.png" alt="image-20210925142830720"></p><p>从白方块那里设为入口，设为黄色，在视野内有三个节点没走过。走其中一个节点那边去，也设为黄色。以此类推，走到视野中没有没去过的节点，一个一个原路返回，看看还有没有没走过的节点。有就继续进入。直到回到初始位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 邻接表存储的图 - DFS */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">( Vertex V )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在访问顶点%d\n&quot;</span>, V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Visited[]为全局变量，已经初始化为false */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">( LGraph Graph, Vertex V, <span class="keyword">void</span> (*Visit)(Vertex) )</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 以V为出发点对邻接表存储的图Graph进行DFS搜索 */</span></span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    </span><br><span class="line">    Visit( V ); <span class="comment">/* 访问第V个顶点 */</span></span><br><span class="line">    Visited[V] = <span class="literal">true</span>; <span class="comment">/* 标记V已访问 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) <span class="comment">/* 对V的每个邻接点W-&gt;AdjV */</span></span><br><span class="line">        <span class="keyword">if</span> ( !Visited[W-&gt;AdjV] )    <span class="comment">/* 若W-&gt;AdjV未被访问 */</span></span><br><span class="line">            DFS( Graph, W-&gt;AdjV, Visit );    <span class="comment">/* 则递归访问之 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先搜索（Breadth-First-Search，BFS）"><a href="#广度优先搜索（Breadth-First-Search，BFS）" class="headerlink" title="广度优先搜索（Breadth First Search，BFS）"></a>广度优先搜索（Breadth First Search，BFS）</h3><p><strong>时间复杂度</strong>(N为顶点个数，E为边的个数)</p><ul><li>用邻接表存储图，有O(N+E)</li><li>用邻接矩阵存储图，有O(N^2)</li></ul><p>这是遍历的图，并非是图的存储结构</p><p>中心节点进入队列进行标示，然后出队，查看他的其他几条边，把几个顶点都入队并且标示，然后依次出队，重复操作。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210925143834719.png" alt="image-20210925143834719"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 邻接矩阵存储的图 - BFS */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* IsEdge(Graph, V, W)检查&lt;V, W&gt;是否图Graph中的一条边，即W是否V的邻接点。  */</span></span><br><span class="line"><span class="comment">/* 此函数根据图的不同类型要做不同的实现，关键取决于对不存在的边的表示方法。*/</span></span><br><span class="line"><span class="comment">/* 例如对有权图, 如果不存在的边被初始化为INFINITY, 则函数实现如下:         */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEdge</span><span class="params">( MGraph Graph, Vertex V, Vertex W )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Graph-&gt;G[V][W]&lt;INFINITY ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Visited[]为全局变量，已经初始化为false */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span> <span class="params">( MGraph Graph, Vertex S, <span class="keyword">void</span> (*Visit)(Vertex) )</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索 */</span></span><br><span class="line">    Queue Q;     </span><br><span class="line">    Vertex V, W;</span><br><span class="line"></span><br><span class="line">    Q = CreateQueue( MaxSize ); <span class="comment">/* 创建空队列, MaxSize为外部定义的常数 */</span></span><br><span class="line">    <span class="comment">/* 访问顶点S：此处可根据具体访问需要改写 */</span></span><br><span class="line">    Visit( S );</span><br><span class="line">    Visited[S] = <span class="literal">true</span>; <span class="comment">/* 标记S已访问 */</span></span><br><span class="line">    AddQ(Q, S); <span class="comment">/* S入队列 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( !IsEmpty(Q) ) &#123;</span><br><span class="line">        V = DeleteQ(Q);  <span class="comment">/* 弹出V */</span></span><br><span class="line">        <span class="keyword">for</span>( W=<span class="number">0</span>; W&lt;Graph-&gt;Nv; W++ ) <span class="comment">/* 对图中的每个顶点W */</span></span><br><span class="line">            <span class="comment">/* 若W是V的邻接点并且未访问过 */</span></span><br><span class="line">            <span class="keyword">if</span> ( !Visited[W] &amp;&amp; IsEdge(Graph, V, W) ) &#123;</span><br><span class="line">                <span class="comment">/* 访问顶点W */</span></span><br><span class="line">                Visit( W );</span><br><span class="line">                Visited[W] = <span class="literal">true</span>; <span class="comment">/* 标记W已访问 */</span></span><br><span class="line">                AddQ(Q, W); <span class="comment">/* W入队列 */</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="comment">/* while结束*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图不连通的情况"><a href="#图不连通的情况" class="headerlink" title="图不连通的情况"></a>图不连通的情况</h3><p><strong>连通</strong>：如果v到w存在一条（无向）<strong>路径</strong>，则称v和w连通。</p><p><strong>路径</strong>：v到w的路径是一系列的顶点（v，v1，v2，v3…..vn，w)的集合。其中任一对相邻的顶点间都有图中的边。<strong>路径的长度</strong>是路径中的边数。如果v到w之间的所有顶点都不同，称为<strong>简单路径</strong>。非简单路径就是有回路的。</p><p><strong>回路</strong>：起点等于终点的路径</p><p><strong>连通图</strong>：图中任意两顶点均连通</p><h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><p><strong>连通分量</strong>：无向图的<strong>极大</strong>连通子图</p><ul><li>极大顶点数：再加1个顶点就不连通了</li><li>极大边数：包含子图中所有顶点相连的所有边</li><li>例</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210925145633349.png" alt="image-20210925145633349"></p><h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><p><strong>强连通：</strong>有向图中顶点v和w之间存在双向路径，则称v和w是强连通的</p><p><strong>强连通图：</strong>有向图中任意两顶点均强连通</p><p><strong>强连通分量：</strong>有向图的极大强连通子图</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210925145925936.png" alt="image-20210925145925936"></p><p>这里后面两个图都是强连通图。</p><p>代码实现</p><p>原理：遍历DFS，然后图不连通的部分，因为这个程序会遍历图，所以不存在遍历不到的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">ListComponents</span>(<span class="params">Graph G</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(each V <span class="keyword">in</span> G)&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">DFS(V); <span class="comment">/*or BFS(V)*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="邻接矩阵-1"><a href="#邻接矩阵-1" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p><strong>数据类型 - 图 - 边</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode MGraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> *<span class="title">PtrToENode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToENode Edge;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;<span class="comment">//顶点数</span></span><br><span class="line">    <span class="keyword">int</span> Ne;<span class="comment">//边数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> G[MaxVertexNum][MaxVertexNum]; <span class="comment">//描述边</span></span><br><span class="line">    <span class="keyword">char</span> data[MaxVertexNum];  <span class="comment">//数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>&#123;</span></span><br><span class="line">    Vertex V1,V2;</span><br><span class="line">    <span class="keyword">int</span> Weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>数据类型 - 方法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图初始化</span></span><br><span class="line"><span class="function">MGraph <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> VertexNum)</span></span>&#123;</span><br><span class="line">    Vertex V,W;</span><br><span class="line">    MGraph Graph;</span><br><span class="line"></span><br><span class="line">    Graph = (MGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认从0开始</span></span><br><span class="line">    <span class="keyword">for</span>(V=<span class="number">0</span>; V&lt;Graph-&gt;Nv;V++)&#123;</span><br><span class="line">        <span class="keyword">for</span> ( W = <span class="number">0</span>; W &lt; Graph-&gt;Nv; W++)</span><br><span class="line">        &#123;</span><br><span class="line">            Graph-&gt;G[V][W] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向MGraph插入边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(MGraph Graph,Edge e)</span></span>&#123;</span><br><span class="line">    Graph-&gt;G[e-&gt;V1][e-&gt;V2]=e-&gt;Weight;</span><br><span class="line">    Graph-&gt;G[e-&gt;V2][e-&gt;V1]=e-&gt;Weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完整的建立图</span></span><br><span class="line"><span class="function">MGraph <span class="title">BuildGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    <span class="keyword">int</span> Nv,i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数 &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Nv);</span><br><span class="line">    Graph = CreateGraph(Nv);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入边的数量 &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Graph-&gt;Ne);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Graph-&gt;Ne!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        E = (Edge)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; Graph-&gt;Ne; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入边的V1,V2,Weight &quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight);</span><br><span class="line">            InsertEdge(Graph,E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( V = <span class="number">0</span>; V &lt; Graph-&gt;Nv; V++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入数据 &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c &quot;</span>,&amp;Graph-&gt;data[V]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻接表-1"><a href="#邻接表-1" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表有向图，因为无向图实现需要另起一个。所以就有向图进行实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Vertex data;</span><br><span class="line">    Edge next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Edge next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> <span class="title">AdjList</span>[<span class="title">MaxVertexNum</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjMatrix</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AdjMatrix</span>&#123;</span></span><br><span class="line">    AdjList adjList;</span><br><span class="line">    <span class="keyword">int</span> Nv,Ne;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode Graph;</span><br><span class="line"></span><br><span class="line"><span class="function">Graph <span class="title">createGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Graph G;</span><br><span class="line">    Edge edge;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    G = (Graph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AdjMatrix));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;顶点数nv 边数Ne &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;G-&gt;Nv,&amp;G-&gt;Ne);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; G-&gt;Nv; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顶点数据&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;data);</span><br><span class="line">        G-&gt;adjList[i].data=data;</span><br><span class="line">        G-&gt;adjList[i].next=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;边&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; G-&gt;Ne; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp,EdgeData;</span><br><span class="line">        <span class="comment">//顶点加入边</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入的边&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入的边数据&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;EdgeData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//头插入</span></span><br><span class="line">        edge = (Edge*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Edge));</span><br><span class="line">        edge-&gt;data=EdgeData;</span><br><span class="line"></span><br><span class="line">        edge-&gt;next=G-&gt;adjList[temp].next;</span><br><span class="line">        G-&gt;adjList[temp].next=edge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Graph G = createGraph();</span><br><span class="line">    <span class="comment">//未写遍历</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(自顶向下)第一章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>Internet从具体构成角度</p><ul><li><p>节点</p><ul><li>主机及其运行的应用程序</li><li>路由器，交换机等网络交换设备</li></ul></li><li><p>边，通信链路</p><ul><li>接入网链路，主机链接到互联网的链路</li><li>主干链路，路由器间的链路</li></ul></li><li><p>协议</p></li></ul><p><strong>网络结构</strong></p><ul><li>网络边缘<ul><li>主机</li><li>应用程序（客户端和服务器）</li></ul></li><li>网络核心<ul><li>互联着的路由器</li><li>网络的网络</li></ul></li><li>接入网，物理媒体<ul><li>有线或者无线通信链路</li></ul></li></ul><h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a><strong>网络边缘</strong></h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210923130211740.png" alt="image-20210923130211740"></p><ul><li>端系统（主机）<ul><li>运行应用程序</li></ul></li><li>C/S 模式<ul><li>客户端向服务器请求，接收服务</li></ul></li><li>对等（peer-peer）模式</li></ul><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a><strong>网络核心</strong></h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210923130236308.png" alt="image-20210923130236308"></p><p>路由器的网状网络</p><p>数据传输</p><ul><li><p><strong>电路交换</strong>：给每个呼叫预留一条专用网络。不共享资源。如果呼叫没有发送数据，分配的线路就会空闲被浪费。</p><p><strong>缺点</strong>：连接建立时间长，计算机之间的通信并不是一直在通信，可靠性不高</p><p>网络资源被分成<strong>片</strong>，为呼叫分配片。将带宽分成片。</p><ul><li><p>频分（Frequency-division multiplexing）</p></li><li><p>时分（Time-division multiplexing）</p></li><li><p>波分（Wave-division multiplexing）</p></li><li><p>例，下面就是FDM TDM的电路交换网。FDM频分，TDM时分。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210923130312349.png" alt="image-20210923130312349"></p></li></ul></li><li><p>分组交换：</p><p>以分组为单位存储-转发，资源共享，按需使用</p><p>网络带宽全部使用。不进行分片。传输的数据分为一个一个分组。分组在一个个路由器中存储-转发，分组每次移动一跳（hop）。</p><ul><li>转发之前，节点必须收到整个分组</li><li>延迟比线路交换更大</li><li>排队时间</li></ul><p>按照有无网络连接，分为</p><ul><li><p>数据报网络：分组的目标地址决定下一跳，在不同的阶段，路由可以改变。类似问路</p></li><li><p>虚电路网络：每个分组都带标签，标签决定下一跳，在呼叫建立时决定路径，在整个呼叫中路径保持不变，路由器维持每个呼叫的状态信息</p></li></ul></li></ul><p>  排队和延迟</p><p>  如果到达速率 &gt; 链路的输出速率，分组就会进行排队，如果路由器中缓存用完，分组会被抛弃。</p><p>  <img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210923131413170.png" alt="image-20210923131413170"></p><p><strong>网络核心关键功能</strong></p><p>路由：决定分组采用的源到目标的路径</p><p>转发：将分组从路由器的输入链路转移到输出链路</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210923183733149.png" alt="image-20210923183733149"></p><h3 id="接入网和物理媒体"><a href="#接入网和物理媒体" class="headerlink" title="接入网和物理媒体"></a><strong>接入网和物理媒体</strong></h3><ul><li>住宅接入网络 modem</li><li>单位接入网络（学校，公司）</li><li>无线接入网络</li></ul><p><strong>物理媒体</strong></p><p>Bit：在发送-接收对间传播</p><p>物理链路：连接每个发送-接收对之间的物理媒体</p><ul><li>导引型媒体：信号沿着固体媒介被引导：同轴电缆，光纤，双绞线</li><li>非导引型媒体：开放的空间传输电磁波或者光信号，在电磁或者光信号中承载数字数据</li></ul><h3 id="Internet结构和ISP"><a href="#Internet结构和ISP" class="headerlink" title="Internet结构和ISP"></a>Internet结构和ISP</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210923192647785.png" alt="image-20210923192647785"></p><p>IXP是内容提供商，如谷歌，微软在全球架构服务器。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210923192738024.png" alt="image-20210923192738024"></p><h3 id="分组延时，丢失和吞吐量"><a href="#分组延时，丢失和吞吐量" class="headerlink" title="分组延时，丢失和吞吐量"></a>分组延时，丢失和吞吐量</h3><p>四种分组延时</p><ol><li><p>节点处理延时</p><ul><li>检查bit级差错，检查分组首部和决定将分组导向何处</li></ul></li><li><p><strong>排队延时</strong></p><ul><li>在输出链路上等待传输的时间，依赖于路由器的拥塞程度</li><li>R=链路带宽  L=分组长度(bits)   a=分组到达队列的平均速率   流量强度= La/R<ul><li>La/R ~ 0 :平均排队延时很小</li><li>La/R -&gt; 1: 延时变的很大</li><li>La/R &gt; 1:比特到达队列的速率超过了从该队列输出的速率，平均排队延时趋向于无穷大</li></ul></li></ul></li><li><p>传输延时</p><ul><li><p>R=链路带宽(bps)  L=分组长度(bits) 将分组发送到链路上的时间=L/R</p></li><li><p>节点通过路由器所花的时间</p></li></ul></li><li><p>传播延时</p><ul><li><p>d=物理链路的长度   s=在媒体上的传播速度   传播延时=d/s</p></li><li><p>节点从这个路由器到下个路由器的传播时间</p></li></ul></li></ol><p><strong>分组丢失</strong></p><p>链路的队列缓冲区有限，当分组到达一个满的队列时，该分组将会丢失。丢失的分组可能会被前一个节点或源端重传，或者根本不重传。</p><p><strong>吞吐量</strong></p><p>在源端和目标端直接传输的速率（数据量/单位时间）</p><ul><li>瞬间吞吐量：在一个时间点的速率</li><li>平均吞吐量：在一个长时间内的平均值</li></ul><p>端到端的路径中，根据水桶原理，是最小的带宽决定的。</p><h3 id="协议层次及服务模型"><a href="#协议层次及服务模型" class="headerlink" title="协议层次及服务模型"></a>协议层次及服务模型</h3><ul><li>服务（service）：低层实体向上层实体提供它们之间的通信的能力。分为面向连接的服务和无连接的服务<ul><li>服务用户（Service User)</li><li>服务提供者（Service provider）</li></ul></li><li>原语（primitive）：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互</li><li>服务访问点SAP（Service Acess Point）：上层使用下层的服务通过层间的接口</li></ul><p>服务和协议的区别</p><ul><li>服务：低层实体向上层实体提供它们直接通信的能力，是通过原语来操作的。垂直</li><li>协议：对等层实体之间在相互通信的过程中，需要遵循的规则的集合。水平。</li></ul><p>它们直接的联系</p><ul><li>本层协议的实现要靠下层提供服务来实现</li><li>本层实体通过协议为上层提供更高级的服务</li></ul><h4 id="Internet协议栈"><a href="#Internet协议栈" class="headerlink" title="Internet协议栈"></a>Internet协议栈</h4><ul><li>应用层 <strong>报文（message）</strong>：网络应用<ul><li>为人类用户或其他应用进程提供网络应用服务</li><li>FTP，SMTP，HTTP，DNS</li></ul></li><li>传输层 <strong>报文段（segment）Tcp段，UDP数据报</strong>：主机之间的数据传输<ul><li>在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠的通信变为可靠的通信</li><li>TCP,UDP</li></ul></li><li>网络层 <strong>分组packet（如果无连接方式，：数据报datagram）</strong>：为数据报从源到目的选择路由<ul><li>主机之间的通信，端到端通信，不可靠</li><li>IP，路由协议</li></ul></li><li>链路层 <strong>帧（frame）</strong>：相邻网络节点间的数据传输<ul><li>2个相邻2点的通信，点到点通信，可靠或不可靠</li><li>点对点协议PPP，802.11（wifi），Ethernet</li></ul></li><li>物理层 <strong>位（bit）</strong>：在线路上传送bit</li></ul><p><strong>ISO/OSI参考模型</strong></p><p>表示层，会话层，在应用层和传输层中间。互联网协议栈没有这两层。</p><ul><li>表示层：允许应用解释传输的数据。e.g，加密，压缩，机器相关的表示转换</li><li>会话层：数据交换的同步，检查点，恢复</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210923200155311.png" alt="封装和解封装"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-树-笔记</title>
      <link href="2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E7%AC%94%E8%AE%B0/"/>
      <url>2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>基本术语</p><ol><li><strong>结点的度</strong>（Degree）：结点的<strong>子树个数</strong></li><li><strong>树的度</strong>：树的所有节点中最大的度数</li><li><strong>叶结点</strong>（Leaf）：<strong>度为0</strong>的节点</li><li><strong>父结点</strong>（Parent）：若一个节点含有子结点，则这个节点称为其节点的父节点</li><li><strong>子结点</strong>（Child）：若A结点是B节点的父结点，则B节点是A节点的子结点，也称孩子节点</li><li><strong>兄弟节点</strong>（Sibling）：具有同一父结点的各结点彼此是兄弟结点</li><li><strong>路径和路径长度</strong>：从结点N1到Nk的路径为一个节点序列，节点的个数为路径的长度</li><li><strong>祖先节点</strong>（Ancestor）：沿树根到某一节点路径上所有节点都是这个节点的祖先节点</li><li><strong>子孙节点</strong>（Descendant）：某一节点的子树中的所有节点是这个节点的子孙</li><li><strong>节点的层次</strong>（Level）：规定根节点在1层</li><li><strong>树的深度</strong>（Depth）：树中所有结点中的最大层次是这棵树的深度</li></ol><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>特殊二叉树</strong></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210902145632268.png" alt="image-20210902145632268"></p><p><strong>重要性质</strong></p><ul><li>一个二叉树第 i 层 的最大结点数为：2^(i-1) , i&gt;=1</li><li>深度为k的二叉树有最大结点总数为：2^k-1,k&gt;=1</li><li><strong>对任何非空二叉树T，若n0表示叶结点的个数，n2是度为2的非叶结点个数，那么两者关系满足 n0=n2+1</strong></li></ul><p><strong>遍历方法</strong></p><ol><li>先序——根，左子树，右子树</li><li>中序——左子树，根，右子树</li><li>后序—–左子树，右子树，根</li><li>层次遍历—从上到下，从左到右（一层一层的遍历，从左到右）</li></ol><h4 id="代码实现-递归-全部代码"><a href="#代码实现-递归-全部代码" class="headerlink" title="代码实现-递归-全部代码"></a>代码实现-递归-全部代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">createTree</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    Tree t;</span><br><span class="line">    <span class="comment">//分配堆栈空间</span></span><br><span class="line">    t=(Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TNode));</span><br><span class="line">    t-&gt;Data = value;</span><br><span class="line">    t-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTraversalRecursion</span><span class="params">(Tree t)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 先序遍历 递归 根 左 右</span></span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">        PreTraversalRecursion(t-&gt;Left);</span><br><span class="line">        PreTraversalRecursion(t-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiddleTraversalRecursion</span><span class="params">(Tree t)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 中序遍历 递归，左 根 右</span></span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        MiddleTraversalRecursion(t-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">        MiddleTraversalRecursion(t-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostTraversalRecursion</span><span class="params">(Tree t)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 后序遍历 递归，左 右 根</span></span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostTraversalRecursion(t-&gt;Left);</span><br><span class="line">        PostTraversalRecursion(t-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(Tree t,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 0 已有，1插入成功</span></span><br><span class="line">    <span class="keyword">if</span>(t-&gt;Data == data)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前节点数据已有&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;Data &gt; data)&#123;</span><br><span class="line">        <span class="comment">// 进左</span></span><br><span class="line">        <span class="comment">// printf(&quot;数据小于当前节点\n t.data = %d&quot;,t-&gt;Data);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;左\n&quot;);</span></span><br><span class="line">            judgeDataExistAndPosition(t-&gt;Left,data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Tree temp;</span><br><span class="line">            temp = createTree(data);</span><br><span class="line">            t-&gt;Left = temp;</span><br><span class="line">            <span class="comment">// free(temp);</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d进左\n&quot;</span>,t-&gt;Left-&gt;Data);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;Data &lt; data)&#123;</span><br><span class="line">        <span class="comment">// 进右</span></span><br><span class="line">        <span class="comment">// printf(&quot;\n数据大于当前节点\n t.data = %d&quot;,t-&gt;Data);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;右&quot;);</span></span><br><span class="line">            judgeDataExistAndPosition(t-&gt;Right,data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Tree temp;</span><br><span class="line">            temp = createTree(data);</span><br><span class="line">            t-&gt;Right = temp;</span><br><span class="line">            <span class="comment">// free(temp);</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d进右\n&quot;</span>,t-&gt;Right-&gt;Data);</span><br><span class="line">            <span class="comment">// t-&gt;Data = data;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Tree t = createTree(<span class="number">4</span>);</span><br><span class="line">    add(t,<span class="number">5</span>);</span><br><span class="line">    add(t,<span class="number">2</span>);</span><br><span class="line">    add(t,<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    PostTraversalRecursion(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码实现-非递归-全部代码"><a href="#代码实现-非递归-全部代码" class="headerlink" title="代码实现-非递归-全部代码"></a>代码实现-非递归-全部代码</h4><p>放上了堆栈的代码，所以看起来有点多。其中后序与中序先序不同。用了不一样的方法。</p><p>具体思路是。先入栈，到最左边之后判断右子树，遍历完全部右子树之后。再进行出栈。也就是说第一次回退不是出栈，只是取栈顶元素。等右子树判断之后再进行出栈操作。</p><ol><li>对当前节点判断是否存在左子树，存在压入栈中。置flag为1，表示判断过一次左子树。</li><li>当当前节点不存在，需要出栈了。分为两种情况，<ul><li>一种是flag=1时，是左子树到顶，取栈顶元素，我们设置flag为2，且进入右子树。</li><li>一种是flag=2时，右子树到顶，需要出栈。打印并出栈</li></ul></li></ol><p>即可解决后序非递归二叉树遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArrayStack</span> *<span class="title">Stack</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArrayStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Tree *data;</span><br><span class="line">    Position top;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">createStack</span><span class="params">(<span class="keyword">int</span> maxsize)</span></span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    <span class="comment">// 分配 堆栈和数据的空间</span></span><br><span class="line">    s=(Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ArrayStack));</span><br><span class="line">    s-&gt;data=(Tree *)<span class="built_in">malloc</span>(maxsize*<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    </span><br><span class="line">    s-&gt;top=<span class="number">-1</span>;</span><br><span class="line">    s-&gt;MaxSize=maxsize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isFull</span><span class="params">(Stack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s-&gt;top==s-&gt;MaxSize<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(Stack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s-&gt;top==<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">push</span><span class="params">(Stack s,Tree data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isFull(s))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s-&gt;data[++(s-&gt;top)]=data;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">pop</span><span class="params">(Stack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s-&gt;data[(s-&gt;top--)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">getNode</span><span class="params">(Stack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">createTree</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    Tree t;</span><br><span class="line">    <span class="comment">//分配堆栈空间</span></span><br><span class="line">    t=(Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TNode));</span><br><span class="line">    t-&gt;Data = value;</span><br><span class="line">    t-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(Tree bt)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;先序遍历&quot;</span>);</span><br><span class="line">    Tree t = bt;</span><br><span class="line">    Stack s = createStack(Maxsize);</span><br><span class="line">    <span class="keyword">while</span>(t || !isEmpty(s))&#123;</span><br><span class="line">        <span class="keyword">while</span>(t)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">            push(s,t);</span><br><span class="line">            t = t-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isEmpty(s))&#123;</span><br><span class="line">            t = pop(s);</span><br><span class="line">            t = t-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiddleOrderTraversal</span><span class="params">(Tree bt)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">    Tree t = bt;</span><br><span class="line">    <span class="comment">// 非递归中序遍历   使用堆栈</span></span><br><span class="line">    Stack s = createStack(Maxsize);</span><br><span class="line">    <span class="keyword">while</span>(t || !isEmpty(s))&#123;</span><br><span class="line">        <span class="keyword">while</span> (t)</span><br><span class="line">        &#123;</span><br><span class="line">            push(s,t);</span><br><span class="line">            t=t-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isEmpty(s))&#123;</span><br><span class="line">            t = pop(s);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">            t = t-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(Tree bt)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;后序遍历&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> flagTag[Maxsize];</span><br><span class="line">    Tree t = bt;</span><br><span class="line">    <span class="comment">// 非递归后序遍历   使用堆栈</span></span><br><span class="line">    Stack s = createStack(Maxsize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t || !isEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            push(s,t);</span><br><span class="line">            flagTag[s-&gt;top]=<span class="number">1</span>;</span><br><span class="line">            t=t-&gt;Left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(flagTag[s-&gt;top]==<span class="number">1</span>)&#123;</span><br><span class="line">                t = getNode(s);</span><br><span class="line">                flagTag[s-&gt;top]=<span class="number">2</span>;</span><br><span class="line">                t = t-&gt;Right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t = pop(s);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">                t = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(Tree t,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 0 已有，1插入成功</span></span><br><span class="line">    <span class="keyword">if</span>(t-&gt;Data == data)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前节点数据已有&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;Data &gt; data)&#123;</span><br><span class="line">        <span class="comment">// 进左</span></span><br><span class="line">        <span class="comment">// printf(&quot;数据小于当前节点\n t.data = %d&quot;,t-&gt;Data);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;左\n&quot;);</span></span><br><span class="line">            add(t-&gt;Left,data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Tree temp;</span><br><span class="line">            temp = createTree(data);</span><br><span class="line">            t-&gt;Left = temp;</span><br><span class="line">            <span class="comment">// free(temp);</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d进左\n&quot;</span>,t-&gt;Left-&gt;Data);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;Data &lt; data)&#123;</span><br><span class="line">        <span class="comment">// 进右</span></span><br><span class="line">        <span class="comment">// printf(&quot;\n数据大于当前节点\n t.data = %d&quot;,t-&gt;Data);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;右&quot;);</span></span><br><span class="line">            add(t-&gt;Right,data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Tree temp;</span><br><span class="line">            temp = createTree(data);</span><br><span class="line">            t-&gt;Right = temp;</span><br><span class="line">            <span class="comment">// free(temp);</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d进右\n&quot;</span>,t-&gt;Right-&gt;Data);</span><br><span class="line">            <span class="comment">// t-&gt;Data = data;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Tree t = createTree(<span class="number">10</span>);</span><br><span class="line">    add(t,<span class="number">11</span>);</span><br><span class="line">    add(t,<span class="number">4</span>);</span><br><span class="line">    add(t,<span class="number">3</span>);</span><br><span class="line">    add(t,<span class="number">5</span>);</span><br><span class="line">    add(t,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    PostOrderTraversal(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>思路：根节点入队</p><ol><li>从队列里面取出元素，访问其左右节点。</li><li>将左右节点入队。输出队列拿出来的节点。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">(Tree bt)</span></span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    Tree t;</span><br><span class="line">    <span class="keyword">if</span>(!bt)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Q = createQueue(Maxsize);</span><br><span class="line">    AddQ(q,bt);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        T = DeleteQ(Q); <span class="comment">//取出队列中的节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Left) AddQ(Q,t-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Right) AddQ(Q,t-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树（BST-Binary-Search-Tree"><a href="#二叉搜索树（BST-Binary-Search-Tree" class="headerlink" title="二叉搜索树（BST, Binary Search Tree)"></a>二叉搜索树（BST, Binary Search Tree)</h4><p>也称二叉排序树，二叉查找树。两个条件</p><ul><li>非空左子树比父结点以及根节点小</li><li>非空右子树比父结点和根节点大</li></ul><h5 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h5><p>从根节点开始，树为空返回NULL。树非空则将节点与需要查找的字段左比较。</p><ul><li>如果相等，返回此节点指针</li><li>如果小于当前节点，则进入左子树</li><li>如果大于当前节点，则进入右子树</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法</span></span><br><span class="line"><span class="function">Tree <span class="title">Find</span><span class="params">(<span class="keyword">char</span> data,Tree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>( data &gt; BST-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> Find(data,BST-&gt;Right);<span class="comment">//进入右子树查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data &lt; BST-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> Find(data,BST-&gt;Left);<span class="comment">//进入左子树查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BST;<span class="comment">//查找成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归算法</span></span><br><span class="line"><span class="function">Tree <span class="title">Find</span><span class="params">(<span class="keyword">char</span> data,Tree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(BST)&#123;</span><br><span class="line">        <span class="keyword">if</span>(data &gt; BST-&gt;data)</span><br><span class="line">            BST=BST-&gt;Right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data &lt; BST-&gt;Left)</span><br><span class="line">            BST=BST-&gt;Left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> BST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找最大元素最小元素</span></span><br><span class="line"><span class="comment">//最小-只查找左子树，向最左边查找</span></span><br><span class="line"><span class="function">Tree <span class="title">FindMin</span><span class="params">(Tree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Left)</span><br><span class="line">        <span class="keyword">return</span> BST;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> FindMin(BST-&gt;Left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最大-只查找右子树，向最右边查找</span></span><br><span class="line"><span class="function">Tree <span class="title">FindMax</span><span class="params">(Tree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST)</span><br><span class="line">        <span class="keyword">while</span>(BST-&gt;Right) BST=BST-&gt;Right;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二叉搜索树插入与删除"><a href="#二叉搜索树插入与删除" class="headerlink" title="二叉搜索树插入与删除"></a>二叉搜索树插入与删除</h5><p>插入操作在上面二叉树的代码中，add就已经实现了。这里不进行实现</p><p>删除分多种情况</p><ol><li>删除叶结点，直接进行删除。将其父结点指针变成NULL</li><li>删除有一个孩子节点，将其父结点指向孩子节点</li><li>删除的节点有两个孩子节点，用左子树的最大元素，或者右子树的最小元素。代替此节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function">Tree <span class="title">Delete</span><span class="params">(<span class="keyword">char</span> data,Tree BST)</span></span>&#123;</span><br><span class="line">    Position Tmp;</span><br><span class="line">    <span class="keyword">if</span>(BST==<span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;要删除的元素未找到&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data &lt; BST-&gt;data)</span><br><span class="line">        BST-&gt;Left = Delete(data,BST-&gt;Left);<span class="comment">//左子树递归</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data &gt; BST-&gt;data)</span><br><span class="line">        BST-&gt;Right = Delete(data,BST-&gt;Right);<span class="comment">//右子树递归</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//找到删除的节点</span></span><br><span class="line">    <span class="keyword">if</span>(BST-&gt;Left &amp;&amp; BST-&gt;Right)&#123;</span><br><span class="line">            <span class="comment">//有一个节点或没有节点</span></span><br><span class="line">            Tmp = FindMin(BST-&gt;Right);</span><br><span class="line">            BST-&gt;data = Tmp-&gt;data;</span><br><span class="line">            BST-&gt;Right = Delete(BST-&gt;data,BST-&gt;Right);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//有两个节点</span></span><br><span class="line">            Tmp=BST;</span><br><span class="line">            <span class="keyword">if</span>(!BST-&gt;Left)</span><br><span class="line">                BST =BST-&gt;Right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Right)</span><br><span class="line">                BST=BST-&gt;Right;</span><br><span class="line">            <span class="built_in">free</span>(Tmp);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树-AVL树"></a>平衡二叉树-AVL树</h4><p><strong>平衡因子（BalanceFactor，BF)</strong>: BF(T) = h(l)-h(r)</p><p>平衡二叉树：空树，或者任一结点左，右子树的高度差绝对值不超过1，|BF(T)|&lt;=1。</p><p><strong>RR旋转</strong></p><p>因为是破坏了右子树的右子树，所以是RR。LL类似</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210921113634245.png" alt="image-20210921113634245"></p><p><strong>LR-RL</strong></p><p>其中 Jan破坏的是先左，后右。用红线标出来了。所以应该是将Mar，Aug，May取中间数，当做其根节点。进行旋转。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210921113904653.png" alt="image-20210921113904653"></p><h3 id="森林-树"><a href="#森林-树" class="headerlink" title="森林-树"></a>森林-树</h3><p>这里是树与二叉链表的对应关系，看图中解释的部分</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211219141939599.png" alt="image-20211219141939599"></p><p>森林与二叉树的关系</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211219142123630.png" alt="image-20211219142123630"></p><ul><li><p>森林转换成二叉树</p><p>如果F={T1,T2,……Tm}是森林，则可按如下规则转换成一颗二叉树B={root,LB,RB}</p><ol><li>若F为空，m=0,则B为空树</li><li>若F非空，则B的根(root) 作为森林中第一棵树的根ROOT(T1)；B的左子树LB是从T1中根节点的子树森林F1={T11,T12,T13….}转换成的二叉树；右子树RB是从森林F’={T2,T3…..Tm}转换成的二叉树</li></ol></li><li><p>二叉树转换成森林</p><p>如果B=(root,LB,RB)是一颗二叉树，则可按如下规则转换为森林F={T1,T2…..Tm}</p><ol><li>若B为空，则F为空</li><li>若B非空，则F中第一棵树T1的根 ROOT(T1) 为二叉树B的根root；T1中的根节点的子树森林F1是由B的左子树LB转换而成的森林；F中除了T1，其余的组成森林F’={T2,T3…..Tm} 是由B的右子树RB转换而成的森林</li></ol></li></ul><h4 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h4><p>EX：对上面第一张图的遍历</p><p>​         先序：ABCDE   后序：BDCEA</p><ol><li><p>先序遍历</p><p>若森林非空</p><ol><li>访问森林中第一颗的根节点</li><li>先序遍历第一棵树中根节点的子树森林</li><li>先序遍历 除去  第一棵树之后剩余的树构成的森林</li></ol></li><li><p>中序遍历</p><ol><li>中序遍历森林中第一颗树的根节点的子树森林</li><li>访问第一棵树的根节点</li><li>中序遍历 除去 第一棵树之后剩余的树构成的森林</li></ol></li></ol><p>所以可借用二叉树的遍历</p><hr><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><blockquote><p><strong>优先队列</strong>（Priority Queue)：特殊的“队列”，取出元素的顺序是依照元素的<strong>优先权（关键字）</strong>大小，而不是元素进入队列的先后顺序</p></blockquote><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210921131806349.png" alt="image-20210921131806349"></p><p>两个特性</p><p>结构性：用数组表示的完全二叉树</p><p>有序性：任意借点的关键字是其子树节点的最大值或最小值。</p><ul><li>最大堆，也称大顶堆，最大值</li><li>最小堆，小顶堆，最小值</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210921132003686.png" alt="image-20210921132003686"></p><h4 id="最大堆创建"><a href="#最大堆创建" class="headerlink" title="最大堆创建"></a>最大堆创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大堆创建</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">MaxHeap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>&#123;</span></span><br><span class="line">    ElementType *Elements;<span class="comment">//存储的堆元素</span></span><br><span class="line">    <span class="keyword">int</span> size;<span class="comment">//当前堆大小</span></span><br><span class="line">    <span class="keyword">int</span> Capacity;<span class="comment">//堆的总大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MaxHeap <span class="title">Create</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>&#123;</span><br><span class="line">    MaxHeap H = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*struct HeapStruct));</span><br><span class="line">    H-&gt;Elements = <span class="built_in">malloc</span>((Maxsize+<span class="number">1</span>) * <span class="keyword">sizeof</span>(ElementType));<span class="comment">//这里+1是因为数组是从1开始的下标，0位置是存的哨兵</span></span><br><span class="line">    H-&gt;size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;Capacity = Maxsize;</span><br><span class="line">    H-&gt;Elements[<span class="number">0</span>] = MaxData;<span class="comment">//这里MaxData是自己设置的哨兵，定为所有元素中可能最大的值</span></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处哨兵的作用是，定义一个可能最大的值，防止后面调整位置的时候，会判断0位置，少做一次判断。</p><h4 id="最大堆插入"><a href="#最大堆插入" class="headerlink" title="最大堆插入"></a>最大堆插入</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210921132625064.png" alt="image-20210921132625064"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(MaxHeap H,ElementType item)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将元素item存进H堆中。Elements[0]为哨兵</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(IsFull(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大堆已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;Size;<span class="comment">//i 指向堆在插入元素后的最后一个位置</span></span><br><span class="line">    <span class="keyword">for</span>( ; H-&gt;Elements[<span class="number">1</span>/<span class="number">2</span>] &lt; item; i/=<span class="number">2</span>)</span><br><span class="line">        B-&gt;Elements[i] = H-&gt;Elements[<span class="number">1</span>/<span class="number">2</span>];<span class="comment">//如果插入的元素比上面的元素大，就要交换其位置</span></span><br><span class="line">    H-&gt;Elements[i] = item;<span class="comment">//插入item</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里哨兵发挥了作用，因为他不小于任何堆里的元素。所以在i=1时，不用去判断是不是到1了。直接 i/2 就会与哨兵判断就可以少一次判断</p><h4 id="最大堆删除"><a href="#最大堆删除" class="headerlink" title="最大堆删除"></a>最大堆删除</h4><p>将44删除，将最下面的节点放到根节点。然后进行判断是否为最大堆，如果不是就进行排序。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210921133212514.png" alt="image-20210921133212514"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">DeleteMax</span><span class="params">(MaxHeap H)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从最大堆取出最大的元素，并删除一个节点</span></span><br><span class="line">    <span class="keyword">int</span> parent,child;</span><br><span class="line">    ElementType MaxItem,temp;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大堆已空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MaxItem = H-&gt;Elements[<span class="number">1</span>];<span class="comment">//取出根节点最大值</span></span><br><span class="line"> temp = H-&gt;Elements[H-&gt;Size--];<span class="comment">//获取下面的节点</span></span><br><span class="line">    <span class="comment">//parent*2就是左子树的下标。+1就是右子树</span></span><br><span class="line">    <span class="keyword">for</span>(parent=<span class="number">1</span>;parent*<span class="number">2</span>&lt;=H-&gt;Size; parent=child)&#123;</span><br><span class="line">        child = parent*<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//这里判断有没有左子树，并且判断左右子树谁大。</span></span><br><span class="line">        <span class="keyword">if</span>((child!=H-&gt;size) &amp;&amp; (H-&gt;Elements[child]&lt; H-&gt;Elements[child+<span class="number">1</span>]))</span><br><span class="line">            child++;</span><br><span class="line">        <span class="comment">//判断节点的大小。如果大于就不动，如果小了就进行换位</span></span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= H-&gt;Elements[child]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            H-&gt;Elements[parent] = H-&gt;Elements[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> Maxitem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>带权路径长度(WPL)：设二叉树有N个叶子节点，每个叶子节点带有权值W_k，从根节点到每个叶子节点长度为 l_k ，则每个叶子节点的带权路径长度只和就是：</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20211219144847466.png" alt="image-20211219144847466"></p><p><strong>最优二叉树</strong>或<strong>哈夫曼树：WPL</strong>最小的二叉树</p><p>哈夫曼树特点</p><ul><li>没有度为1的节点</li><li>n个叶子节点的哈夫曼树共有2n-1个节点</li><li>哈夫曼树任意非叶子的左右子树交换仍然是哈夫曼树</li><li>同一组权值，存在不同构的哈夫曼树</li></ul><p>哈夫曼树的构造：每次吧<strong>权值最小的两颗二叉树合并</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    HuffmanTree Left,Right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffmanTree <span class="title">Huffman</span><span class="params">(MinHeap H)</span></span>&#123;</span><br><span class="line"><span class="comment">//我们所有节点假设权值已经算好在weight中</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    BuildMinHeap(H);<span class="comment">//构建最小堆</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt; H-&gt;size; i++)&#123;</span><br><span class="line">        T=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">        <span class="comment">//从最小堆删除节点，作为左节点和右节点</span></span><br><span class="line">        T-&gt;Left = DeleteMin(H);</span><br><span class="line">        T-&gt;Right = DeleteMin(H);</span><br><span class="line">        <span class="comment">//计算新的权值</span></span><br><span class="line">        T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight;</span><br><span class="line">        <span class="comment">//插入最小堆</span></span><br><span class="line">        Insert(H,T);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T = DeleteMin(H);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>哈夫曼编码</strong></p><p>使用不等长编码，利用前缀码perfix code（任何字符的编码都不是另一字符编码的前缀）</p><p>利用二叉树，只有叶子节点存值</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210925132454649.png" alt="image-20210925132454649"></p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>用树来表示集合</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20210925132810197.png" alt="image-20210925132810197"></p><p>这三个分别是不同的集合。每个子节点指向父节点的下标</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 顶部导航栏</title>
      <link href="2021/Android-%E9%A1%B6%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F/"/>
      <url>2021/Android-%E9%A1%B6%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>顶部应用栏，有两种可以实现的方法，一种是用5.0之后的Toolbar，一种是我们自己写导航。</p><h2 id="自定义ActionBar"><a href="#自定义ActionBar" class="headerlink" title="自定义ActionBar"></a>自定义ActionBar</h2><ol><li><p>取消系统自带的主题，在values/theme中，改为NoActionBar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.LazyBookkeeping&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在layout中创建导航栏的布局</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/navigationbar_title&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;</span><br><span class="line">        android:textColor=&quot;@color/white&quot;</span><br><span class="line">        android:textSize=&quot;20sp&quot;</span><br><span class="line">        app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/monthly_expenditure&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_marginEnd=&quot;300dp&quot;</span><br><span class="line">        android:layout_marginRight=&quot;300dp&quot;</span><br><span class="line">        android:textColor=&quot;@color/white&quot;</span><br><span class="line">        android:textSize=&quot;20sp&quot;</span><br><span class="line">        app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toBottomOf=&quot;@+id/navigationbar_title&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在activity_main.xml中定义导航栏</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;cn.yvenxx.lazybookkeeping.topGlobalNavigationBar</span><br><span class="line">                android:id=&quot;@+id/topNavigation_bar&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;</span><br><span class="line">                android:fitsSystemWindows=&quot;true&quot;</span><br><span class="line">                app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">                app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">                app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义导航栏相对的Java类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">topGlobalNavigationBar</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TextView tvTitle;</span><br><span class="line">    <span class="keyword">private</span> View view;</span><br><span class="line">    <span class="keyword">private</span> TextView monthly_expenditure;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">topGlobalNavigationBar</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">topGlobalNavigationBar</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">topGlobalNavigationBar</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        view = inflate(context, R.layout.topnavigationbar, <span class="keyword">this</span>);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span></span>&#123;</span><br><span class="line">        tvTitle = view.findViewById(R.id.navigationbar_title);</span><br><span class="line">        monthly_expenditure = view.findViewById(R.id.monthly_expenditure);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTvTitle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String date = Utils.getDate();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        tvTitle.setText(date);</span><br><span class="line"></span><br><span class="line">        monthly_expenditure.setGravity(Gravity.START);</span><br><span class="line">        monthly_expenditure.setText(<span class="string">&quot;月支出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在MainActivity类中实现ActionBar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//        顶部自定义栏</span></span><br><span class="line">    topGlobalNavigationBar topGlobalNavigationBar = findViewById(R.id.topNavigation_bar);</span><br><span class="line">    topGlobalNavigationBar.setTvTitle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);<span class="comment">//设置透明导航栏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这就可以实现基本的导航栏。可以自行更改界面配置。</p></li></ol><h2 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h2><p>Toolbar在应用窗口的顶部提供的是一个固定的位置，可以随着页面改变而改变。</p><ol><li><p>先取消主题，在res/value/theme 中，改为NoActionBar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.LazyBookkeeping&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在active_main.xml中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;Toolbar</span><br><span class="line">         android:id=&quot;@+id/tool_bar&quot;</span><br><span class="line">         android:layout_width=&quot;match_parent&quot;</span><br><span class="line">         android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">         android:minHeight=&quot;?attr/actionBarSize&quot;</span><br><span class="line">         android:background=&quot;#FFFFFF&quot;</span><br><span class="line">         app:popupTheme=&quot;@menu/topbar&quot;</span><br><span class="line">         android:fitsSystemWindows=&quot;true&quot;&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/tool_bar_title&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:layout_gravity=&quot;center&quot;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">Toolbar</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在res/menu 创建menu文件。没有menu文件夹可以创建。这里没添加内容，可以自行添加。</p><p>[文档]: <a href="https://developer.android.com/guide/topics/ui/menus">https://developer.android.com/guide/topics/ui/menus</a>    “”文档””</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>MainActivity.java，记得调用init()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        toolbar = (Toolbar) findViewById(R.id.tool_bar);</span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line"></span><br><span class="line">        setTitle();</span><br><span class="line"></span><br><span class="line">        toolbar.inflateMenu(R.menu.topbar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO流</title>
      <link href="2021/Java-IO%E6%B5%81/"/>
      <url>2021/Java-IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><p>IO是指 Input  –  Output，即输入和输出，以内存为中心</p><p>input从外部读入数据到内存。output从内存输出到外部。</p><p>这些输入输出流的来源地和目的地可以是文件，也可以是网络连接，甚至是内存块。</p><p>其中Stream是进行处理字节的，而Reader和Writer是用来处理字符的，他们衍生的子类命名也都是以这些后缀结束的。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20201119153701157.png" alt="image-20201119153701157"></p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="读字节-InputStream"><a href="#读字节-InputStream" class="headerlink" title="读字节 InputStream"></a>读字节 InputStream</h3><p>读（IputStream） 类有一个抽象方法，read()，这个方法读入一个字节，并返回读入的字节。或者在输入源结尾时返回-1。</p><p>一个读取操作如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用try finally</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    InputStream is =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用try resource</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算机系统中，我们打开了一个资源使用完了需要进行关闭。以便让操作系统把资源释放到，否则应用程序占用的资源会越来越多。</p><p>InputStream,OutputStream都是通过close关闭资源的。</p><p>在我们第一个代码中，我们看到 InputStream is = null;  然后在try里面进行了数据的读操作。但是如果读操作失败了。程序就会跳到finally中，如果我们没有对is进行不等于null的判断，那么就是is操作还没有完成就会被关闭掉。这是不正常的关闭。</p><p>而第二个代码块中，我们使用的是java 7之后支持的 try(resource) 的写法，只需要编写try语句，编译器就会为我们自动关闭资源。</p><blockquote><p>实际上，编译器并不会特别地为<code>InputStream</code>加上自动关闭。编译器只看<code>try(resource = ...)</code>中的对象是否实现了<code>java.lang.AutoCloseable</code>接口，如果实现了，就自动加上<code>finally</code>语句并调用<code>close()</code>方法。<code>InputStream</code>和<code>OutputStream</code>都实现了这个接口，因此，都可以用在<code>try(resource)</code>中。</p></blockquote><h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><p>在我们读取流的时候，一个一个读取并不是最高效的。大多数流支持一次性读取多个字节到缓冲区。InputStream支持读取多个字节填充到byte数据中。</p><ul><li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li><li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li></ul><p>利用上述方法一次读取多个字节时，需要先定义一个<code>byte[]</code>数组作为缓冲区，<code>read()</code>方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。<code>read()</code>方法的返回值不再是字节的<code>int</code>值，而是返回实际读取了多少个字节。如果返回<code>-1</code>，表示没有更多的数据了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BufferInputStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">//三个字节读一次</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写字节-OutputStream"><a href="#写字节-OutputStream" class="headerlink" title="写字节-OutputStream"></a>写字节-OutputStream</h3><p>OutputStream也是一个抽象类，抽象了write(int b)方法</p><p>要注意的是 int b虽然是int参数。但是每次写入还是只能写入一个字节。</p><p>OutputStream还定义了一个flush()方法，目的是将缓冲区中的内容输出到目的地。因为在写入数据的时候，处于效率的考虑，操作系统不是写入一个字节就发送一个字节。而是当缓冲区满了之后在发出去。而flush方法可以强制性的将缓冲区的内容发送到目的地。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次读入一个字节</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        os.write(<span class="number">10</span>);</span><br><span class="line">        os.write(<span class="number">108</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次读入多个字节</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        os.write(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>在InputStream和outputStream中，读写的操作是阻塞的。也就是说，这个线程在进行读取的时候，不能进行下面的操作，需要等到读写完毕之后，才能运行下面的语句。</p><h3 id="copy文件的实现"><a href="#copy文件的实现" class="headerlink" title="copy文件的实现"></a>copy文件的实现</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">copy</span>(<span class="params"><span class="built_in">String</span> path,<span class="built_in">String</span> copyPath</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">try</span>(<span class="params">InputStream is = <span class="keyword">new</span> FileInputStream(path)</span>)</span> &#123;</span><br><span class="line">        int len;</span><br><span class="line">        byte[] buf = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="function"><span class="title">try</span>(<span class="params">OutputStream os = <span class="keyword">new</span> FileOutputStream(copyPath)</span>)</span> &#123;</span><br><span class="line">                os.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Filter-组合输入-输出流过滤器"><a href="#Filter-组合输入-输出流过滤器" class="headerlink" title="Filter 组合输入/输出流过滤器"></a>Filter 组合输入/输出流过滤器</h2><p>DataInputStream只能读入数据类型，而FileInputStream可以提供在磁盘上读取文件的一个输入流。</p><p>其中DataInputStream不能进行读写磁盘，FileInputStream不能进行数值的读写。</p><p>但是Java使用了一种灵巧的机制可以将二者进行结合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream file = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(file);</span><br><span class="line"></span><br><span class="line">file.readInt(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这样的话FileInputStream基础智商高，可以附加额外的功能。</p><p>还可以使用这样的嵌套机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">    <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)));</span><br></pre></td></tr></table></figure><p>我们将DataInputStream放在构造器链的最后，是希望使用DataInputStream的read方法且带有缓冲机制。</p><h2 id="输入输出字符"><a href="#输入输出字符" class="headerlink" title="输入输出字符"></a>输入输出字符</h2><h3 id="输入-Reader"><a href="#输入-Reader" class="headerlink" title="输入-Reader"></a>输入-Reader</h3><p>Reader是Java Io库中的另外一个输入流。和InputStream的区别是，InputStream是byte为单位进行读取。而Reader是字符流，字符单位进行读取的(char);</p><p>使用时需要指定编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取单个字符</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReaderTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;test.txt&quot;</span>,StandardCharsets.UTF-<span class="number">8</span>))&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fileReader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取多个字符</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReaderTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;test.txt&quot;</span>),,StandardCharsets.UTF-<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = fileReader.read(chars))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(chars);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-Writer"><a href="#输出-Writer" class="headerlink" title="输出-Writer"></a>输出-Writer</h3><p>基本原理和输入流的概念相同===直接上例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(Writer w = <span class="keyword">new</span> FileWriter(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        w.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e )&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="copy文件的实现-1"><a href="#copy文件的实现-1" class="headerlink" title="copy文件的实现"></a>copy文件的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Reader r = <span class="keyword">new</span> FileReader(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = r.read(chars))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> (Writer w = <span class="keyword">new</span> FileWriter(<span class="string">&quot;test2.txt&quot;</span>))&#123;</span><br><span class="line">                w.write(chars,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓冲流-提高流的读取写入的速度"><a href="#缓冲流-提高流的读取写入的速度" class="headerlink" title="缓冲流-提高流的读取写入的速度"></a>缓冲流-提高流的读取写入的速度</h2><p>内部提供了一个缓冲区。增加读写速度。</p><p>使用用例：copy文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BufferStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)))&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(buf)) != -<span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">try</span> (BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>)))&#123;</span><br><span class="line">                bos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符流操作基本相同，不进行演示。</p><h2 id="IO转换流"><a href="#IO转换流" class="headerlink" title="IO转换流"></a>IO转换流</h2><p>属于字符流</p><p>inputStreamReader，将一个字节的输入流转换为字符的输入流</p><p>OutputStreamWriter，将一个字符的输出流转换为字节的输出流</p><p>inputStreamReader用例，用字节流读出文件，使用转换流进行转换并输出，其中用了嵌套调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InputStreamReaderTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStreamReader is = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(cbuf))!= -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(cbuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>outputStreamWriter用例，将字符文件读取出来，用另外一种编码方式，使用转换流进行编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputStreamWriterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStreamReader is = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)))&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(cbuf))!= -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> (OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>),<span class="string">&quot;gbk&quot;</span>))&#123;</span><br><span class="line">                osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标准输入输出流（了解）"><a href="#标准输入输出流（了解）" class="headerlink" title="标准输入输出流（了解）"></a>标准输入输出流（了解）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStreamReader is = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(is);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        String s = br.readLine();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equals(s)||<span class="string">&quot;exit&quot;</span>.equals(s))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;------finish------&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>DataInputStream，DataOutputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line">    dos.writeUTF(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">    dos.writeInt(<span class="number">1</span>);</span><br><span class="line">    dos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>ObjectInputStream，ObjectOutputStream，用于存储和读取<strong>基本数据类型数据</strong>或<strong>对象</strong>的处理流。可以吧Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p><ul><li><p>序列化：用ObjectOutputStream类<strong>保存</strong>基本类型数据或对象的机制</p></li><li><p>反序列化：用ObjectInputStream类<strong>读取</strong>基本类型数据或对象的机制</p></li></ul><p>ObjectOutputStream和ObjectInputStream不能序列化<strong>static</strong>和<strong>transient</strong>修饰的成员变量</p><ul><li><p>对象的序列化机制：允许吧内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久的保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其他程序获得了这个二进制流，就可以恢复成原来的Java对象</p></li><li><p>序列化的好处在于可将任何实现了Serializable接口的对象转换为字节数据，使其在保存和传输时可被还原。</p></li><li><p>要想某个类能够被序列化，需要实现序列化接口。加上序列端口号（serialVersionUID)</p><ul><li>必须加上serialVersionUID，如果没加上，在实例的时候会自动给serialVersionUID赋值，但是如果类的实例变量做了修改，serialVersionUID可能发生变化。</li><li>而且，除了本类需要序列化，类中的属性也必须都支持序列化</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ObjectOutputStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;object.dat&quot;</span>)))&#123;</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ObjectInputStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;object.dat&quot;</span>))) &#123;</span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        String str = (String) o;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h2><ul><li><p>直接继承与Object，实现了DataInput，DataOutput接口，既可以作为输入流，也可以作为输出流</p></li><li><p>如果RandomAccessFile类作为一个输出流，写出的文件不存在时，则在执行过程中自动创建。如果写出的文件存在，则会对原油文件内容覆盖，从头覆盖。</p></li></ul><p>方法</p><ul><li>seek(int x);  seek可以将指针调整到x的位置。</li></ul><p>文件的复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RandomAccessFile r1 = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    RandomAccessFile r2 = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test1.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = r1.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        r2.write(buf,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    r1.close();</span><br><span class="line">    r2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为了看起来方便所以没用使用try-catch-finally，实际使用中需要使用try-catch-finally</p><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>Java NIO（new IO)是从java1.4版本开始引入的新io api。与原有的io有同样的作用和目的。但是会有一些区别</p><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流(Stream Oriented)</td><td>面向缓冲区(Buffer Oriented)</td></tr><tr><td>阻塞IO(blocking IO)</td><td>非阻塞IO(Non Blocking IO)</td></tr><tr><td>无</td><td>选择器(Selectors)</td></tr></tbody></table><h2 id="通道和缓冲区"><a href="#通道和缓冲区" class="headerlink" title="通道和缓冲区"></a>通道和缓冲区</h2><p>通道（channel）负责传输，buffer（缓冲区）负责存储</p><p>核心在于，通道表示打开到IO设备的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。</p><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><ul><li><p>缓冲区(Buffer)：一个用于<strong>特定基本类型的容器</strong>。由java.nio包定义的。所有缓冲区都是Buffer抽象类的子类。</p></li><li><p>Java Nio中的Buffer主要用于与Nio通道进行交互，数据是从<strong>通道读入缓冲区</strong>，从<strong>缓冲区写入通道中</strong>的。</p></li></ul><ol><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ol><p>都采用相似的方法进行管理数据，只是各自管理的数据类型不同。</p><p>通过如下方法获取一个Buffer对象</p><p><strong>static xxxBuffer  allocate(int capacity); 创建一个容量为capacity的xxxBuffer对象</strong></p><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><ul><li>容量(Capacity)：表示Buffer最大数据容量，缓冲区容量不能为负，且创建后不能更改</li><li>限制(limit)：不应该被读取或写入的数据的索引，也就是说，位于limit后的数据不可读写，缓冲区的限制不能为负，并且不能大于其容量</li><li>位置(position):下一个要读写数据的索引，缓冲区的位置不能为负，并且不能大于其限制。</li><li>标记(mark)与重置(reset)：标记是一个索引，通过mark方法标记一个位置，通过reset可以回到这个位置。</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20201120143549483.png" alt="image-20201120143549483"></p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20201120143929945.png" alt="image-20201120143929945"></p><h4 id="缓冲区的数据操作"><a href="#缓冲区的数据操作" class="headerlink" title="缓冲区的数据操作"></a>缓冲区的数据操作</h4><p>Buffer所有子类提供了俩个用于数据操作的方法：get()与put()方法</p><ul><li>获取Buffer中的数据<ul><li>get()：获取单个字节</li><li>get(byte[] dst): 批量读取多个字节到dst中</li><li>get(int index)：读取指定索引位置的字节（不会移动position)</li></ul></li><li>放入数据到Buffer中<ul><li>​    put(byte b ); 将给定单个字节写入缓冲区的当前位置</li><li>put(byte[] src) 将src中的字节写入缓冲区的当前位置</li><li>put(int index, byte b) 将指定字节写入缓冲区的索引位置（不会移动position）</li></ul></li></ul><h2 id="直接缓冲区和非直接缓冲区"><a href="#直接缓冲区和非直接缓冲区" class="headerlink" title="直接缓冲区和非直接缓冲区"></a>直接缓冲区和非直接缓冲区</h2><ul><li>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则java虚拟机会尽最大努力直接在此缓冲区上执行本机I/O操作。也就是说，在每次调用基础操作系统的一个本机I/O操作之前 / 之后   ，虚拟机都会尽量避免缓冲区的内容复制到中间缓冲区中。（或从中间缓冲区复制内容）</li><li>直接字节缓冲区可以通过调用此类的<strong>allocateDirect()工厂方法</strong>来创建。此方法返回的<strong>缓冲区进行分配和取消分配所需成本通常 高于 非直接缓冲区</strong>。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，他们对应用程序的内存需求造成的影响可能不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机I/O操作影响的大型持久的缓冲区，一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显的好处时分配他们。</li><li>直接字节缓冲区还可以通过<strong>FileChannel的map()方法</strong>将文件区域直接映射到内存中来创建。该方法返回<strong>MappedByteBuffer</strong>。Java平台的实现有助于通过JNI从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。</li><li>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其isDirect()方法来确定。提供此方法为了能够在性能关键型代码中执行显式缓冲区管理。</li></ul><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20201120192145057.png" alt="image-20201120192145057"></p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20201120192154588.png" alt="image-20201120192154588"></p><h2 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h2><p>通道：由java.nio.channels包定义。表示io源与目标打开的连接。类似于传统的”流“。只不过不能直接访问数据，只能与buffer进行交互。</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20201120194239570.png" alt="image-20201120194239570"></p><ul><li>FileChannel：用于读取，写入，映射和操作文件的通道</li><li>DatagramChannel：通过UDP读写网络中的数据通道</li><li>SocketChannel：通过Tcp读写网络中的数据</li><li>ServerSocketChannel：可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel</li></ul><h3 id="获取通道"><a href="#获取通道" class="headerlink" title="获取通道"></a>获取通道</h3><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20201120194520338.png" alt="image-20201120194520338"></p><h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20201120194533240.png" alt="image-20201120194533240"></p><h2 id="分散（Scatter）聚集（Gather"><a href="#分散（Scatter）聚集（Gather" class="headerlink" title="分散（Scatter）聚集（Gather)"></a>分散（Scatter）聚集（Gather)</h2><p>分散是指一个channel的数据，分散到多个缓冲区。</p><p>聚集是指多个buffer聚集到一个channel中。</p><p>所有操作都需要try-catch，这里只是为了看的层次感。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分散读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ScatterAndGatherTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    FileChannel fisChannel = fis.getChannel();</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">    ByteBuffer buffer2 = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    ByteBuffer[] buffers = &#123;buffer1,buffer2&#125;;</span><br><span class="line">    fisChannel.read(buffers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分散读取</span></span><br><span class="line">    <span class="keyword">for</span> (ByteBuffer buffer : buffers) &#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//聚集写入</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line">    FileChannel fosChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">    fosChannel.write(buffers);</span><br><span class="line"></span><br><span class="line">    fis.close();</span><br><span class="line">    fisChannel.close();</span><br><span class="line">    fos.close();</span><br><span class="line">    fosChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TransferTo—-TransferFrom"><a href="#TransferTo—-TransferFrom" class="headerlink" title="TransferTo—-TransferFrom"></a>TransferTo—-TransferFrom</h2><p>将数据从源通道传输到其他Channel</p><h3 id="TransferFrom"><a href="#TransferFrom" class="headerlink" title="TransferFrom"></a>TransferFrom</h3><p>使用输出流的channel，from表示从哪里来，所以用输出流调用此方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransferFrom</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TransferFromTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FileChannel fisChannel = fis.getChannel();</span><br><span class="line">    FileChannel fosChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">    fosChannel.transferFrom(fisChannel,<span class="number">0</span>, fisChannel.size());</span><br><span class="line"></span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">    fisChannel.close();</span><br><span class="line">    fosChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="TransferTo"><a href="#TransferTo" class="headerlink" title="TransferTo"></a>TransferTo</h3><p>使用输入流channel调用，表示数据到哪里去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransferTo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TransferToTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FileChannel fisChannel = fis.getChannel();</span><br><span class="line">    FileChannel fosChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">    fisChannel.transferTo(<span class="number">0</span>, fisChannel.size(),fosChannel);</span><br><span class="line"></span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">    fisChannel.close();</span><br><span class="line">    fosChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FileChannel常用方法"><a href="#FileChannel常用方法" class="headerlink" title="FileChannel常用方法"></a>FileChannel常用方法</h2><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20201120205445563.png" alt="image-20201120205445563"></p><h2 id="NIO非阻塞式网络通信"><a href="#NIO非阻塞式网络通信" class="headerlink" title="NIO非阻塞式网络通信"></a>NIO非阻塞式网络通信</h2><p>传统的IO流都是阻塞式的。而JavaNIO是非阻塞的。当线程从某同道进行读写数据时，若没有数据可同时，该线程可以进行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行Io操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO可以让服务器端使用一个或有限几个线程来同时处理连接到服务端的所有客户端。</p><h3 id="选择器Selector"><a href="#选择器Selector" class="headerlink" title="选择器Selector"></a>选择器Selector</h3><p>选择器（Selector） 是 SelectableChannle 对象的多路复用器，<strong>Selector 可以同时监控多个 SelectableChannel 的 IO 状况</strong>，也就是说，利用 <strong>Selector 可使一个单独的线程管理多个 Channel</strong>。Selector 是非阻塞 IO 的核心。</p><p>Selector结构</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20201122135131145.png" alt="image-20201122135131145"></p><h3 id="Tcp模式的Selector非阻塞"><a href="#Tcp模式的Selector非阻塞" class="headerlink" title="Tcp模式的Selector非阻塞"></a>Tcp模式的Selector非阻塞</h3><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SocketChannel sChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9898</span>))) &#123;</span><br><span class="line">        <span class="comment">//设置非阻塞模式</span></span><br><span class="line">        sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            String s = sc.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;exit&quot;</span>.equals(s))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf.put(s.getBytes());</span><br><span class="line">            buf.flip();</span><br><span class="line">            sChannel.write(buf);</span><br><span class="line">            buf.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SocketChannel sChannel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> (ServerSocketChannel ssChannel = ServerSocketChannel.open())&#123;</span><br><span class="line"><span class="comment">//设置非阻塞模式</span></span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//绑定端口</span></span><br><span class="line">        ssChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line"><span class="comment">//获取选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"><span class="comment">//向选择器注册通道</span></span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否有选择器被注册</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select()&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//获取注册器的SelectedKeys迭代器</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                SelectionKey sk = it.next();</span><br><span class="line">                <span class="comment">//是否接受就绪</span></span><br><span class="line">                <span class="keyword">if</span> (sk.isAcceptable())&#123;</span><br><span class="line">                    sChannel = ssChannel.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    sChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//是否可读就绪</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sk.isReadable())&#123;</span><br><span class="line">                    sChannel = (SocketChannel)sk.channel();</span><br><span class="line">                    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                    ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((len = sChannel.read(buf))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        buf.flip();</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(buf.array(),<span class="number">0</span>,len));</span><br><span class="line">                        buf.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定</p><p>可以监听的事件类型（<strong>可使用</strong> <strong>SelectionKey</strong> <strong>的四个常量表示</strong>）：</p><ul><li><p> 读 : SelectionKey.OP_READ （1） </p></li><li><p> 写 : SelectionKey.OP_WRITE （4） </p></li><li><p> 连接 : SelectionKey.OP_CONNECT （8） </p></li><li><p> 接收 : SelectionKey.OP_ACCEPT （16） </p></li></ul><h4 id="Selector常用方法"><a href="#Selector常用方法" class="headerlink" title="Selector常用方法"></a>Selector常用方法</h4><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20201122152338158.png" alt="image-20201122152338158"></p><h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p>连接到Tcp网络套接字的通道</p><p>操作步骤</p><ol><li>打开SocketChannel</li><li>读写数据</li><li>关闭SocketChannel</li></ol><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h4><ul><li><p>能发送Udp包的通道</p></li><li><p>操作步骤</p><ol><li>打开DatagramChannel</li><li>接受/发送数据</li></ol></li></ul><p>UDP基本和Tcp一样</p><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramChannel dc = DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">    dc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (scan.hasNext())&#123;</span><br><span class="line">        String s = scan.nextLine();</span><br><span class="line">        buf.put(s.getBytes());</span><br><span class="line"></span><br><span class="line">        buf.flip();</span><br><span class="line">        dc.send(buf,<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9898</span>));</span><br><span class="line">        buf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    dc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramChannel dc = DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">    dc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    dc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line"></span><br><span class="line">    Selector selector= Selector.open();</span><br><span class="line"></span><br><span class="line">    dc.register(selector,SelectionKey.OP_READ);</span><br><span class="line">    <span class="keyword">while</span> (selector.select()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            SelectionKey sk = it.next();</span><br><span class="line">            <span class="keyword">if</span> (sk.isReadable())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">                ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                dc.receive(buf);</span><br><span class="line">                buf.flip();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(buf.array(),<span class="number">0</span>,buf.limit()));</span><br><span class="line">                buf.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    dc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pipe（管道）"><a href="#Pipe（管道）" class="headerlink" title="Pipe（管道）"></a>Pipe（管道）</h2><p>管道是俩个线程之间的单向数据连接。Pipe有一个Source通道和一个Sink通道。</p><p>数据会被写入Sink通道，从Source通道接收读取</p><p><img src="https://blog-1257997408.cos.ap-guangzhou.myqcloud.com/images/image-20201122152654073.png" alt="image-20201122152654073"></p><p>这里将sink和source放在一个方法中了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String s = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Pipe pipe = Pipe.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sink</span></span><br><span class="line">    Pipe.SinkChannel sink = pipe.sink();</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    buffer.put(s.getBytes());</span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">        sink.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//source</span></span><br><span class="line">    Pipe.SourceChannel source = pipe.source();</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    source.read(buffer1);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(buffer1.array(),<span class="number">0</span>,buffer1.limit()));</span><br><span class="line"></span><br><span class="line">    source.close();</span><br><span class="line">    sink.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7 安装python3.x</title>
      <link href="2021/Centos7-%E5%AE%89%E8%A3%85python3-x/"/>
      <url>2021/Centos7-%E5%AE%89%E8%A3%85python3-x/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>Centos自带的是2.x的python，升级到3.x的版本</p><hr><p>下载python 官网地址:<a href="https://www.python.org/">https://www.python.org/</a></p><p>这里使用3.7版本的python</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#在Linux中运行</span><br><span class="line">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.7.3&#x2F;Python-3.7.3.tgz</span><br><span class="line"></span><br><span class="line">#解压 x.x.x是你的版本</span><br><span class="line">tar -xzvf Python-x.x.x.tgz </span><br><span class="line"></span><br><span class="line">#安装 其他python需要的包</span><br><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc  libffi-devel</span><br><span class="line"></span><br><span class="line">#编译安装 进入解压之后的python目录中</span><br><span class="line"># --prefix 指定安装位置</span><br><span class="line"># --enable-shared 共享库</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3.7 --enable-shared</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>make install之后 使用命令  echo $?</p><p>终端输出0就是没错。如果不是0就是有报错</p><p>没有报错的话。在/usr/local/ 中会有python3.7目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#安装完成之后</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><p><strong>备份系统自带的python2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv &#x2F;usr&#x2F;bin&#x2F;python &#x2F;usr&#x2F;bin&#x2F;python.bak</span><br></pre></td></tr></table></figure><p><strong>创建python3的软连接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python3.7&#x2F;bin&#x2F;python3.7 &#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"></span><br><span class="line">#检验一下 --如果是3.7版本就是成功了</span><br><span class="line">python -v</span><br></pre></td></tr></table></figure><p><strong>如果有报共享库错误，或者找不到xxx.lib文件</strong></p><h3 id="使用ldconfig命令"><a href="#使用ldconfig命令" class="headerlink" title="使用ldconfig命令"></a>使用ldconfig命令</h3><p>​    ldconfig /usr/local/python3.7/lib<br>​    即可</p><h3 id="因为python升级了，yum也需要改一下配置"><a href="#因为python升级了，yum也需要改一下配置" class="headerlink" title="因为python升级了，yum也需要改一下配置"></a>因为python升级了，yum也需要改一下配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;bin&#x2F;yum</span><br><span class="line">vim &#x2F;usr&#x2F;libexec&#x2F;urlgrabber-ext-down</span><br></pre></td></tr></table></figure><p>将开头的#/usr/bin/python 改为/usr/bin/python2</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言：指针</title>
      <link href="2021/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E6%8C%87%E9%92%88/"/>
      <url>2021/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>学习数据结构顺带记下。</p></blockquote><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针也可以理解为一个数据类型。指针类型，他不是一个具体的值，他保存的是一个地址。这个地址保存了其他的数据。（有点抽象）</p><p>可以这么理解。一个数组的下标就是地址。数组里面的值，才是保存的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *b = &amp;a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%d\n&quot;</span>,*b);</span><br><span class="line"></span><br><span class="line">    *b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%d\n&quot;</span>,*b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------输出结果——--------------</span><br><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="number">10</span></span><br><span class="line">a=<span class="number">20</span></span><br><span class="line">b=<span class="number">20</span></span><br></pre></td></tr></table></figure><p>可以看到，<em>b赋值20的时候，a也变为20了。\</em>b指向了a的地址。当改变b的值时，改变的是*b指向的地址那里的值。</p><ul><li><strong>“ &amp;（取址运算符）”:  取出变量的地址</strong></li><li>*<em>“ <em>+变量名 “ :  指针</em></em></li></ul><h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> temp)</span></span>&#123;</span><br><span class="line">    temp=<span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> *temp)</span></span>&#123;</span><br><span class="line">    temp=<span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    test1(a);</span><br><span class="line">    test2(&amp;b);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d&quot;</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line">--------------输出-------------</span><br><span class="line">a=<span class="number">10</span> b=<span class="number">999</span></span><br></pre></td></tr></table></figure><p>test1函数，并没有改变a的值。因为test1的temp是一个临时变量，改变的只是temp的值。</p><p>test2函数，是用指针来接收b的地址，修改了值之后，修改的是b位置的值。</p><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ary_set</span><span class="params">(<span class="keyword">int</span> v[],<span class="keyword">int</span> n ,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v[i]=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = a;</span><br><span class="line">    ary_set(&amp;a[<span class="number">2</span>],<span class="number">5</span>,<span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\na[%d] = %d  *(p+i)=%d&quot;</span>,i,a[i],*(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=========输出-=================</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>  *(p+i)=<span class="number">1</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span>  *(p+i)=<span class="number">2</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">99</span>  *(p+i)=<span class="number">99</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">99</span>  *(p+i)=<span class="number">99</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">99</span>  *(p+i)=<span class="number">99</span></span><br><span class="line">a[<span class="number">5</span>] = <span class="number">99</span>  *(p+i)=<span class="number">99</span></span><br><span class="line">a[<span class="number">6</span>] = <span class="number">99</span>  *(p+i)=<span class="number">99</span></span><br><span class="line">a[<span class="number">7</span>] = <span class="number">0</span>  *(p+i)=<span class="number">0</span></span><br></pre></td></tr></table></figure><ol><li>*p = a，指向 a[0]的地址  相当于  *p = &amp;a[0]。</li><li>p+1 = a[0+1]</li><li>思考：可以看到 数组只有5位，但是我们是从下标2开始赋值99，后面下标为6的值也为99。6已经超过了我们的数组长度。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Meta 的标签理解总结- Html</title>
      <link href="2021/Meta-%E7%9A%84%E6%A0%87%E7%AD%BE%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93-Html/"/>
      <url>2021/Meta-%E7%9A%84%E6%A0%87%E7%AD%BE%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93-Html/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>这俩天在搜索自己博客的时候，发现只有自己网页显示的内容。但是看了一下别人网页的首页和我一样没什么信息。但是在搜索引擎搜索的时候却有很多没看到的信息显示在上面。于是看了一下网页的源代码。发现搜索引擎出来的数据都是在meta标签中。于是重新去看了一下html的meta标签。</p><p>在之前的理解中，meta只有这个作用</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attribute">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="MDN中"><a href="#MDN中" class="headerlink" title="MDN中"></a>MDN中</h2><blockquote><p><strong>HTML meta 元素</strong>表示那些不能由其它HTML元相关元素 (style, base, link, script, title)之一表示的任何元数据信息。</p></blockquote><p>其中 meta 中文名 也叫 元数据（Metadata)</p><hr><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><p>meta 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。</p><hr><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="必要属性"><a href="#必要属性" class="headerlink" title="必要属性"></a>必要属性</h3><p><a href="https://imgchr.com/i/dEPgun"><img src="https://s1.ax1x.com/2020/08/16/dEPgun.md.png" alt="dEPgun.md.png"></a></p><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p><a href="https://imgchr.com/i/dEP2Bq"><img src="https://s1.ax1x.com/2020/08/16/dEP2Bq.md.png" alt="dEP2Bq.md.png"></a></p><hr><h4 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h4><ol><li><p>application-name，定义运行在该网页上的网络应用名称</p><p>这个没试过，就不写例子了。防止耽误人。</p></li></ol><ol start="2"><li><p>author，这个网页的作者。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yvenxx&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>description，包含网页中的精简的描述，网站的主要内容是什么，其中Firefox和Opera，将其用作书签的描述。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yven的个人博客，写一写技术总结，存放一些个人作品&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>keywords，搜索引擎所提取网页关键字。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yven，博客，后端，java&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>rebots，定义搜索引擎蜘蛛的的索引方式。告诉它哪些要索引哪些不要索引（值有很多）</p><p>值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.index----允许蜘蛛索引页面,也就是索引此页面。</span><br><span class="line">2.noindex----防止蜘蛛索引该页面</span><br><span class="line">3.follow----允许蜘蛛通过此页面的链接。索引其他页面。</span><br><span class="line">4.nofollow----防止蜘蛛索引此页面上的链接。</span><br><span class="line">5.noodp----禁止将Open Directory Project的描述，用作搜索引擎结果页面中页面的描述</span><br><span class="line">6.noarchive----防止搜索引擎缓存页面的内容</span><br><span class="line">7.nocache----与noarchive相同。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;rebots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>viewport，提供有关视图的初始大小，但仅对移动设备生效。</p><p>值</p><p><a href="https://imgchr.com/i/dEPRH0"><img src="https://s1.ax1x.com/2020/08/16/dEPRH0.md.png" alt="dEPRH0.md.png"></a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>copyright，版权信息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;copyright&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yvenxx&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><p>revisit-after，设置蜘蛛重新访问的时间</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;revisit-after&quot;</span> <span class="attr">content</span>=<span class="string">&quot;2 days&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="http-equiv属性–特定的Http头部"><a href="#http-equiv属性–特定的Http头部" class="headerlink" title="http-equiv属性–特定的Http头部"></a>http-equiv属性–特定的Http头部</h4><ol><li><p>content-type ,使用这个属性，值必须是”<code>text/html; charset=utf-8</code>“。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span></span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>x-ua-compatible，如果指定内容属性值必须为 IE=edge</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x-ua-compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span>&gt;</span>//指定ie和chrome渲染当前页</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>refresh，指定网页自动载入页面的时间间隔。有俩种用法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1，如果content只包含一个正整数，就是重新载入网页的时间。</span><br><span class="line">2，如果content包含了一个正整数，外加 ;url=xxxxx 则是重定向到那个网页的间隔时间。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;2;url=http://yvenxx.cn&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中还有部分的属性没有提到，还没有完全的了解。把常用的一些属性总结在了里面。</p><p>如果文章有错误的地方，希望各位指正。感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
