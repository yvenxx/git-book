<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机组成原理-第三章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020085556746.png" alt="image-20211020085556746"></p><p>主存带宽（Bm）：<strong>又称数据传输率</strong>，表示每秒从主存进出信息的最大数量，单位为 字/秒，字节/秒（B/s)或位/秒(b/s)</p><h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020090432859.png" alt="image-20211020090432859"></p><p>这里的原理是：8个存储元组成一个字节，当红色总线为高电平时，所有mos管导通，使其数据导出到绿色线，导入MDR</p><p><strong>存储芯片基本结构</strong></p><p>片选线：CS或CE（高电平有效，如果画一横就是低电平有效）</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020090643045.png" alt="image-20211020090643045"></p><p><strong>寻址</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020090910640.png" alt="image-20211020090910640"></p><p>如图4位一个字，如果按字寻址，第一个字偏移量0，第二个字左移两位就到了偏移量为4的位置</p><blockquote><p>还可按字节，半字，双字寻址</p></blockquote><h2 id="SRAM和DRAM"><a href="#SRAM和DRAM" class="headerlink" title="SRAM和DRAM"></a>SRAM和DRAM</h2><ul><li><p>DRAM用于主存，使用<strong>栅极电容</strong>存储信息</p><p>因为是电容放电信息被破坏才能读出（<strong>破坏性读出</strong>），读出后应有<strong>重写</strong>操作，也称“再生”。读写速度慢</p></li><li><p>SRAM用于Cache，使用<strong>双稳态触发器</strong>存储信息</p><p>读出数据，触发器状态保持稳定，是<strong>非破坏性读出，无须重写</strong>。读写速度快</p></li></ul><p><strong>双稳态触发器</strong></p><p>1：A高B低（输入1）</p><p>0：A低B高</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020094741786.png" alt="image-20211020094741786"></p><h3 id="DRMA刷新"><a href="#DRMA刷新" class="headerlink" title="DRMA刷新"></a>DRMA刷新</h3><p>刷新周期：一般2ms</p><p>以行为单位，每次刷新一行存储单元。用行列地址减少选通线的数量</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020095731169.png" alt="image-20211020095731169"></p><p>每次刷新一个存储单元，通过选中一行选中一列，来选中存储单元（必须行列都选中）。然后进行刷新（其中行列地址线可以共用，所以只需要一半的线路，芯片引脚数目也减少）</p><p>刷新思路</p><ul><li>分散刷新：每次读写完都刷新一行，系统存取时间变为1us，前半时间用于正常读写，后半用于刷新</li><li>集中刷新：2ms内几种安排时间全部刷新，存取周期0.5us，有一段时间专用与刷新，无法访问存储器，称为访存“死区”</li><li>异步刷新：2ms内每行刷新一次即可，2ms内需要产生128次刷新请求，每隔2ms/128=15.6us一次。每15.6us内有0.5us的 “死时间”</li></ul><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>MROM（Mask Read-Only Memory)—掩模式制度存储器（<strong>任何人不可重写）</strong></p><p>PROM（Programmable Read-Only Memory)–可编程只读存储器，<strong>写一次之后不可更改</strong></p><p>EPROM（Erasable Programmable Read-Only Memory）—-可擦除可编程只读存储器<strong>可进行多次重写</strong></p><p>Flash Memory—-闪速存储器（注：u盘，sd卡），<strong>可进行多次快速擦除重写，闪存的 写速度，比读速度慢</strong></p><p>SSD====固态  控制单元+FLASH芯片</p><p>ROM芯片：虽然名字为Read—Only，但很多ROM也可以“写”，ROM也具有“随机存取”的特性</p><blockquote><p>其中BIOS也是ROM，CPU将其和主存统一编址。所以有时主存也包括 内存条+BIOS</p></blockquote><h2 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h2><p>上面这张图中，就是译码器，控制电路与主存的连接。下面的图是整体结构。其中读写控制线（WE/WR，还是一样有一横为低电平有效反之高电平有效）</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020090643045.png" alt="image-20211020090643045"></p><h3 id="增加主存的存储字长-位扩展"><a href="#增加主存的存储字长-位扩展" class="headerlink" title="增加主存的存储字长-位扩展"></a>增加主存的存储字长-位扩展</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020105422663.png" alt="image-20211020105422663"></p><p>具体是扩展数据总线连接的芯片。这里只有两个芯片分别连接 D0，D1，还空出来2-7，可以再增加几个芯片进行位扩展。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020105603876.png" alt="image-20211020105603876"></p><p>8片 8k<em>1位的存储芯片—–&gt;变为1位 8k\</em>8位的存储器，容量8KB</p><h3 id="增加主存的存储字数-字扩展"><a href="#增加主存的存储字数-字扩展" class="headerlink" title="增加主存的存储字数-字扩展"></a>增加主存的存储字数-字扩展</h3><p><strong>线选法</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020110033811.png" alt="image-20211020110033811"></p><p>数据总线的位置每个芯片已经包含了所有。地址总线A13-15并没有进行使用。</p><p>其中第一块芯片和第二块芯片连接A13。其中第二块的线位置进行了一次取反（不取反会两个芯片都为1/0，在数据总线位置会发生冲突，取反后两个接收信号不相同，避免冲突）</p><p><strong>译码片选法</strong></p><p>先对译码器进行解释</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020111036953.png" alt="image-20211020111036953"></p><p>整体图</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020111110530.png" alt="image-20211020111110530"></p><table><thead><tr><th>线选法</th><th>译码片选法</th></tr></thead><tbody><tr><td>n条线–&gt;n个选片信号</td><td>n条线–&gt;2^n个选片信号</td></tr><tr><td>电路简单</td><td>电路复杂</td></tr><tr><td>地址空间不连续</td><td>地址空间可连续，可增加逻辑设计</td></tr></tbody></table><h3 id="字位同时扩展"><a href="#字位同时扩展" class="headerlink" title="字位同时扩展"></a>字位同时扩展</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020111319651.png" alt="image-20211020111319651"></p><p>拿红色框起来的两个芯片来说，两个芯片数据线分别占CPU数据线的一半，字扩展的线两个芯片公用同一条线，进行同时计算</p><h2 id="双口RAM多模块存储器"><a href="#双口RAM多模块存储器" class="headerlink" title="双口RAM多模块存储器"></a>双口RAM多模块存储器</h2><p><strong>存取周期=存取时间+恢复时间</strong></p><h3 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020131704983.png" alt="image-20211020131704983"></p><h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><p>可分为  单体多字存储器，多体并行存储器（又分为高位交叉编址存储器 和 低位交叉编址存储器）</p><p>其中单体多字存储器，如果要读两行不同的数据，需要读两次。而多体并行存储器，只需要一次就可以解决</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020131946454.png" alt="image-20211020131946454"></p><p><strong>高位编址，低位编址存储器</strong></p><p>下面的高位和低位存储器。每个四个内存条。</p><p>高位编址中，每个内存条是连续编址，所以如果访问连续的数据(在一个内存条内)，则需要存取时间+恢复时间进行完之后，才能继续访问下一个。所以需要5T的时间才能访问5个。</p><p>低位编址中，地址按照从左到右的连续编址，连续的地址在不同内存条中，访问连续的地址，只需要存取时间进行访问，在其中一个内存条在恢复时间的时候，另一个内存条可以继续进行读取。具体如下图。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020132451927.png" alt="image-20211020132451927"></p><blockquote><p>在低位存储中，应设置 模块数m&lt;=T/r，可以充分利用资源</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020133111990.png" alt="image-20211020133111990"></p></blockquote><h2 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h2><p>因为主存和CPU速度差距过大，Cache是用来过度的，且成本大，一个Cache不会特别大。</p><h3 id="Cache工作原理"><a href="#Cache工作原理" class="headerlink" title="Cache工作原理"></a>Cache工作原理</h3><p>当一个应用启动，会将数据代码等文件从辅存读入主存。而Cache会将主存使用的数据放到Cache中，加速读取的速度。</p><p>局部性原理</p><ul><li>空间局部性：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在<strong>存储空间上是邻近</strong>的（数据元素，顺序执行的指令代码）</li><li>时间局部性：在最近的未来要用到的信息，很可能是<strong>现在正在使用的信息</strong>（循环结构的指令代码）</li></ul><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a><strong>性能分析</strong></h3><p>分为两种情况，一种是先查Cache中是否有这个信息。另一种是Cache和主存一起查找，如果Cache中查到了，则马上停止主存的查找信息，未查找到，则主存继续查找。后一种的速度更快</p><p>命中率H，缺失（未命中）率M=1-H，Tc访问Cache耗时，Tm访问主存耗时，则访问时间 </p><ul><li><p>非同时的情况  t=HTc = (1-H)(Tc+Tm)</p></li><li><p>同时的情况    t=HTc+ (1-H)Tm</p></li></ul><h3 id="Cache存储"><a href="#Cache存储" class="headerlink" title="Cache存储"></a>Cache存储</h3><p>Cache存储是按照分块进行处理的。主存和Cache之间以 “块”为单位进行数据交换，例如1KB为一块。按照  （块号+块内地址）为一块</p><p>一个块 也称为一个 页/页面/页框，Cache中的“块”也称为 “行”</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020142600459.png" alt="image-20211020142600459"></p><h3 id="主存和Cache的映射方式"><a href="#主存和Cache的映射方式" class="headerlink" title="主存和Cache的映射方式"></a>主存和Cache的映射方式</h3><p>全部相联映射，直接映射，组相联映射</p><p><strong>全相联映射</strong></p><p>访存的流程</p><ul><li>主存地址的 块号对比Cache中的标记</li><li>如果标记匹配，且有效位为1，则Cache命中，访问块内地址。</li><li>如果未命中或者有效位为0，则正常访问主存</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020143617157.png" alt="image-20211020143617157"></p><p><strong>直接映射</strong></p><p>取块号后三位，或者主存块号%Cache总块数，可以得到Cache 的位置，存放在这个位置。但是如果这个位置已经存储了信息，则直接替换（下一节会介绍）。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020143914950.png" alt="image-20211020143914950"></p><p><strong>组相联映射</strong></p><p>所属分组=主存块号%分组数，相当于 块号取最后两位数。而其中确定组之后，组内存储可以像全相联映射一样，随便存储。</p><p>这里分为4组，两块一组。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211020144257335.png" alt="image-20211020144257335"></p><h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h3><ul><li><p>随机算法（RAND）：随机的确定替换的Cache块。实现简单，但没有依据程序访问的局部性原理，可能命中率较低</p></li><li><p>先进先出算法（FIFO）：选择最早调入的行进行替换。比较容易实现，没有依据程序访问的局部性原理，可能会把一下需要经常使用的程序块（如循环程序）也作为最早进入Cache的块替换掉</p></li><li><p><strong>近期最少使用算法（LRU）</strong>：依据程序访问的局部性原理，选择近期内最长久未访问过的存储行作为替换的行，平均命中率比FIFO高，是堆栈类算法）</p><p>具体思路：对每行设置一个计数器，Cache命中一次，把命中的计数器置为0，其他的块每个计数器+1。需要替换时就把最大计数器的块替换</p></li><li><p>最不经常使用算法（LFU）：将一段时间内被访问次数最少的存储行换出。每行设置一个计数器，新行建立后从0开始计数，被访问的行计数器+1。需要替换时，最小计数器的行被替换。</p><blockquote><p>这个算法的问题是，假如微信视频，一段时间内一直使用。但是未来不一定会使用这个。在很长一段时间就会导致块没被访问</p></blockquote></li></ul><p>使用最多的也就是LRU算法。如果是 直接映射，就直接进行替换。不需要使用上面的算法</p><h3 id="Cache-写策略"><a href="#Cache-写策略" class="headerlink" title="Cache 写策略"></a>Cache 写策略</h3><p>分为 写命中的情况和未命中的情况</p><ul><li><p>写命中</p><ul><li><p>全写法（写直通法）</p><p>当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲（访存次数增加，速度变慢，但能保证数据一致性）</p><blockquote><p>使用写缓冲，CPU写的速度很快，若写操作不频繁，则效果很好。若写操作很频繁，可能会因为写缓冲饱和而发生阻塞</p></blockquote></li><li><p>写回法</p><p>当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时，才写回主存（存在数据不一致的隐患）</p></li></ul></li><li><p>写不命中</p><ul><li><p>写分配法</p><p>当CPU对Cache<strong>写不命中时</strong>，把主存中的块调入Cache，在Cache中修改。通常<strong>搭配写回法</strong>使用</p></li><li><p>非写分配法</p><p>当CPU对Cache<strong>写不命中</strong>时只写入主存，不调入Cache，搭配全写法使用</p></li></ul></li></ul><p>多级Cache：现代计算机通常采用多级Cache结构，各级Cache间常采用“全写法+非写分配法” ， Cache和主存间采用 “写回法+写分配法”</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-第二章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018081735509.png" alt="image-20211018081735509"></p><h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><h3 id="8421（加法）"><a href="#8421（加法）" class="headerlink" title="8421（加法）"></a>8421（加法）</h3><blockquote><p><strong>加法超过1-9的表示范围需要加6来表示</strong></p></blockquote><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018082549357.png" alt="image-20211018082549357"></p><h3 id="余3码"><a href="#余3码" class="headerlink" title="余3码"></a>余3码</h3><p><strong>在8421码基础上加上一个3</strong></p><h3 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h3><p>2421分别为每一位的权值，表示0-4时最高位为0，5-9时最高位为1</p><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018083836835.png" alt="image-20211018083836835"></p><h2 id="汉字的表示和编码"><a href="#汉字的表示和编码" class="headerlink" title="汉字的表示和编码"></a>汉字的表示和编码</h2><p><strong>GB2312-80</strong></p><p>+80H为了高位为1，与ASCII码进行区分</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018084425246.png" alt="image-20211018084425246"></p><p><strong>输入：输入编码</strong></p><p><strong>输出：汉字字形码</strong></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>大端模式：将数据的最高有效字节存放在低地址单元中</p><p>小端模式：将数据的最高有效字节存放在高地址单元中</p><p>字符串：计算机按字节编址，以 “\0” 结尾，在所有计算机中，<strong>多字节数据</strong>都被<strong>存放在连续的字节序列中</strong></p><p>例如 “abc啊”，B0H A1H表示为啊，这里是大端模式</p><table><thead><tr><th>61H</th><th>62H</th><th>63H</th><th>B0H</th><th>A1H</th><th>00H</th></tr></thead></table><h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><p>原理</p><p>若干位代码组成的一个字叫<strong>码字</strong>，将两个码字逐位进行对比，具有不同的位的个数称为<strong>两个码字j间的距离</strong>，各合法码字间的最小距离称为<strong>码距（d）</strong></p><p>d=1时，无检错能力。d=2时，有检错能力。d&gt;=3时，设计合理，可能具有检错纠错能力</p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>奇校验码：整个校验码（有效信息位和校验位）中”1“的个数为奇数，偶校验码类似</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018091039245.png" alt="image-20211018091039245"></p><p>例：奇校验，给出1001101和1010111的两个二进制数</p><p>设最高位是校验位，7位是信息位。1001101—&gt;<strong>1</strong>1001101，1010111—-&gt;<strong>0</strong>1010111。也就是用校验位保证为1为奇数个，当发送数据时，如果发生数据跳变，其中一个位变化，就会变成偶数个，就可以看到是否有出错。</p><blockquote><p>但是如果有偶数个bit发生跳变，是无法发现错误</p></blockquote><p>计算机中的实现，各信息进行异或，算出是否需要校验位。如下</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018091638976.png" alt="image-20211018091638976"></p><h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><p>思路：将信息位分组进行偶校验，将数据进行分组，每个分组都设置校验位，多个校验位标注出错位置</p><p>其中分组按照2的n次方来计算的。四位是2的3次方，所以分为3个组。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018094018035.png" alt="image-20211018094018035"></p><p>校验原理是：按照数据存放的位置，例如H3（011）其中两个1，对应1位和2位，所以与校验码 p1,p2进行对应</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018095035901.png" alt="image-20211018095035901"></p><p>数据存放方法，上面为从大到小。如下是从小到大</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018094218710.png" alt="image-20211018094218710"></p><blockquote><p>补充</p><p>无法确定是一位出错还是两位出错，如果p1,p2同时出错，就为110，但是实际不是那个位置出错。</p><p>所以需要加上<strong>全校验位</strong>，也就是在加上一个最高位为全校验位，进行偶校验。</p><p>000=无错误</p><p>不为000就代表有错误，如果校验失败，就纠错。</p><p>如果校验成功，有两位错，需重传。</p></blockquote><h3 id="CRC码（循环冗余校验码）"><a href="#CRC码（循环冗余校验码）" class="headerlink" title="CRC码（循环冗余校验码）"></a>CRC码（循环冗余校验码）</h3><p>基本思想：数据接收方和发送方约定一个 ”<strong>除数</strong>“，且给   k个信息位+R个校验位作为 ”<strong>被除数</strong>“，添加校验位后<strong>保证除法的余数为0</strong>。</p><p>收到数据后，进行除法检查余数是否为0，如果为0是为出错，非0表示出错。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018103751182.png" alt="image-20211018103751182"></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018103910642.png" alt="image-20211018103910642"></p><blockquote><p>这里010表示C2出错，是有依据的。但是也不完全正确。如果2^R &gt;= K+R+1，则CRC码可纠错一位的错误。如果不是，则010可能不是表示2的位置，也可能表示9（按照上题）</p><p>001001 001，余数为010，实际是9位出错。101001 011 余数010 ，2位出错。</p></blockquote><h2 id="定点数的表示"><a href="#定点数的表示" class="headerlink" title="定点数的表示"></a>定点数的表示</h2><p>定点数：小数点的位置固定    996.007</p><p>浮点数：小数点的位置不固定    9.96007*10^3</p><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><blockquote><p>无符号数通常只表示整数</p></blockquote><p>所有位数都是数值，没有符号位。N位无符号数表示范围：0-2^(n-1)</p><h3 id="有符号数的定点表示"><a href="#有符号数的定点表示" class="headerlink" title="有符号数的定点表示"></a>有符号数的定点表示</h3><blockquote><p>0有+0和-0</p></blockquote><p>正（0）负（1）</p><p>可用<strong>原码，补码，反码</strong>三种方式来表示定点整数和定点小数。还可用<strong>移码</strong>表示定点整数</p><p>若真值为x，则用[x]原，[x]反，[x]补，[x]移分别表示真值所对应的原码反码……</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018104904524.png" alt="image-20211018104904524"></p><p><strong>原码整数</strong>的表示范围：-(2^n-1) &lt;= x &lt;= 2^n-1</p><p><strong>原码小数</strong>的表示范围：-(1-2^-n) &lt;= x &lt;= 1-2^-n</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><blockquote><p>0有+0和-0</p></blockquote><p>若符号位为0，则反码与原码相同</p><p>若符号位为1，则数值位全部取反</p><p>表示范围与原码的表示范围一致</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>补码：解决计算机中的减法操作。两个原码相减，将减数转为补码，就可以转为加法运算。</p><p>正数的补码=原码。负数的补码=反码末位+1（要考虑进位）</p><blockquote><p>补码的真值0只有一种表示形式</p><p><strong>原码补码相互转换方法一样</strong></p></blockquote><p>表示范围</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018110254156.png" alt="image-20211018110254156"></p><h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><p>补码的基础上将符号位取反。或者移码=真值+偏置值（计算机中的设定）<strong>移码只能用于整数</strong></p><p>表示范围与补码一致</p><p>移码作用：移码表示的整数很方便对比大小</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><p>通过改变各个数码位的小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法，除法</p><h5 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h5><p><strong>原码的算数移位</strong>—-符号位保持不变，仅对数值位进行移位</p><p>右移：高位补0，低位舍弃。若舍弃的位=0，相当于 /2 ；舍弃的位不为0，则会丢失精度</p><p>左移：低位补0，高位舍弃。舍弃的位=0，相当于*2。舍弃的位不为0，会出现<strong>严重误差</strong></p><p>反码算数移位</p><ul><li>正数高位为0，与原码移位一样。补0</li><li>负数高位为1，高位低位补1。</li></ul><p>补码算数移位</p><ul><li>正数与原码相同</li><li>负数：最右边的1的右边，用原码的规律。最右边的1的左边，用反码的规律<ul><li>右移（同反码）：高位补1，低位舍弃</li><li>左移（同原码）：低位补0，高位舍弃</li></ul></li></ul><h5 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h5><p>可以看作对无符号数的移位，右移,高位补0，低位舍弃。左移，低位补0，高位舍弃</p><h5 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h5><p>例如左移，会把移出去的那移位，放到最末位。右移类似</p><p>带  进位  位的循环左移：</p><p>例：有8bit位的数值，在前面再加一个位。当左移的时候，将最高位放到进位 位。将进位 位的数值放到末位。</p><h4 id="加减运算"><a href="#加减运算" class="headerlink" title="加减运算"></a>加减运算</h4><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018143143114.png" alt="image-20211018143143114"></p><p>原码进行加减需要太多机制，而且可能会出错。所以用补码进行加减运算。<strong>补码运算如下</strong></p><p>例：A=15,B=-24</p><p>[A+B]补=[A]补+[B]补=0,0001111+1,1101000=1,1110111（再转换为原码）</p><p>[A-B]补=[A]补+[-B]补=0,0001111+1,0011000=0,0100111（转换原码即可）</p><p>其中A-B 那里是将B进行按位取反再+1。也就是转为补码的补码（这里要连同符号位）</p><h4 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h4><blockquote><p>双符号位补码又称：模4补码</p><p>单符号位补码又称：模2补码</p></blockquote><p>正+正=负（上溢）</p><p>负+负=正（下溢）</p><p><strong>方法一</strong></p><p>采用一位符号位。设A的符号为As,B的符号为Bs，运算结果的符号为Ss,则溢出逻辑表达式为<img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018141531037.png" alt="image-20211018141531037"></p><p>若V=0，表示无溢出，反之溢出</p><p>例：A=15,C=124</p><p>A+C=0,0001111+0,1111100=1,0001011  等于-117 肯定溢出了</p><p>其中计算时   A的符号位0，C符号位0，S符号位1。进行计算。V=000+111=1(溢出)</p><p><strong>方法二</strong></p><p>采用一符号位，根据数据位进位情况判断溢出，符号位的进位Cs，最高数值位的进位C1</p><table><thead><tr><th></th><th>Cs</th><th>C1</th></tr></thead><tbody><tr><td>上溢</td><td>0</td><td>1</td></tr><tr><td>下溢</td><td>1</td><td>0</td></tr></tbody></table><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018142104328.png" alt="image-20211018142104328"></p><p><strong>方法三</strong></p><blockquote><p>双符号位，实际存储只存储1个符号位，运算时会复制一个符号位</p></blockquote><p>采用双符号位，正数符号为00，负数符号为11</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018142256958.png" alt="image-20211018142256958"></p><h4 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a><strong>符号扩展</strong></h4><p>8位—》16位</p><p>整数在最高位前面补数字，原码补0反码补码补1。小数就是在后面补0/1，反码补1，原码补码补0</p><h4 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h4><p>直接上实例。其中X和MQ中存的是他们的<strong>绝对值</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018144552008.png" alt="image-20211018144552008"></p><p>这里已经是算完的状态，也就是已经都移位完了。如果没有算的状态，ACC里面是全0的状态，每次取灰色的位置，乘以X，放入ACC，然后MQ和ACC统一逻辑右移移位。移到最后一位就可以不用进行运算(灰色的0不参与)。然后进行异或符号，放入最高位的位置。</p><h4 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h4><p>进行n+1轮加法，移位。每次加法可能是 +0，+[x]补，+[-x]补。且每次移位是补码的<strong>算数右移</strong>，符号位参与运算（原码使用的是绝对值，符号位不参加运算）</p><p>红色的为辅助位，X位置的辅助位是双符号位。算法与原码类似。</p><p><strong>有一点不同的是，+0，+[x]补，+[-x]补。具体实现是，辅助位-最低位获得的数字。为0，1，-1来进行对应</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018145357424.png" alt="image-20211018145357424"></p><h4 id="原码除法"><a href="#原码除法" class="headerlink" title="原码除法"></a>原码除法</h4><p><strong>恢复余数法</strong></p><p>ACC初始存被除数，当计算开始后存相减之后的余数。</p><p>计算方法：<strong>因为计算机不会判断大小，他会先取1进MQ的位置，然后让 ACC-除数，如果算出来的数字出错（符号位为1），就会将减掉的数字再加上去，将MQ的低位换为0。然后进行逻辑左移右边补0，ACC移出去的数字丢弃。</strong>最后得到的商在MQ中，余数在ACC中，但是余数需要乘以 2^-n次方才是最终余数。然后符号位异或</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018150955305.png" alt="image-20211018150955305"></p><p><strong>加减交替法</strong></p><p>和恢复余数法很类似，但是优化了其中的过程。具体如下，<strong>但当最后余数为负，则需商0，并+[Y]补得到正确的余数</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018152409858.png" alt="image-20211018152409858"></p><h4 id="补码除法"><a href="#补码除法" class="headerlink" title="补码除法"></a>补码除法</h4><p>符号位参与运算，被除数/余数，除数，采用双符号位</p><p>余数和除数<strong>同号</strong>，商<strong>1</strong>，<strong>余数左移一位减去除数</strong></p><p>余数和除数异号，商<strong>0</strong>，<strong>余数左移一位加上除数</strong></p><blockquote><p>最后结果，需要末位恒置为1。精度误差不超过2^(-n)</p></blockquote><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>无符号数与有符号数：不改变数据内容，改变解释方式</p><p>都是补码的形式。长整数变短整数，高位截断保留低位。</p><p>例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> x = <span class="number">-4321</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> y = (<span class="keyword">unsigned</span> <span class="keyword">short</span>)x;</span><br><span class="line"><span class="comment">// x=1110 1111 0001 1111（-4321）   y=1110 1111 0001 1111 （61215）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = x;</span><br><span class="line"><span class="comment">//m=1111 1111 1111 1111 1110 1111 0001 1111(-4321)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">165537</span>;</span><br><span class="line"><span class="keyword">short</span> c=(<span class="keyword">short</span>)a;</span><br><span class="line"><span class="comment">//a=0x000286a1(61215) , c=0x86a1(-31071)</span></span><br></pre></td></tr></table></figure><h3 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h3><p>大端，小端模式</p><p>大端：将数据最高位存在低位的位置（可以理解为从左往右，从大到小）</p><p>小端：将数据最低位存在低位的位置（从左往右，从左到大，主要是为了理解，实际并不一定是从左往右）</p><p><strong>边界模式</strong></p><p>现代计算机通常字节编址，每个字节对应一个地址。通常按字，半字，字节寻址。如下图</p><blockquote><p>注：其中填充是因为要边界对齐</p></blockquote><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019115407404.png" alt="image-20211019115407404"></p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点数的真值：N=r^e * M，r通常为2和2的倍数，M为尾数</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019130619281.png" alt="image-20211019130619281"></p><p>例：</p><p>a=0,01;1.1001     b=0,10;0.01001</p><p>a的表示为：00111001。但是b的表示 有9位，超出了8bit。所以需要进行规格化</p><p>b的尾数是0.01001，将小数点后面的0去掉，左移1。使小数点第一位是1。最后面补0（如果满了就不用管）。得到01001001。</p><p><strong>规格化</strong></p><p>规定<strong>尾数的最高数值位必须是一个有效值</strong></p><p><strong>左规：</strong>当浮点数运算的结果为非规格化时要进行规格化处理，将<strong>尾数算数左移移位，阶码减1</strong></p><p><strong>右规：</strong>当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将<strong>尾数算数右移一位，阶码加1</strong></p><blockquote><p>采用双符号位，当溢出发生时，可以挽救。更高的符号位是正确的符号位。</p><p>右规的情况，例如两个数字相加  出现了符号位两个数字不同。就是溢出，所以需要纠正</p></blockquote><p>用原码表示的尾数进行规格化</p><ul><li>正数为0.1xxxx（小数点后第一位需要为1，如果是0就丢弃然后左移，直到有1），则其最大值表示为0.11……1；最小值表示为0.10…….0。尾数的表示范围为  1/2 &lt;=M&lt;=(1-2^(-n))</li><li>负数为1.1xxx，其最大值为1.10….0；最小值为1.11…..1。尾数表示范围为  -(1-2^(-n)) &lt;=M&lt;= -1/2</li></ul><p>用补码表示的尾数进行规格化</p><ul><li>正数为0.1xxx，其最大值表示为0.1….1；最小值为0.10….0。尾数表示范围 1/2 &lt;=M&lt;=(1-2^(-n))</li><li>负数为1.0xxx，其最大值表示为1.01….1（这里小数点后面需要一个1，然后才是1）；最小值为1.0…0。尾数的表示范围 -1&lt;= M &lt;= -(1/2+2^(-n))</li></ul><h3 id="IEEE754"><a href="#IEEE754" class="headerlink" title="IEEE754"></a>IEEE754</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019142430106.png" alt="image-20211019142430106"></p><blockquote><p>阶码全0，全1用作特殊用途</p></blockquote><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019142524479.png" alt="image-20211019142524479"></p><p>由浮点数确定真值（阶码不是全0和全1）</p><ol><li>根据 “某浮点数” 确定数符，阶码，尾数的分布</li><li>确定尾数1.M（需要补充最高的隐含位1）</li><li>确定阶码的  真值 = 移码-偏置值</li><li>(-1)^s * 1.M = 2^(E-偏置值)</li></ol><p>最小绝对值：尾数全为0，阶码真值最小 -126，对应移码机器数0000 0001，整体的真值为 (1.0) * 2^(-126)</p><p>最大绝对值：尾数全为1，阶码真值最大127，对应移码机器数为1111 1110，整体真值为 (1.11….11) * 2^127</p><p>特殊的：</p><p>当<strong>阶码全为0</strong></p><ul><li>尾数不全为0时，表示<strong>非规格化小数</strong>  ±(0.xx.xxxx)+2^(-126)</li><li>尾数全为0时，表示<strong>真值 ±0</strong></li></ul><p><strong>当阶码全为1</strong></p><ul><li>尾数全为0，表示 <strong>±无穷</strong></li><li>尾数不全为0，表示<strong>非数值 “NaN”</strong></li></ul><h4 id="浮点数加减运算"><a href="#浮点数加减运算" class="headerlink" title="浮点数加减运算"></a>浮点数加减运算</h4><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019150600241.png" alt="image-20211019150600241"></p><p><strong>舍入</strong></p><p><strong>“0” 舍 “1” 入法：</strong>在尾数右移时，被移去的最高数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1.（但是可能会让尾数溢出，需要再做右规）</p><p><strong>恒置 ”1“ 法：</strong>尾数右移时，不论丢掉的最高数值位是 ”1“ 还是 “0” 都使右移后的尾数末位恒置 “1”，（可能会使尾数变大或变小）</p><h3 id="浮点数参与的强制类型转换"><a href="#浮点数参与的强制类型转换" class="headerlink" title="浮点数参与的强制类型转换"></a>浮点数参与的强制类型转换</h3><p>char-&gt; int -&gt; long -&gt; double（long32位时无精度丢失，但如果long是64位时转到double会有精度丢失）</p><p>32位</p><p>int：表示整数，范围是 -2^31—2^(31-1)，有效数字32位</p><p>float：表示整数及小数，范围 [ 2^(-126)—— 2^127(2-2^(-23)) ]</p><p>如果是int转float肯定会有精度丢失，因为int有31个数值位，float只有24个尾数位。float转int一样会有精度丢失，int会把小数点之后的数字丢失。</p><h2 id="算数逻辑单元ALU"><a href="#算数逻辑单元ALU" class="headerlink" title="算数逻辑单元ALU"></a>算数逻辑单元ALU</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019163305455.png" alt="image-20211019163305455"></p><h3 id="一位全加器"><a href="#一位全加器" class="headerlink" title="一位全加器"></a>一位全加器</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019172231738.png" alt="image-20211019172231738"></p><h3 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019172429386.png" alt="image-20211019172429386"></p><p>进位触发器存放进位的值，每次运算的时候将进位的值加进去运算（0/1）</p><p>只有一个全加器，数据逐位串行送入加法器中jji进行运算。进位触发器用来寄存进位信号，以便下一次运算（操作数为n，那么就要加n次）</p><h3 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019172636212.png" alt="image-20211019172636212"></p><p><strong>串行进位的并行加法器</strong>：把n个全加器串接起来，就可以j进行两个n位数的相加。不过，虽然输入可以n个进行输入，但是还是要等低位的进行运算，然后将进位送到下一个运算器，才能进行下一次计算。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-第一章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211014153140336.png" alt="image-20211014153140336"></p><h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211014154114854.png" alt="image-20211014154114854"></p><h3 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211014160713514.png" alt="image-20211014160713514"></p><ul><li>MAR：地址寄存器，MDR：数据寄存器</li><li><strong>存储单元</strong>：每个存储单元存放一串二进制代码</li><li><strong>存储字</strong>（word）：存储单元中二进制代码的组合</li><li><strong>存储字长</strong>：存储单元中二进制代码的位数</li><li>存储元：存储二进制的电子元件，每个存储元可存1bit</li></ul><h3 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211014161045566.png" alt="image-20211014161045566"></p><ul><li>ACC：累加器，用于存放操作数，或运算结果</li><li>MQ：乘商寄存器，在乘，除运算时，用于存放操作数或运算结果</li><li>X：通用的操作数寄存器，用于存放操作数</li><li><strong>ALU</strong>：算术逻辑单元，通过内部复杂的电路实现算数运算，逻辑运算</li></ul><h3 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211014161512386.png" alt="image-20211014161512386"></p><ul><li><strong>CU：</strong>控制单元，分析指令，给出控制信号</li><li>IR：指令寄存器，存放当前执行的指令</li><li>PC：程序计数器，存放下一条指令地址，有自动加1功能</li></ul><p>取指令（PC）—-&gt;分析指令（IR）—-&gt;执行指令(CU)</p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>初始：指令，数据存入主存，PC指向第一条指令。从主存中取指令放入IR，PC自动加1，CU分析指令，CU指挥其他部件执行指令</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211014163156292.png" alt="image-20211014163156292"></p><h3 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211014170343989.png" alt="image-20211014170343989"></p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211014172800820.png" alt="image-20211014172800820"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(自顶向下)第六章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="链路层和局域网"><a href="#链路层和局域网" class="headerlink" title="链路层和局域网"></a>链路层和局域网</h2><blockquote><p>网络层解决一个网络到达另一个网络的路由问题</p><p>链路层：网络内部如何由一个节点（主机或路由器）到达另一个相邻节。（点到点连接，多点连接）</p><p>wan：网络形式采用点到点链路</p><p>LAN：一般采用多点连接方式</p></blockquote><h3 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h3><p>术语</p><ul><li>主机和路由器：nodes（节点）</li><li>沿着通信路径，连接相邻节点通信信道的是<strong>链路</strong>：links（无线，有线，局域网，共享性链路）</li><li>第二层协议数据单元帧frame，封装数据报</li></ul><blockquote><p><strong>数据链路层负责从一个节点通过链路将数据报发送到相邻的物理节点</strong></p></blockquote><p><strong>链路层：上下文</strong></p><p>数据报在不同链路上以不同的链路协议传送：</p><ol><li>第一跳：以太网</li><li>中间链路：帧中继链路</li><li>最后一跳：802.11</li></ol><p>传输类比</p><ul><li>从A到B<ul><li>有不同交通工具</li></ul></li><li>旅行者=数据报datagram</li><li>交通段=通信链路communication link</li><li>交通模式=链路层协议：数据链路层和局域网protocol</li><li>票务代理=路由算法routing algorithm</li></ul><p><strong>链路层服务</strong></p><p>流量控制，错误检测，差错纠正，半双工和全双工</p><p>成帧，链路接入：</p><ul><li><p>将数据报封装在帧中，加上帧头、帧尾部</p></li><li><p>如果采用的是共享性介质，信道接入获得信道访问权</p></li><li><p>在帧头部使用“MAC”（物理）地址来标示源和目的 ，不同于IP地址</p></li></ul><p><strong>相邻节点内完成可靠数据传输</strong></p><p>低差错的链路上很少使用（光纤，一些双绞线）</p><p>高差错链路上需要进行可靠数据传送（无线链路）</p><p><strong>链路层的实现位置</strong></p><ul><li><p>主机</p></li><li><p>”适配器“（aka network interface and NIC)或者在一个芯片组上</p><ul><li>以太网卡，802.11网卡，以太网芯片组</li><li>实现链路层和响应的物理层功能</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211016155954402.png" alt="image-20211016155954402"></p></li><li><p>接到主机的系统总线上</p></li><li><p>硬件，软件，固件的综合体</p></li></ul><h3 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h3><p>EDC=差错检测和纠正位（冗余位），D =数据由差错检测保护，可以包含头部字段</p><blockquote><p>错误检测不是100%可靠，会漏检一些错误，但是错误更少。更长的EDC字段可以得到更好的检测和纠正效果</p></blockquote><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017092217140.png" alt="image-20211017092217140"></p><p><strong>奇偶校验</strong></p><p><strong>单bit奇偶校验（检测耽搁bit级错误），2维奇偶校验（检测和纠正单个bit错误）</strong></p><p><strong>Internet校验和</strong></p><p>目标：检测在传输报文段时的错误（如位翻转）且仅用在传输层</p><p><strong>发送方</strong></p><ul><li>将报文段看成16-bit整数</li><li>报文段和校验和：和（1‘的补码和）</li><li>发送方将checksum的值放在’UDP校验和‘字段</li></ul><p><strong>接收方</strong></p><ul><li><strong>计算</strong>接收到的报文段的校验和</li><li>检查是否与携带校验和字段值一致<ul><li>不一致：有错误</li><li>一致：没有检出错误，但可能有错</li></ul></li></ul><p><strong>检验和：CRC</strong>（循环冗余校验）</p><ul><li><p>强大的差错检测码</p></li><li><p>将数据比特 D, 看成是二进制的数据</p></li><li><p>生成多项式G：双方协商r+1位模式（r次方） ，生成和检查所使用的位模式</p></li></ul><p>目标：选择r位 CRC附加位R，使得</p><ul><li>&lt;D,R&gt;正好被G整除（modulo 2）</li><li>接收方知道G，将&lt;D,R&gt;除以G，如果非0余数：检查出错误</li><li>能检出所有少于r+1位的突发错误</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017095037279.png" alt="image-20211017095037279"></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017095103093.png" alt="image-20211017095103093"></p><h3 id="多点访问协议"><a href="#多点访问协议" class="headerlink" title="多点访问协议"></a>多点访问协议</h3><p><strong>多路访问链路和协议</strong></p><ul><li>点对点（拨号访问的PPP，以太网交换机和主机间的点对点链路）</li><li>广播（共享链路或媒体）传统以太网，HFC上行链路，802.11无线局域网</li></ul><p><strong>协议</strong></p><p>单个共享的广播型链路，2个或更多的站点同时发送会<strong>冲突（collision）</strong></p><p><strong>多路访问协议（介质访问控制协议：MAC）</strong></p><p>MAC（媒体访问控制）协议：分类</p><ul><li>信道划分<ul><li>把信号分成小片（时间TDMA，频率FDMA，编码CDMA）</li><li>分配片个每个节点专用</li></ul></li><li>随机访问<ul><li>信号不划分，允许冲突</li><li>冲突后恢复</li></ul></li><li>依次轮流<ul><li>节点依次轮流</li><li>但是有很多数据传输的节点可以获得较长的信道使用权</li></ul></li></ul><h4 id="随机存取协议"><a href="#随机存取协议" class="headerlink" title="随机存取协议"></a><strong>随机存取协议</strong></h4><p>当节点有帧要发送时，以<strong>信道带宽的全部R bps</strong>发送，没有节点间的预先协调。</p><p>两个或更多节点同时传输，会发生冲突（collision）</p><p>随机存取协议规定了，如何检测冲突，如何从冲突中恢复。还有随机MAC协议（时隙ALOHA，ALOHA，CSMA，CSMA/CD，CSMA/CA）</p><h5 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h5><p>假设：所有帧是等长的，时间被划分成相等的<strong>时隙</strong>，每个时隙可发送一帧。节点只在时隙开始时发送帧，节点在时钟上是同步的，如果两个或多个节点在一个时隙传输，所有站点都能检测到冲突。</p><p>运行</p><ul><li>当节点获取心的帧，在下一个时隙传输</li><li>传输时没有检测到冲突，成功，节点能够在下一时隙发送帧</li><li>检测到冲突，失败，节点在每一个随后的时隙以概率p重传帧直到成功</li></ul><blockquote><p>优点：节点可以以信道带宽全速连续传输。高度分布，仅需要节点之间在时隙上同步。</p><p>缺点：存在冲突，浪费时隙。即使有帧要发送仍然有可能存在空闲的时隙。节点检测冲突的时间&lt;帧传输的时间。且必须传完，需要时钟同步</p></blockquote><p>最好的情况：效率利用率37%</p><h5 id="纯ALOHA（非时隙）"><a href="#纯ALOHA（非时隙）" class="headerlink" title="纯ALOHA（非时隙）"></a>纯ALOHA（非时隙）</h5><p>无时隙ALOHA：简单，无须节点间在时间上同步。当有帧需要传输：马上传输。冲突的概率增加。</p><p>效率相比时隙ALOHA更差</p><h5 id="CSMA（载波侦听多路访问）"><a href="#CSMA（载波侦听多路访问）" class="headerlink" title="CSMA（载波侦听多路访问）"></a><strong>CSMA（载波侦听多路访问）</strong></h5><p>在传输前先侦听信道，如果信道空闲，传送整个帧。信道忙，推迟传送</p><p>冲突：仍然可能发生，由传播延迟造成，两个节点可能侦听不到正在进行的传输。整个冲突帧的传输时间都被浪费，是无效传输。传播延迟决定冲突的概率。</p><h5 id="CSMA-CD（冲突检测）"><a href="#CSMA-CD（冲突检测）" class="headerlink" title="CSMA/CD（冲突检测）"></a>CSMA/CD（冲突检测）</h5><p>载波侦听CSMA：和在CSMA中一样发送前侦听信道，没有传完一个帧就可以在短时间内检测到冲突，冲突发生时则传输终止，减少对信道的浪费</p><p><strong>冲突检测CD技术</strong>，有线局域网中容易实现：检测信号强度，比较传输与接收到的信号是否相同，通过周期的过零点检测</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017103404876.png" alt="image-20211017103404876"></p><p><strong>CSMA/CD算法</strong></p><ol><li><p>适配器获取数据报，创建帧</p></li><li><p>发送前：侦听信道CS</p><p>1)闲：开始传送帧</p><p>2)忙：一直等到闲再发送</p></li><li><p>发送过程中，冲突检测CD</p><p>1)没有冲突:成功</p><p>2)检测到冲突:放弃,之后尝试重发</p></li><li><p>发送方适配器检测到冲突，除放弃外，还发送一个Jam信号，所有听到冲突的适配器也是如此</p><p><strong>强化冲突：让所有站点都知道冲突</strong></p></li><li><p>如果放弃，适配器进入指数退避状态</p><p>第m次失败后，适配器随机选择一个{ 0 到  2^(m-1) }为k，等待k*512位时间，然后转到步骤2（指数退避）</p></li></ol><p><strong>指数退避</strong></p><p>首次碰撞：在{0，1}选择K；延迟K*512位时，第2次碰撞：在{0，1，2，3}选择K，第10次碰撞：在{0，1，2，3，……，1023}选择K</p><p><strong>效率：比ALOHA更好的性能，简单，廉价，分布式</strong></p><h5 id="无线局域网：CSMA-CA"><a href="#无线局域网：CSMA-CA" class="headerlink" title="无线局域网：CSMA/CA"></a>无线局域网：CSMA/CA</h5><p><strong>发送方</strong></p><p>1 如果站点侦测到信道空闲持续**DIFS长，则传输整个帧 **(no CD)</p><p>2 如果侦测到信道忙碌，那么 选择一个随机回退值，并在信道空闲时递减该值；如果信道忙碌，回退值不会变化到数到0时（只生在信道闲时）发送整个帧如果没有收到ACK, 增加回退值，重复2</p><p><strong>802.11接收方</strong></p><p>如果帧正确，则在SIFS后发送ACK</p><p>IEEE 802.11 MAC协议：CSMA/CA</p><p>在count down时，侦听到了信道空闲为什么不发送，而要等到0时在发送</p><ul><li><p>2个站点有数据帧需要发送，第三个节点正在发送</p></li><li><p>LAN CD：让2者听完第三个节点发完，立即发送</p></li><li><p>冲突：放弃当前的发送，避免了信道的浪费于无用冲突帧的发送。代价不昂贵</p></li></ul><p>无法完全避免冲突，例如AB都要等C发送完，但是AB的值很接近。可能会冲突等等</p><p><strong>WLAN：CA</strong></p><p>无法CD，一旦发送必须发完，冲突就会导致信道浪费。</p><p><strong>冲突避免</strong></p><p>允许发送方“预约”信道，而不是随机访问该信道: 避免长数据帧的冲突（可选项）</p><ul><li><p>发送方首先使用CSMA向BS发送一个小的RTS分组，RTS可能会冲突（但是由于比较短，浪费信道较少）</p></li><li><p>BS广播 clear-to-send CTS，作为RTS的响应</p></li><li><p>CTS能够被所有涉及到的节点听到，发送方发送数据帧，其它节点抑制发送</p></li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017110306509.png" alt="image-20211017110306509"></p><h5 id="线缆接入网络"><a href="#线缆接入网络" class="headerlink" title="线缆接入网络"></a>线缆接入网络</h5><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017111405264.png" alt="image-20211017111405264"></p><p><strong><em>多个</em></strong>40Mbps 下行(广播)信道,FDM </p><p>​    下行：通过FDM分成若干信道，互联网、数字电视等 </p><p>​    互联网信道：只有1个CMTS在其上传输</p><p><strong><em>多个</em></strong>30 Mbps上行的信道,FDM </p><p>​    <strong>多路访问</strong>：所有用户使用；接着TDM分成微时隙</p><p>​    部分时隙：分配；部分时隙：竞争；</p><h4 id="轮流（Taking-Turns）MAC协议"><a href="#轮流（Taking-Turns）MAC协议" class="headerlink" title="轮流（Taking Turns）MAC协议"></a>轮流（Taking Turns）MAC协议</h4><p>信道划分MAC协议：</p><ul><li>共享信道在高负载时是有效和公平的</li><li>在低负载时效率地下，只能等到自己的时隙开始发送或者利用1/N的信道频率发送。当只有一个节点有帧传时，也只能够得到1/N个带宽分配</li></ul><p>随机访问MAC协议</p><ul><li>在低负载时效率高，单个节点完全可以利用信道全部带宽</li><li>高负载时，冲突开销较大，效率极低，时间很多浪费在冲突中</li></ul><p>轮流协议：有两者优点</p><p>轮流询问:</p><p>主节点邀请从节点依次传送，从节点一般比较 “dumb”</p><p>缺点: </p><ul><li><p>轮询开销：轮询本身消耗信道带宽 </p></li><li><p>等待时间：每个节点需等到主节点轮询后开始传输，即使只有一个节点，也需要等到轮询一周后才能够发送 </p></li><li><p>单点故障：主节点失效时造成整个系统无法工作</p></li></ul><p><strong>令牌传递</strong>: </p><p>控制令牌( token)循环从一个节点到下一个节点传递</p><p>令牌报文：特殊的帧</p><p>缺点: </p><ul><li><p>令牌开销：本身消耗带宽 </p></li><li><p>延迟：只有等到抓住令牌，才可传输 </p></li><li><p>单点故障 (token)： </p><ul><li>令牌丢失系统级故障，整个系统无法传输 </li><li>复杂机制重新生成令牌</li></ul></li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017112508792.png" alt="image-20211017112508792"></p><h3 id="LANs"><a href="#LANs" class="headerlink" title="LANs"></a>LANs</h3><h4 id="addressing，ARP"><a href="#addressing，ARP" class="headerlink" title="addressing，ARP"></a>addressing，ARP</h4><p>MAC地址和ARP</p><p>32位 bit IP地址</p><ul><li>网络层地址</li><li>前n-1跳：用于使数据报到达目的IP子网</li><li>最后一条：到达子网中的目标节点</li></ul><p>LAN（MAC/物理/以太网）地址：</p><ul><li>用于使帧从一个网卡传递到与其物理连接的另一个网卡（在同一个物理网络中）</li><li>48bit MAC地址固化在适配器的ROM，有时也可以通过软件设定，理论上全球任何一个网卡MAC都不同</li></ul><p><strong>网络地址和物理地址分离</strong></p><p>IP地址是分层的，一个子网所有站点网络号一致，路由聚集，减少路由表。IP地址完成网络到网络的交付</p><p>mac地址是平面的：网卡在生产时给一个唯一标识，用于区分一个网络内部不同的网卡即可。可以完成一个物理网络内部的节点到节点的数据交付</p><blockquote><p>局域网上每一个适配器都有一个唯一的<strong>LAN</strong>地址</p></blockquote><p>MAC地址有IEEE管理和分配，制造商购入MAC地址空间（保证唯一性），MAC地址可以进行移动，不影响IP地址，IP地址有层次，不能移动</p><p><strong>Address Rseolution Protocol（ARP)</strong></p><p>在LAN上的每个IP节点都有一个ARP表（包括一些LAN节点IP/MAC地址的映射 《IP,MAC，TTL》）</p><p>同一个网络中</p><p>A要发送帧给B，B的MAC地址不在A的ARP表中，A广播包含B的ip地址的ARP查询包，B接收到ARP包，恢复A自己的MAC地址，A在ARP中缓存B的mac地址。</p><p>不同网络中，用iP先到那个路由表，然后该地方的路由器会找到要传送的MAC地址</p><h4 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h4><p>以太网：目前最主流的LAN技术：98的占有率，最早广泛应用的LAN技术，比令牌网和ATM网络简单，廉价</p><p><strong>物理拓扑</strong></p><p>总线</p><p>星形（目前最主流），使用hub或switch，现在一般是交换机在中心。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017123355782.png" alt="image-20211017123355782"></p><p><strong>以太帧结构</strong></p><p>发送方适配器在以太网帧中封装IP数据报或其他玩路过层协议数据单元</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017123433548.png" alt="image-20211017123433548"></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017123509472.png" alt="image-20211017123509472"></p><p>以太网：无连接，不可靠</p><p>无连接：帧传输前，发送方和接收方之间没有握手</p><p>不可靠：接收方适配器不发送ACKs或NAKs给发送方，递交给网络层的数据报流可能有gap</p><p>以太网的MAC协议，采用<strong>二进制退避的CSMA/CD介质访问控制形式</strong></p><p><strong>Hubs</strong></p><p>Hubs 本质上是物理层的中继器: </p><ul><li><p>从一个端口收，转发到所有其他端口</p></li><li><p>速率一致</p></li><li><p>没有帧的缓存</p></li><li><p>在hub端口上没有CSMA/CD机制:适配器检测冲突</p></li><li><p>提供网络管理功能</p></li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017124014124.png" alt="image-20211017124014124"></p><p><strong>Manchester编码</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017124149266.png" alt="image-20211017124149266"></p><p>在10BaseT中使用，每一个bit的位时中间有一个信号跳变，允许在接收方和发送方节点之间进行时钟同步</p><p><strong>100baseT使用4b5b编码</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017124326145.png" alt="image-20211017124326145"></p><p>千兆以太网</p><ul><li>采用标准的以太帧格式</li><li>允许点对点链路和共享广播信道</li><li>物理编码：8b10b编码</li><li>在共享模式，继续使用CSMA/CD MAC技术，节点间需要较短距离以提高利用率</li><li>交换模式：全双工千兆可用于点对点链路<ul><li>站点使用专用信道，基本不会冲突，除非发往同一个节点</li></ul></li><li>10 Gbps</li></ul><h4 id="802-11-WLAN"><a href="#802-11-WLAN" class="headerlink" title="802.11 WLAN"></a>802.11 WLAN</h4><p>802.11b，802.11a，802.11g，802.11n等，所有802.11标准都是CSMA/CA进行多路访问，都有基站模式和自组织网络模式</p><p><strong>802.11LAN 体系结构</strong></p><p>无线主机与基站通信，**基站（base station） = 接入点（access point（AP)）</p><p>基础设施模式下的<strong>基本服务集Basic Service Set（BSS）</strong></p><ul><li>无线主机</li><li>接入点（AP）：基站</li><li>自组织模式下：只有无线主机</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017141158756.png" alt="image-20211017141158756"></p><p><strong>802.11：信道与关联</strong></p><p>802.11b：2.4GHz-2.485GHz频谱被分为11个相互不同的但是部分重叠的频段</p><ul><li>AP管理员为AP选择一个频率</li><li>可能的干扰：邻居AP可能选择同样一个信道</li></ul><p>主机：必须在通信之前和AP建立<strong>associate</strong></p><ul><li>扫描所有的信道，侦听包含AP SSID和MAC地址的信标帧<ul><li>主动扫描：主机发送真的，接收AP的响应</li><li>被动扫描</li></ul></li><li>选择希望关联的AP</li><li>可能需要执行鉴别（认证），基于MAC，用户名口令，通过AP的中继，使用RADIUS鉴别服务器进行身份鉴别</li><li>将会执行DHCP获得IP地址和AP所在的子网前缀</li></ul><p>主动扫描–被动扫描</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017142228001.png" alt="image-20211017142228001"></p><p><strong>802.11地址</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017142343269.png" alt="image-20211017142343269"></p><p>duration：预约传输时间的持续期(RTS/CTS)</p><p>seq control：帧序号（for RDT)</p><p><strong>frame control中</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017142609921.png" alt="image-20211017142609921"></p><h4 id="switches"><a href="#switches" class="headerlink" title="switches"></a>switches</h4><p><strong>Hub:集线器</strong></p><p>网段（LAN segments）：可以允许一个站点发送的玩路过范围。通常拥有相同的前缀，比IP子网更详细的前缀。在一个碰撞域，同时只允许一个站点在发送，如果有两个节点同时发送，则会碰撞。</p><p>所有以Hub连到一起的站点，处在一个网段，一个碰撞域</p><p>通过hub可扩展节点之间的最大距离，但是不能将10BaseT和100BaseT的网络连接在一起</p><p><strong>Switches</strong>（交换机）</p><p>链路层设备：扮演主动角色（端口执行以太网协议）</p><ul><li>对帧进行存储和转发，对于过来的帧，检查帧头，根据目标MAC地址进行选择性转发。</li><li>当帧需要向某个网段进行转发，使用CSMA/CD进行接入控制。但通常一个交换机端口一个独立网段</li></ul><p><strong>多路同时传输</strong></p><p>因为是端口连接，所以只要A—B，C—D，这样不会互相影响。每条链路都是独立的碰撞域。</p><p>其中交换机都有一个转发表，知道每个表项。</p><p><strong>自学习</strong></p><p>当接收到帧时，交换机就会记录到发送站点所在的端口（网段），记录发送方MAC地址进入端口映射关系，在交换表中</p><p><strong>交换机和路由器</strong></p><p>都是存储转发设备，层次不同</p><ul><li>交换机：链路层设备（检查链路层头部）</li><li>路由器：网络层设备（检查网络层的头部）</li></ul><p>都有转发表</p><ul><li>交换机：维护交换表，按照MAC地址转发</li><li>路由器：维护路由表，执行路由算法</li></ul><h4 id="VLANs"><a href="#VLANs" class="headerlink" title="VLANs"></a>VLANs</h4><p>基于端口的VLAN：交换机端口成组（通过交换机管理软件），以至于<strong>单个的</strong>交换机可以分成若干虚拟LANs。（一个物理LAN基础的设置，虚拟成多个LANs）</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211017145353221.png" alt="image-20211017145353221"></p><p>流量隔离：从/到1-8端口的流量只会设计到1-8</p><p>动态成员：成员可以在VLANs之间动态分配</p><p>在VLANs间转发：通过路由器进行转发</p><h3 id="链路虚拟化：MPLs"><a href="#链路虚拟化：MPLs" class="headerlink" title="链路虚拟化：MPLs"></a>链路虚拟化：MPLs</h3><p>建立基于标签的转发表-信令协议：支持逐跳和显示路由：路由信息传播，路由计算（基于Qos，基于策略的），标签分发。</p><ul><li><p>从IP网络来看，将一组支持MPLS的网络虚拟成链路的技术</p></li><li><p>纯IP网络是按照IP地址对分组进行转发的，前缀匹配，转发的方法固定，无法控制IP分组的路径，无法支持流连工程，也无法对一个IP分组流进行资源分配，性能无法保证</p></li><li><p>MPLs网络按照标签label进行分组的转发，类似与VC，有基于标签的<strong>转发表</strong>，基于虚电路表，IP vs 线路交换</p></li></ul><p><strong>标签交换的过程</strong></p><ol><li>入口路由器：LER对进入的分组按照EFC的定义打上标签</li><li>在MPLS网络中（虚拟成了链路）对分组按照标签进行交换</li><li>到了出口路由器，在将标签摘除</li><li>支持MPLS的路由器组构成的网络，从IP网络的角度来看虚拟成了链路</li></ol><p><strong>优点</strong></p><p>路由弹性：基于Qos，基于策略的</p><p>充分利用已有的硬件ATM快速转发，支持流连工程，VPN…..</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(自顶向下)第五章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="网络控制平面"><a href="#网络控制平面" class="headerlink" title="网络控制平面"></a>网络控制平面</h2><h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><h4 id="路由概念"><a href="#路由概念" class="headerlink" title="路由概念"></a>路由概念</h4><p>按照某种指标（站数，延迟，费用，队列长度等，或者是一些单纯指标的加权平均）找到一条从源节点到目标节点的较好路径（按照某种指标较小的路径）</p><p>以<strong>网络</strong>为单位进行路由（计算机网络 到其他网络怎么走），路由器—路由器之间的路由。</p><blockquote><p>在一个网络中：路由器—主机之间的通信，链路层解决。其他的就是到路由器，到了路由器就是到了这个网络，里面有很多主机。</p></blockquote><p><strong>网络的图抽象</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211015110859673.png" alt="image-20211015110859673"></p><p>路由的输入：拓扑，边的代价，源节点</p><p>输出的输出：源节点的汇集树</p><p>最优化原则：算法可以参考图里面的最短路径算法</p><h4 id="路由的原则"><a href="#路由的原则" class="headerlink" title="路由的原则"></a>路由的原则</h4><p>正确性：算法必须<strong>正确</strong>和<strong>完整</strong>的。</p><p>简单性：算法在计算机上实现简单。</p><p>健壮性：算法应能适应<strong>通信量</strong>和网络拓扑的变化。例如不向很挤的链路发数据，不向断了的链路发数据</p><p>稳定性：产生的路由不应该摇摆</p><p>公平性：对每个站点公平</p><p>最优性：某一个指标的最优，或者综合最优。</p><h4 id="路由算法分类"><a href="#路由算法分类" class="headerlink" title="路由算法分类"></a>路由算法分类</h4><p>全局：所有路由器拥有完整的拓扑和边的代价的信息。Linkstate算法</p><p>分布式：路由器只知道与他有物理连接关系的领居路由器，distance vector算法</p><p>静态或动态</p><p>静态：路由随时间变化缓慢</p><p>动态：路由变化很快，周期性更新，根据链路代价的变化而变化</p><h4 id="Link-state算法"><a href="#Link-state算法" class="headerlink" title="Link state算法"></a>Link state算法</h4><p><strong>LS路由选择算法</strong>的路由工作过程</p><ul><li>各点通过各种渠道获得<strong>整个网络拓扑</strong>，网络中所有链路<strong>代价</strong>等信息（协议和实现）</li><li>使用<strong>LS路由算法</strong>，计算本站点到其他站点的最优路径（汇集树），得到路由表</li><li>按照此路由表转发分组（datagram方式），分发到输入端口的网络层（不能算一个步骤）</li></ul><p><strong>Link state routing链路状态路由选择</strong></p><p>LS路由的基本工作过程</p><ol><li><p>发送相邻节点，获知对方网络地址</p><ul><li>一个路由器接上电，向所有线路发送HELLO分组</li><li>其他路由器收到HELLO分组，回送应答，在应答分组中稿纸自己的名字（全局唯一）</li><li>在LAN中，通过广播HELLO分组，获得其他路由器的信息</li></ul></li><li><p>测量到相邻节点的代价（延迟，开销）</p><ul><li>实测法，发送一个分组要求对方立即响应，回送一个ECHO分组，通过测量时间估算出延迟情况</li></ul></li><li><p>组装一个分组，描述相邻节点的情况</p><ul><li>发送者名称，序号，年龄</li><li>列表：给出他相邻节点，和它到相邻节点的延迟</li></ul></li><li><p>将分组通过扩散的方法发到所有其他路由器</p><ul><li><p>设置顺序号：防止无穷的扩散，每个路由器都记录（源路由器，顺序号），发现重复的或老的就不扩散。</p><p>生成一个分组，设置一个年龄字段/顺序号，不为0，每过一个路由器，顺序号减1，当顺序号为0时分组被抛弃</p></li><li><p>分组的数据结构</p><ul><li>Source：从哪个节点收到LS分组</li><li>Seq，Age：序号，年龄</li><li>Send flags：发送标记，必须向指定的那些相邻站点转发LS分组</li><li>ACK flags：本站点必须向哪些站点发送应答</li><li>DATA：来自source站点的LS分组</li></ul></li></ul></li><li><p>通过Dijkstra算法找出最短路径</p><ul><li>路由器获得各站点LS分组和整个网络拓扑。通过Dijkstra算法计算出到其他各路由器的最短路径（汇集树）</li><li>将计算结果安装到路由表中</li></ul></li></ol><p><strong>链路状态路由选择算法工作原理</strong></p><p>符号标记:</p><ul><li><p>c(i,j): 从节点i 到j链路代价(初始状态下非相邻节点之间的</p><p>链路代价为∞)</p></li><li><p>D(v): 从源节点到节点V的当前路径代价(节点的代价)</p></li><li><p>p(v): 从源到节点V的路径前序节点</p></li><li><p>N’: 当前已经知道最优路径的的节点集合(永久节点的集合)</p></li></ul><p><strong>工作原理</strong></p><p>节点标记：每一个节点使用（D(v) , p(v)) 如(3,B)，Dv从源节点由已知的最优路径到达本节点的距离，pv为前序节点</p><p>分为两类节点</p><p>临时节点（tentative node）还没有找到从源节点到此节点的最优路径的节点</p><p>永久节点（permanent node）N’：已经找到了从源节点到此节点的最优路径的节点</p><blockquote><p>初始化</p><ul><li><p>除了源节点外,所有节点都为临时节点</p></li><li><p>节点代价除了与源节点代价相邻的节点外,都为∞ </p></li></ul><p>从所有临时节点中找到一个节点代价最小的临时节点,将之变成永久节点(当前节点)W</p><p>对此节点的所有在临时节点集合中的邻节点(V) </p><ul><li><p>如 D(v)&gt;D(w) + c(w,v), 则重新标注此点, (D(W)+C(W,V), W) </p></li><li><p>否则，不重新标注</p></li></ul><p>开始一个新的循环</p></blockquote><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211015201158511.png" alt="image-20211015201158511"></p><h4 id="distance-vector算法"><a href="#distance-vector算法" class="headerlink" title="distance vector算法"></a>distance vector算法</h4><p><strong>距离矢量路由选择（distance vector routing）</strong></p><p>基本思想</p><p>各路由器维护一张路由表（如图），各路由器与相邻路由器交换路由表，根据获得的路由信息，更新路由表</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211015202014231.png" alt="image-20211015202014231"></p><p>路由信息的更新（定期测量）</p><ol><li>根据实测，得到本节点A到相邻节点的代价（如：延迟）</li><li>根据各相邻节点声称他们到B节点的代价</li><li>计算出A经过相邻站点到达B的代价，选择最小的代价和相应下一个节点。</li></ol><p><strong>距离矢量算法</strong></p><p>核心思路：</p><p>每个节点将自己的距离矢量估计值传送给邻居，定时或者DV有变化时，让对方算。当x从邻居收到DV时，自己计算，更新他自己的距离矢量</p><p><strong>异步式，迭代</strong>，本地链路代价变化，从邻居来了DV的更新消息</p><p><strong>分布式：</strong>每个节点在自己的DV改变后向邻居通告，然后邻居在有必要的时候再通知他们其他的邻居</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211015203614861.png" alt="image-20211015203614861"></p><p>DV的特点</p><p>好消息传的快，坏消息传的慢。好消息的传播以每一个交换周期的速度进行。</p><p>坏消息的传播速度非常慢，例如 A&lt;———B&lt;———-C，C有个坏消息要传A，他会传给B，B又给C，这样循环往复，到A的距离不可达</p><p><strong>水平分裂（split horizon）算法</strong></p><p>对无穷计算问题的解决方案</p><blockquote><p>注：某些拓扑形式下会失败（存在环路）</p></blockquote><p>例：</p><p>A，B到D的距离为2，C到D的距离为1，如果C-D失败，C知道到D是INF，A，B从C知道到D是INF，但是A从B以为到D可达，A就会从B走（B也有类似的问题），经过无限次之后，A和B都知道D不可到</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211015221220033.png" alt="image-20211015221220033"></p><h4 id="LS和DV算法的比较"><a href="#LS和DV算法的比较" class="headerlink" title="LS和DV算法的比较"></a>LS和DV算法的比较</h4><p>两种算法都有优缺点。</p><p>消息复杂度（DV胜出）</p><p>收敛时间（LS胜出）</p><p>健壮性（LS胜出）</p><h3 id="因特网中自治系统内部的路由选择"><a href="#因特网中自治系统内部的路由选择" class="headerlink" title="因特网中自治系统内部的路由选择"></a>因特网中自治系统内部的路由选择</h3><h4 id="RIP（Routing-Information-Protocol）"><a href="#RIP（Routing-Information-Protocol）" class="headerlink" title="RIP（Routing Information Protocol）"></a>RIP（Routing Information Protocol）</h4><p>DV算法</p><ul><li>距离矢量：每条链路cost=1，# of hops (max= 15hops) 跳数</li><li>DV每隔30秒和邻居交换DV，通告</li><li>每个通告包括：最多25个目标子网</li><li>通告：DV：在邻居之间每30秒交换通告报文<ul><li>定期，而且在改变路由的时候发送通告报文</li><li>在对方的请求下也可发送通告报文</li></ul></li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211015224223020.png" alt="image-20211015224223020"></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211015224349738.png" alt="image-20211015224349738"></p><p><strong>RIP：链路失效和恢复</strong></p><p>如果180秒没有收到通告信息—&gt;邻居或者链路失效</p><p>发现经过这个邻居的路由失效，新的通告报文会传递给邻居，邻居因此会发出新的通告（如果路由发生变化），链路失效快速的在整网中传输，使用<strong>毒性逆转</strong>阻止ping-pong回路（不可达的距离：跳数无线=16段）</p><p><strong>RIP：进程处理</strong></p><p>RIP以应用进程方式实现：route-d（daemon），通告报文通过UDP报文传送，周期性重复，网络层的协议使用了传输层的服务，以应用层实体的方式实现</p><h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><p>Open Shortest Path First</p><p>open：标准可公开获得</p><p>使用LS算法，LS分组在网络中（一个AS内部）分发，全局网络在拓扑，代价在每一个节点中保持，路由计算采用Dijkstra算法</p><p>OSPF通告信息中携带：每一个邻居路由器的一个表项，通告信息会传遍AS全部（通过泛洪）（在IP数据报上直接传送OSPF报文，而不是通过UDP和TCP）</p><p><strong>IS-IS路由协议</strong>：几乎和OSPF一样</p><p><strong>“高级特性”</strong>（在RIP中没有的）</p><p><strong>安全</strong>：所有的OSPF报文都是经过认证的</p><p>允许有<strong>多个代价相同的</strong>路径存在（RIP只有一个），对于每一个链路，对不同的TOS有<strong>多重代价矩阵</strong>。对单播和多播集成支持Multicast OSPF。在大型网络中支持<strong>层次性</strong>OSPF</p><p><strong>层次性OSPF</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211016132602160.png"></p><p>2个级别的层次性：本地，骨干</p><p>链路状态通告仅仅在本地Area范围内进行，每一个节点拥有本地区域的拓扑信息</p><p><strong>区域边界路由器：</strong>“汇总“到自己区域内网络的距离，向其他区域边界路由器通告</p><p><strong>骨干路由器：</strong>仅仅在骨干区域内，运行OSPF路由</p><p>边界路由器：连接其他的AS’s</p><h3 id="ISP之间的路由选择：BGP"><a href="#ISP之间的路由选择：BGP" class="headerlink" title="ISP之间的路由选择：BGP"></a><strong>ISP之间的路由选择：BGP</strong></h3><p><strong>层次路由</strong>：将互联网分成一个个AS（路由器区域）</p><p>某个区域内的路由器集合 autonomous systems（AS），一个AS用AS Number（ASN）唯一标识，且一个ISP内可能有多个AS</p><p><strong>AS内部路由</strong>：在同一个AS内，路由器运行相同的路由协议。不同的AS可能运行不同的内部网关协议</p><p>AS间运行<strong>AS间路由协议</strong></p><p><strong>优点</strong></p><p>AS内部<strong>数量有限</strong>的路由器相互到达的问题，AS<strong>内部规模可控</strong></p><p>AS之间的路由，增加一个AS也只是增加一个节点，AS内部的多少不影响AS间路由</p><h4 id="AS间路由：BGP"><a href="#AS间路由：BGP" class="headerlink" title="AS间路由：BGP"></a>AS间路由：BGP</h4><p>Border Gateway Protocol：自治区域间路由协议，将互联网各个AS连接在一起的胶水</p><p>BGP方法：</p><ul><li><p>eBGP：从相邻的ASes那里获得子网可达信息</p></li><li><p>iBGP：将获得的子网可达信息传遍到AS内部的所有路由器</p></li><li><p>根据子网可达信息和策略来决定到达子网的好路径</p></li></ul><p>基于距离矢量算法，允许子网向互联网通告”我在这里“</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211016143409789.png" alt="image-20211016143409789"></p><p><strong>BGP会话</strong>：2个BGP路由器在一个半永久的TCP连接上交换BGP报文</p><p>如当AS3网关路由器3a向AS2的网关路由器2c通告路径：AS3.X</p><p>通告的时候，通告包含BGP属性</p><ul><li>prefix+attributes=”route“</li><li>重要属性<ul><li>AS-PATH：前缀通告所经过的AS列表</li><li>NEXT-HOP：从当前AS下吓一跳AS有多少个链路</li></ul></li></ul><p><strong>BGP报文</strong></p><p>使用TCP协议交换BGP报文</p><ul><li>OPEN：打开TCP连接，认证发送方</li><li>UPDATE：通告新路径（或者撤销原路径）</li><li>KEEPALIVE：在没有更新时保持连接，也用于对OPEN请求确认</li><li>NOTIFICATION：报告以前消息的错误，也用来关闭连接</li></ul><p>路由器转发表项</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211016144742050.png" alt="image-20211016144742050"></p><p><strong>BGP路径选择</strong></p><p>路由器可能获得一个网络前缀的多个路径，路由器必须进行路径的选择，路由选择可以基于：</p><ol><li><p>本地偏好值属性: 偏好策略决定</p></li><li><p>最短AS-PATH ：AS的跳数</p></li><li><p>最近的NEXT-HOP路由器:热土豆路由</p><ul><li><strong>热土豆策略</strong>：选择具备最小内部区域代价的网关作为往X的出口（如：2d选择2a，即使往X可能有比较多的AS跳数）：不要操心域间的代价！</li></ul></li><li><p>附加的判据：使用BGP标示</p></li></ol><p><strong>通过路径通告执行策略</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211016145139366.png" alt="image-20211016145139366"></p><p>例如A通知BC路径Aw，B可以选择不向C通知路径BAw</p><p>策略: </p><ul><li><p>Inter-AS: 管理员需要控制通信路径，谁在使用它的网络进行数据传输；</p></li><li><p>Intra-AS: 一个管理者，所以无需策略; </p><ul><li>AS内部的各子网的主机尽可能地利用资源进行快速路由</li></ul></li></ul><p>规模: </p><ul><li><p>AS间路由必须考虑规模问题，以便支持全网的数据转发</p></li><li><p>AS内部路由规模不是一个大的问题 </p><ul><li>如果AS 太大，可将此AS分成小的AS；规模可控</li><li>AS之间只不过多了一个点而已</li><li>或者AS内部路由支持层次性，层次性路由节约了表空间, 降低了更新的数据流量</li></ul></li></ul><p>性能: </p><ul><li><p>Intra-AS: 关注性能</p></li><li><p>Inter-AS: 策略可能比性能更重要</p></li></ul><h3 id="ICMP：因特网控制报文协议"><a href="#ICMP：因特网控制报文协议" class="headerlink" title="ICMP：因特网控制报文协议"></a>ICMP：因特网控制报文协议</h3><p>由主机，路由器，网关用于传达网络层控制信息（错误报告，Echo请求和回复）</p><p>ICMP处在网络层，但是是在IP协议的上面，ICMP消息由IP数据报承载</p><p><strong>ICMP报文</strong></p><ul><li>类型</li><li>编码</li><li>加上IP数据报的头 8B，第一个导致该ICMP报文的IP数据报</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211016150646484.png" alt="image-20211016150646484"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(自顶向下)第四章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="网络层：数据平面"><a href="#网络层：数据平面" class="headerlink" title="网络层：数据平面"></a>网络层：数据平面</h2><h3 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h3><p><strong>网络层服务</strong></p><p>在发送主机和接收主机对之间传送<strong>段(segment)**，在发送端将段封装到数据报中，在接收端，将段 上交给传输层实体。网络层协议存在于</strong>每一个**主机和路由器。路由器检查每一个经过它的IP数据报的头部。</p><p><strong>网络层的功能</strong></p><ul><li>转发：将分组从路由器的输入接口转发到合适的输出接口</li><li>路由：使用路由算法来决定分组从发送主机到目标接收主机的路径<ul><li>路由选择算法</li><li>路由选择协议</li></ul></li></ul><p><strong>数据平面导论</strong></p><p>本地，每个路由器的功能。决定从路由器输入端口到达的分组，如何转发到输出端口</p><p>转发功能</p><ul><li>传统方式：基于目标地址+转发表</li><li>SDN方式：基于多个字段+流表</li></ul><p><strong>控制平面导论</strong></p><p>网络范围内的逻辑，决定数据报如何在路由器之间路由，决定数据报 从源到目标主机之间的端到端路径</p><p>控制平面方法</p><ul><li>传统的路由算法：在路由器中被实现</li><li>SDN（software-defined networking）：在远程的服务器中实现</li></ul><p>传统方式：在<strong>每一个路由器</strong>中的单独路由器算法元件，在控制平面进行交互</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011150523420.png" alt="image-20211011150523420"></p><p>SDN模式</p><p>远程控制器计算和分发转发表以供每台路由器使用。控制平面和数据平面是物理分开的。也就是<strong>软件定义网络</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011151111494.png" alt="image-20211011151111494"></p><p><strong>网络服务模型</strong>可能包括</p><ul><li>确保交互</li><li>有序分组交互</li><li>确保最小带宽</li><li>安全性</li><li>具有时延上界的确保交付</li></ul><p>因特网提供单一的服务，尽力而为服务</p><h3 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h3><p>路由器体系结构</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011151944542.png" alt="image-20211011151944542"></p><ul><li><p><strong>输入端口</strong>：根据数据报头部的信息，在输入端口内存中的转发表查找合适的输出端口（匹配+行动）</p><ul><li><p><strong>基于目标的转发</strong>：仅仅依赖于IP数据报的目标IP地址（传统方法）</p><p>全球有40多亿节点，不可能每个都弄在表中。所以可以用前缀来进行区分。相同前缀的在一起，前缀后面的数字不同而已。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011160839745.png" alt="image-20211011160839745"></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011160913313.png" alt="image-20211011160913313"></p></li><li><p><strong>通用转发</strong>：基于头部字段的任意集合进行转发</p></li></ul></li></ul><p><strong>输入端口缓存</strong></p><p>因为交换结构有多个输入端口和输出端口。当交换结构的速率小于输入端口的汇聚起来的速率时，输入端口需要排队。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011161157439.png" alt="image-20211011161157439"></p><p><strong>交换结构</strong></p><p>将分组从输入缓冲区传输到合适的输出端口</p><p>交换速率：分组按照交换速率在其中进行传输。N个输入接口，交换速率就是输入端口的N倍</p><p><strong>3种典型的交换结构</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011161357751.png" alt="image-20211011161357751"></p><p><strong>memory通过内存交换</strong>，在cpu直接控制下的交换。</p><p>分组被拷贝到系统内存，CPU从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口。</p><p>缺点：转发速率被内存的带宽限制（数据报需要通过bus总线两次），一次只能转发一个分组</p><p><strong>bus通过总线交换</strong></p><p>数据报通过共享总线，从输入端口转发到输出端口。一次处理一个分组</p><p>总线竞争：交换速度受限于总线带宽</p><p><strong>crossbar通过互联网络的交换</strong></p><p>同时转发多个分组。</p><p><strong>输出端口</strong></p><p>也有缓冲区，交换机构的达到速度比传输速率块，需要输出端口缓存。</p><p>且有<strong>调度机制</strong>。</p><p><strong>调度机制</strong></p><p>机制有很多。</p><ul><li>可以像队列一样先进先出</li><li>按照优先权来进行调度</li><li>循环发同类分组，一类分组发完发另外的。或者按照类的权重进行分配服务时间</li></ul><h3 id="Internet-Protocol"><a href="#Internet-Protocol" class="headerlink" title="Internet Protocol"></a>Internet Protocol</h3><p>网络层功能</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011163006390.png" alt="image-20211011163006390"></p><h4 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h4><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011163109738.png" alt="image-20211011163109738"></p><p><strong>IP分片和重组（Fragmentation &amp; Reassembly）</strong></p><p>因为网络链路有MTU（最大传输单元）（链路层帧所携带的最大数据长度）</p><p>大的IP数据报在网络上被分片，一个数据报被分割成若干个小的数据报。头部相同，重组在目标主机进行。头部信息用于标识，排序相关分片，通过数据偏移量（offset）来进行排序。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011163655528.png" alt="image-20211011163655528"></p><h3 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h3><p>32位二进制标识，一个ip跟一个接口相关联</p><p><strong>子网</strong></p><p>判断方法：将每个接口从主机或者路由器上分开，构成一个个网络孤岛。每个孤岛就是子网subnet。如</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011164146760.png" alt="image-20211011164146760"></p><p><strong>IP地址分类</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011164309052.png" alt="image-20211011164309052"></p><p><strong>IP编址：CIDR</strong></p><p>Classless InterDomain Routing（无类域间路由）</p><p>子网部分可以在任意的位置a.b.c.d/x，其中x是地址中子网号的长度。例如下面x是23，也就是前面长度23为固定地址。不用像abcd类那样分类</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011164920563.png" alt="image-20211011164920563"></p><p><strong>子网掩码</strong></p><p>32bits，0表示主机部分，1表示子网部分。A类是前8为1，B类前16。或者像上面按照需要的位数来进行表示</p><p><strong>转发表和转发算法</strong></p><p>按照子网来进行转发，例如110.10.20.x，在x之前的前缀都由一个路由器接收。那么就转发到这个路由器。如果没找到，就按照默认表项（<strong>路由聚集</strong>）</p><p><strong>获得一个IP地址</strong></p><ul><li>系统管理员将地址配置在一个文件中</li><li>DHCP（Dynamic Host Configuration Protocol）：从服务器中动态获得一个IP地址<ul><li> plug-and-play</li></ul></li></ul><p><strong>DHCP</strong></p><p>工作概述：主机广播 ”DHCP discover”—&gt;DHCP服务器用 “DHCP offer” 提供报文响应—–&gt;主机请求IP地址(发送 DHCP request报文)—–&gt;DHCP服务器发送地址(DHCP ack报文)</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011171542540.png" alt="image-20211011171542540"></p><p>DHCP返回：ip地址，第一段路由器的IP地址（默认网关），DNS服务器的域名和IP地址，子网掩码（指示地址部分的网络号和主机号）</p><p>一个ISP如何获得一个地址块</p><p>ICANN：Internet Corporation for Assigned Names and Numbers</p><ul><li>分配地址</li><li>管理DNS</li><li>分配域名，解决冲突</li></ul><p><strong>NAT：Network Address Translation</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011180005372.png" alt="image-20211011180005372"></p><p>动机：本地网络只有一个有效IP地址</p><ul><li>不需要从ISP分配一块地址，可用一个IP地址用于所有的（局域网）设备（省钱）</li><li>可以在局域网改变设备的地址情况下而无须通知外界</li><li>可以改变ISP（地址变化）而不需要改变内部的设备地址</li><li>局域网内部的设备没有明确的地址，对外是不可见的（安全）</li></ul><p>实现要求：</p><ul><li>外出数据包：替换<strong>源地址和端口号</strong>为<strong>NAT IP</strong>地址和新的端口号，目标IP和端口不变。目标端传回来数据，会将NAT IP地址，新端口号作为目标地址</li><li>记住每个转换替换对（在NAT转换表中）。源IP，端口 <strong>VS</strong> NAT IP，新端口</li><li>从服务器到NAT里面后：替换<strong>目标IP地址和端口号</strong>，<strong>采用存储在NAT表中的mapping表项</strong>，用（源IP，端口）</li></ul><p>有16-bit端口字段，有6w多个同时连接，在一个局域网</p><blockquote><p><strong>对NAT是有争议的</strong></p><p>路由器只应该对第三层做信息处理，而这里对端口号做了处理，是第四层</p><p>违反了end-to-end原则，因为端到端原则中，复杂性的东西应该放到网络边缘，无需借助中转和变换，就可以直接传送到目标主机</p></blockquote><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>为了解决32-bit地址空间用完问题。还有头部格式改变帮助加速处理和转发（TTL-1，头部checksum，分片）。头部格式改变帮助Qos</p><p><strong>IPv6数据报格式</strong></p><ul><li>固定的40字节头部</li><li>数据报传输过程中，不允许分片</li></ul><p><strong>IPv6头部</strong></p><p>Pri（priority）：标示流中数据报的优先级</p><p>Flow Label：标示数据报在一个“flow” （flow的概念没有被严格的定义）</p><p>Next hdr（header）：标示上层协议</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011182540805.png" alt="image-20211011182540805"></p><p>和IPv4的变化</p><p>Checksum：被移除，降低在每一段中的处理速度</p><p>Options：允许，但是头部之外，被Next header字段标示</p><p>ICMpv6：ICMP的新版本，附加了报文类型，Packet Too Big，多播组管理功能</p><h3 id="SDN"><a href="#SDN" class="headerlink" title="SDN"></a>SDN</h3><p>逻辑上集中的控制平面，一个不同的控制器和CA交互，控制器决定分组转发的逻辑（可编程），CA所在设备执行逻辑。（CA为路由器）</p><p><strong>主要思路</strong></p><p>网络设备数据平面和控制平面分离</p><p>数据平面-分组交换机</p><ul><li>将路由器，交换机和目前大多数网络设备的功能进一步<strong>抽象</strong>成：按照流表（由控制平面设置的控制逻辑）进行PDU（帧，分组）的动作（包括转发，丢弃，拷贝，泛洪，阻塞）</li><li><strong>统一化</strong>设备功能：SDN交换机（分组交换机），执行控制逻辑</li></ul><p>控制平面-控制器+网络应用</p><p>分离，集中，计算和下发控制逻辑：流表</p><blockquote><p><strong>优势</strong></p><p><strong>水平集成</strong>控制平面的<strong>开放实现</strong>（而非私有实现），创造出好的产业生态。</p><p><strong>集中</strong>实现控制逻辑，网络<strong>管理容易</strong></p><p>基于流表的<strong>匹配+行动</strong>的工作方式允许“可编程的”分组交换机</p></blockquote><p>传统路由<strong>流量工程</strong>困难</p><p>如果要自定义流量走的路由器，需要去定义链路，然后流量路由以此算法运算。但是如果要将A到B的流量分两路就不可实现。还有等等</p><p>SDN架构：数据平面交换机</p><p>流表被控制器计算和安装，基于南向API（如OpenFlow），SDN控制器访问基于流的交换机，也定义了和控制器的协议</p><p><strong>SDN控制器（网络OS）</strong></p><p>维护网络状态信息，通过上面的北向API和网络控制应用交互，通过下面的南向API和网络交换机交互，逻辑上集中，但是在实现上通常由于性能，可扩展性，容错性以及鲁棒性采用分布式方法</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011194742269.png" alt="image-20211011194742269"></p><p><strong>SDN控制应用</strong></p><p>采用下层提供的服务（SDN控制器提供的API），实现网络功能（路由器，交换机，接入控制，防火墙，负载均衡等）。可以被第三方提供，与控制器厂商不同，与交换机厂商也可以不同</p><h3 id="OpenFlow例子（数据平面抽象）"><a href="#OpenFlow例子（数据平面抽象）" class="headerlink" title="OpenFlow例子（数据平面抽象）"></a>OpenFlow例子（数据平面抽象）</h3><p>流：由分组（帧）头部字段所定义</p><p>通用转发：简单的分组处理规则</p><ul><li>模式：将分组头部字段和流表进行匹配</li><li>行动：对于匹配上的分组，可以丢弃，转发，修改，将匹配的分组发送给控制器</li><li>优先权：几个模式匹配了，优先采用哪个</li><li>计数器：#bytes以及#packets</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011195417472.png" alt="image-20211011195417472"></p><p>这里第一个，表示 src源1-*，目的地址是3-*</p><p>OpenFlow流表的表项结构</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011195518498.png" alt="image-20211011195518498"></p><p><strong>例</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211011195536823.png" alt="image-20211011195536823"></p><p><strong>OpenFlow抽象</strong></p><p>match+action：统一化各种网络设备提供的功能</p><ul><li>路由器，match（最长前缀匹配），action（通过一条链路转发）</li><li>交换机，match（目标MAC地址），action（转发或者泛洪）</li><li>防火墙，match（ip地址和TCP/UDP端口号），action（允许或者禁止）</li><li>NAT，match（IP地址和端口号），action（重写地址）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础排序算法</title>
      <link href="2021/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>2021/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>都是伪码描述，且用 C 实现</p></blockquote><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_Sort</span><span class="params">(ElementType a[],<span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(p=Length<span class="number">-1</span>;p&gt;=<span class="number">0</span>;p--)&#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;p;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[i+<span class="number">1</span>])&#123;</span><br><span class="line">                Swap(A[i],A[i+<span class="number">1</span>]);</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag=<span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//已经完全顺序了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insertion_Sort</span><span class="params">(ElementType a[],<span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(p=<span class="number">1</span>; p&lt;length; p++)&#123;<span class="comment">//假设已经有一个数字，所以从1开始</span></span><br><span class="line">        Tmp = a[p];<span class="comment">//取出一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(i=p; i&gt;<span class="number">0</span> &amp;&amp; a[i<span class="number">-1</span>]&gt;tmp ;i--)</span><br><span class="line">            a[i]=a[i<span class="number">-1</span>];<span class="comment">//如果tmp小于其中的数字，就会移动出空位</span></span><br><span class="line">        a[i]=tmp;<span class="comment">//赋值到移出来的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">( ElementType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 希尔排序 - 用Sedgewick增量序列 */</span></span><br><span class="line">     <span class="keyword">int</span> Si, D, P, i;</span><br><span class="line">     ElementType Tmp;</span><br><span class="line">     <span class="comment">/* 这里只列出一小部分增量 */</span></span><br><span class="line">     <span class="keyword">int</span> Sedgewick[] = &#123;<span class="number">929</span>, <span class="number">505</span>, <span class="number">209</span>, <span class="number">109</span>, <span class="number">41</span>, <span class="number">19</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> ( Si=<span class="number">0</span>; Sedgewick[Si]&gt;=N; Si++ ) </span><br><span class="line">         ; <span class="comment">/* 初始的增量Sedgewick[Si]不能超过待排序列长度 */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> ( D=Sedgewick[Si]; D&gt;<span class="number">0</span>; D=Sedgewick[++Si] )&#123;</span><br><span class="line">         <span class="keyword">for</span> ( P=D; P&lt;N; P++ ) &#123; <span class="comment">/* 插入排序*/</span></span><br><span class="line">             Tmp = A[P];</span><br><span class="line">             <span class="keyword">for</span> ( i=P; i&gt;=D &amp;&amp; A[i-D]&gt;Tmp; i-=D )</span><br><span class="line">                 A[i] = A[i-D];</span><br><span class="line">             A[i] = Tmp;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>算法1-利用最小堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_Sort</span><span class="params">(ElementType a[],<span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line">    BuildHeap(A);<span class="comment">//构建最小堆</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;Length; i++)</span><br><span class="line">        Tmp[i] = DeleteMin(A);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;Length; i++)</span><br><span class="line">        a[i]=Tmp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法2-利用最大堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_Sort</span><span class="params">(ElementType a[], <span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=Length/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        PercDown(a,i,Length);<span class="comment">//buildHeap</span></span><br><span class="line">    <span class="keyword">for</span>(i=length<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">        Swap(&amp;A[<span class="number">0</span>], &amp;a[i]); <span class="comment">//删除（取出）最大值</span></span><br><span class="line">        PercDown(a,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><strong>递归实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* L = 左边起始位置, R = 右边起始位置, RightEnd = 右边终点位置*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">( ElementType A[], ElementType TmpA[], <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> RightEnd )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 */</span></span><br><span class="line">     <span class="keyword">int</span> LeftEnd, NumElements, Tmp;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     </span><br><span class="line">     LeftEnd = R - <span class="number">1</span>; <span class="comment">/* 左边终点位置 */</span></span><br><span class="line">     Tmp = L;         <span class="comment">/* 有序序列的起始位置 */</span></span><br><span class="line">     NumElements = RightEnd - L + <span class="number">1</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">while</span>( L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd ) &#123;</span><br><span class="line">         <span class="keyword">if</span> ( A[L] &lt;= A[R] )</span><br><span class="line">             TmpA[Tmp++] = A[L++]; <span class="comment">/* 将左边元素复制到TmpA */</span></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             TmpA[Tmp++] = A[R++]; <span class="comment">/* 将右边元素复制到TmpA */</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>( L &lt;= LeftEnd )</span><br><span class="line">         TmpA[Tmp++] = A[L++]; <span class="comment">/* 直接复制左边剩下的 */</span></span><br><span class="line">     <span class="keyword">while</span>( R &lt;= RightEnd )</span><br><span class="line">         TmpA[Tmp++] = A[R++]; <span class="comment">/* 直接复制右边剩下的 */</span></span><br><span class="line">         </span><br><span class="line">     <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; NumElements; i++, RightEnd -- )</span><br><span class="line">         A[RightEnd] = TmpA[RightEnd]; <span class="comment">/* 将有序的TmpA[]复制回A[] */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Msort</span><span class="params">( ElementType A[], ElementType TmpA[], <span class="keyword">int</span> L, <span class="keyword">int</span> RightEnd )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 核心递归排序函数 */</span> </span><br><span class="line">     <span class="keyword">int</span> Center;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> ( L &lt; RightEnd ) &#123;</span><br><span class="line">          Center = (L+RightEnd) / <span class="number">2</span>;</span><br><span class="line">          Msort( A, TmpA, L, Center );              <span class="comment">/* 递归解决左边 */</span> </span><br><span class="line">          Msort( A, TmpA, Center+<span class="number">1</span>, RightEnd );     <span class="comment">/* 递归解决右边 */</span>  </span><br><span class="line">          Merge( A, TmpA, L, Center+<span class="number">1</span>, RightEnd );  <span class="comment">/* 合并两段有序序列 */</span> </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">( ElementType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 归并排序 */</span></span><br><span class="line">     ElementType *TmpA;</span><br><span class="line">     TmpA = (ElementType *)<span class="built_in">malloc</span>(N*<span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> ( TmpA != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">          Msort( A, TmpA, <span class="number">0</span>, N<span class="number">-1</span> );</span><br><span class="line">          <span class="built_in">free</span>( TmpA );</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="built_in">printf</span>( <span class="string">&quot;空间不足&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>顺序实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这里Merge函数在递归版本中给出 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* length = 当前有序子列的长度*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_pass</span><span class="params">( ElementType A[], ElementType TmpA[], <span class="keyword">int</span> N, <span class="keyword">int</span> length )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 两两归并相邻有序子列 */</span></span><br><span class="line">     <span class="keyword">int</span> i, j;</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">for</span> ( i=<span class="number">0</span>; i &lt;= N<span class="number">-2</span>*length; i += <span class="number">2</span>*length )</span><br><span class="line">         Merge( A, TmpA, i, i+length, i+<span class="number">2</span>*length<span class="number">-1</span> );</span><br><span class="line">     <span class="keyword">if</span> ( i+length &lt; N ) <span class="comment">/* 归并最后2个子列*/</span></span><br><span class="line">         Merge( A, TmpA, i, i+length, N<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="comment">/* 最后只剩1个子列*/</span></span><br><span class="line">         <span class="keyword">for</span> ( j = i; j &lt; N; j++ ) TmpA[j] = A[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_Sort</span><span class="params">( ElementType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     <span class="keyword">int</span> length; </span><br><span class="line">     ElementType *TmpA;</span><br><span class="line">     </span><br><span class="line">     length = <span class="number">1</span>; <span class="comment">/* 初始化子序列长度*/</span></span><br><span class="line">     TmpA = <span class="built_in">malloc</span>( N * <span class="keyword">sizeof</span>( ElementType ) );</span><br><span class="line">     <span class="keyword">if</span> ( TmpA != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">          <span class="keyword">while</span>( length &lt; N ) &#123;</span><br><span class="line">              Merge_pass( A, TmpA, N, length );</span><br><span class="line">              length *= <span class="number">2</span>;</span><br><span class="line">              Merge_pass( TmpA, A, N, length );</span><br><span class="line">              length *= <span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">free</span>( TmpA );</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="built_in">printf</span>( <span class="string">&quot;空间不足&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取中间，首位，尾部的中间数来当pivot</span></span><br><span class="line"><span class="function">ElementType <span class="title">Median3</span><span class="params">( ElementType A[], <span class="keyword">int</span> Left, <span class="keyword">int</span> Right )</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> Center = (Left+Right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( A[Left] &gt; A[Center] )</span><br><span class="line">        Swap( &amp;A[Left], &amp;A[Center] );</span><br><span class="line">    <span class="keyword">if</span> ( A[Left] &gt; A[Right] )</span><br><span class="line">        Swap( &amp;A[Left], &amp;A[Right] );</span><br><span class="line">    <span class="keyword">if</span> ( A[Center] &gt; A[Right] )</span><br><span class="line">        Swap( &amp;A[Center], &amp;A[Right] );</span><br><span class="line">    <span class="comment">/* 此时A[Left] &lt;= A[Center] &lt;= A[Right] */</span></span><br><span class="line">    Swap( &amp;A[Center], &amp;A[Right<span class="number">-1</span>] ); <span class="comment">/* 将基准Pivot藏到右边*/</span></span><br><span class="line">    <span class="comment">/* 只需要考虑A[Left+1] … A[Right-2] */</span></span><br><span class="line">    <span class="keyword">return</span>  A[Right<span class="number">-1</span>];  <span class="comment">/* 返回基准Pivot */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qsort</span><span class="params">( ElementType A[], <span class="keyword">int</span> Left, <span class="keyword">int</span> Right )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 核心递归函数 */</span> </span><br><span class="line">     <span class="keyword">int</span> Pivot, Cutoff, Low, High;</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">if</span> ( Cutoff &lt;= Right-Left ) &#123; <span class="comment">/* 如果序列元素充分多，进入快排 */</span></span><br><span class="line">          Pivot = Median3( A, Left, Right ); <span class="comment">/* 选基准 */</span> </span><br><span class="line">          Low = Left; High = Right<span class="number">-1</span>;</span><br><span class="line">          <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">/*将序列中比基准小的移到基准左边，大的移到右边*/</span></span><br><span class="line">               <span class="keyword">while</span> ( A[++Low] &lt; Pivot ) ;</span><br><span class="line">               <span class="keyword">while</span> ( A[--High] &gt; Pivot ) ;</span><br><span class="line">               <span class="keyword">if</span> ( Low &lt; High ) Swap( &amp;A[Low], &amp;A[High] );</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          Swap( &amp;A[Low], &amp;A[Right<span class="number">-1</span>] );   <span class="comment">/* 将基准换到正确的位置 */</span> </span><br><span class="line">          Qsort( A, Left, Low<span class="number">-1</span> );    <span class="comment">/* 递归解决左边 */</span> </span><br><span class="line">          Qsort( A, Low+<span class="number">1</span>, Right );   <span class="comment">/* 递归解决右边 */</span>  </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> InsertionSort( A+Left, Right-Left+<span class="number">1</span> ); <span class="comment">/* 元素太少，用简单排序 */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">( ElementType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 统一接口 */</span></span><br><span class="line">     Qsort( A, <span class="number">0</span>, N<span class="number">-1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>次位优先</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxDigit 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Radix 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 桶元素结点 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 桶头结点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeadNode</span> &#123;</span></span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeadNode</span> <span class="title">Bucket</span>[<span class="title">Radix</span>];</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDigit</span> <span class="params">( <span class="keyword">int</span> X, <span class="keyword">int</span> D )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 默认次位D=1, 主位D&lt;=MaxDigit */</span></span><br><span class="line">    <span class="keyword">int</span> d, i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=D; i++) &#123;</span><br><span class="line">        d = X % Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LSDRadixSort</span><span class="params">( ElementType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 基数排序 - 次位优先 */</span></span><br><span class="line">     <span class="keyword">int</span> D, Di, i;</span><br><span class="line">     Bucket B;</span><br><span class="line">     PtrToNode tmp, p, List = <span class="literal">NULL</span>; </span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;Radix; i++) <span class="comment">/* 初始化每个桶为空链表 */</span></span><br><span class="line">         B[i].head = B[i].tail = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123; <span class="comment">/* 将原始序列逆序存入初始链表List */</span></span><br><span class="line">         tmp = (PtrToNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">         tmp-&gt;key = A[i];</span><br><span class="line">         tmp-&gt;next = List;</span><br><span class="line">         List = tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 下面开始排序 */</span> </span><br><span class="line">     <span class="keyword">for</span> (D=<span class="number">1</span>; D&lt;=MaxDigit; D++) &#123; <span class="comment">/* 对数据的每一位循环处理 */</span></span><br><span class="line">         <span class="comment">/* 下面是分配的过程 */</span></span><br><span class="line">         p = List;</span><br><span class="line">         <span class="keyword">while</span> (p) &#123;</span><br><span class="line">             Di = GetDigit(p-&gt;key, D); <span class="comment">/* 获得当前元素的当前位数字 */</span></span><br><span class="line">             <span class="comment">/* 从List中摘除 */</span></span><br><span class="line">             tmp = p; p = p-&gt;next;</span><br><span class="line">             <span class="comment">/* 插入B[Di]号桶尾 */</span></span><br><span class="line">             tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">             <span class="keyword">if</span> (B[Di].head == <span class="literal">NULL</span>)</span><br><span class="line">                 B[Di].head = B[Di].tail = tmp;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 B[Di].tail-&gt;next = tmp;</span><br><span class="line">                 B[Di].tail = tmp;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/* 下面是收集的过程 */</span></span><br><span class="line">         List = <span class="literal">NULL</span>; </span><br><span class="line">         <span class="keyword">for</span> (Di=Radix<span class="number">-1</span>; Di&gt;=<span class="number">0</span>; Di--) &#123; <span class="comment">/* 将每个桶的元素顺序收集入List */</span></span><br><span class="line">             <span class="keyword">if</span> (B[Di].head) &#123; <span class="comment">/* 如果桶不为空 */</span></span><br><span class="line">                 <span class="comment">/* 整桶插入List表头 */</span></span><br><span class="line">                 B[Di].tail-&gt;next = List;</span><br><span class="line">                 List = B[Di].head;</span><br><span class="line">                 B[Di].head = B[Di].tail = <span class="literal">NULL</span>; <span class="comment">/* 清空桶 */</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 将List倒入A[]并释放空间 */</span></span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        tmp = List;</span><br><span class="line">        List = List-&gt;next;</span><br><span class="line">        A[i] = tmp-&gt;key;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主位优先</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxDigit 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Radix 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 桶元素结点 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 桶头结点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeadNode</span> &#123;</span></span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeadNode</span> <span class="title">Bucket</span>[<span class="title">Radix</span>];</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDigit</span> <span class="params">( <span class="keyword">int</span> X, <span class="keyword">int</span> D )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 默认次位D=1, 主位D&lt;=MaxDigit */</span></span><br><span class="line">    <span class="keyword">int</span> d, i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=D; i++) &#123;</span><br><span class="line">        d = X%Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSD</span><span class="params">( ElementType A[], <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> D )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 核心递归函数: 对A[L]...A[R]的第D位数进行排序 */</span></span><br><span class="line">     <span class="keyword">int</span> Di, i, j;</span><br><span class="line">     Bucket B;</span><br><span class="line">     PtrToNode tmp, p, List = <span class="literal">NULL</span>; </span><br><span class="line">     <span class="keyword">if</span> (D==<span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">/* 递归终止条件 */</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;Radix; i++) <span class="comment">/* 初始化每个桶为空链表 */</span></span><br><span class="line">         B[i].head = B[i].tail = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=L; i&lt;=R; i++) &#123; <span class="comment">/* 将原始序列逆序存入初始链表List */</span></span><br><span class="line">         tmp = (PtrToNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">         tmp-&gt;key = A[i];</span><br><span class="line">         tmp-&gt;next = List;</span><br><span class="line">         List = tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 下面是分配的过程 */</span></span><br><span class="line">     p = List;</span><br><span class="line">     <span class="keyword">while</span> (p) &#123;</span><br><span class="line">         Di = GetDigit(p-&gt;key, D); <span class="comment">/* 获得当前元素的当前位数字 */</span></span><br><span class="line">         <span class="comment">/* 从List中摘除 */</span></span><br><span class="line">         tmp = p; p = p-&gt;next;</span><br><span class="line">         <span class="comment">/* 插入B[Di]号桶 */</span></span><br><span class="line">         <span class="keyword">if</span> (B[Di].head == <span class="literal">NULL</span>) B[Di].tail = tmp;</span><br><span class="line">         tmp-&gt;next = B[Di].head;</span><br><span class="line">         B[Di].head = tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 下面是收集的过程 */</span></span><br><span class="line">     i = j = L; <span class="comment">/* i, j记录当前要处理的A[]的左右端下标 */</span></span><br><span class="line">     <span class="keyword">for</span> (Di=<span class="number">0</span>; Di&lt;Radix; Di++) &#123; <span class="comment">/* 对于每个桶 */</span></span><br><span class="line">         <span class="keyword">if</span> (B[Di].head) &#123; <span class="comment">/* 将非空的桶整桶倒入A[], 递归排序 */</span></span><br><span class="line">             p = B[Di].head;</span><br><span class="line">             <span class="keyword">while</span> (p) &#123;</span><br><span class="line">                 tmp = p;</span><br><span class="line">                 p = p-&gt;next;</span><br><span class="line">                 A[j++] = tmp-&gt;key;</span><br><span class="line">                 <span class="built_in">free</span>(tmp);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">/* 递归对该桶数据排序, 位数减1 */</span></span><br><span class="line">             MSD(A, i, j<span class="number">-1</span>, D<span class="number">-1</span>);</span><br><span class="line">             i = j; <span class="comment">/* 为下一个桶对应的A[]左端 */</span></span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSDRadixSort</span><span class="params">( ElementType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 统一接口 */</span></span><br><span class="line">    MSD(A, <span class="number">0</span>, N<span class="number">-1</span>, MaxDigit); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(自顶向下)第三章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="概述传输层（TCP-UDP）"><a href="#概述传输层（TCP-UDP）" class="headerlink" title="概述传输层（TCP/UDP）"></a>概述传输层（TCP/UDP）</h2><p>为运行在不同主机上的应用进程提供<strong>逻辑通信</strong></p><p>传输协议运行在端系统，发送方将应用层的报文分成<strong>报文段</strong>，传递给网络层。接收方将报文段重组成报文，然后传递给应用层</p><p><strong>传输层和网络层的差别</strong></p><p>网络层服务：主机之间的逻辑通信</p><p>传输层服务，进程间的逻辑通信，且依赖于网络层的服务（延时，带宽），并对网络层的服务进行增强（数据丢失，顺序混乱，加密）</p><p><strong>Internet传输层协议</strong></p><p>TCP：可靠的，保序的传输，多路复用解复用，拥塞控制，流量控制，建立连接</p><p>UDP：不可靠，不保序的传输，没有给ip服务添加更多的服务</p><p>都不提供延时保证，带宽保证</p><h2 id="多路复用-解复用"><a href="#多路复用-解复用" class="headerlink" title="多路复用/解复用"></a>多路复用/解复用</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008154118576.png" alt="image-20211008154118576"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>主机收到ip数据报，每个数据报有源IP地址和目标地址，承载一个传输层报文段，有一个源端口号和目标端口号（UDP只有目标端口号）</li><li>服务器联合使用<strong>IP地址</strong>和<strong>端口号</strong>将报文段发送给合适的套接字</li></ul><h2 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：UDP</h2><p>User Datagram Protocol</p><p>”尽力而为式的服务“，报文段可能丢失，可能乱序。但是在应用层进行增加可靠性可以实现可靠传输。</p><p><strong>无连接</strong>：UDP发送端和接收端之间无握手，每个UDP报文段都被独立处理</p><p>应用：流媒体，DNS，SNMP</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008155135484.png" alt="image-20211008155135484"></p><h3 id="UDP校验和"><a href="#UDP校验和" class="headerlink" title="UDP校验和"></a>UDP校验和</h3><p>目标：检测在被传输报文段中的差错</p><p><strong>发送方</strong></p><ul><li>将报文段的内容视为16比特的整数</li><li>检验和：报文段的加法和（1的补运算）</li><li>发送放将检验和放在UDP的 校验和 字段</li></ul><p><strong>接收方</strong></p><ul><li>计算接收到的报文段的检验和</li><li>检查计算出的 校验和 与 校验和 字段的内容是否相等：<ul><li>不相等-检测到差错</li><li>相等–可能无差错</li></ul></li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008155721874.png" alt="image-20211008155721874"></p><h2 id="可靠数据传输-rdt-的原理"><a href="#可靠数据传输-rdt-的原理" class="headerlink" title="可靠数据传输(rdt)的原理"></a>可靠数据传输(rdt)的原理</h2><p>rdt在应用层，传输层和数据链路层都重要，是网络TOP10问题之一。信道的不可靠特点决定了可靠数据传输协议的复杂性</p><p>先看以下四种运行状态</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008161156148.png" alt="image-20211008161156148"></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008161227419.png" alt="image-20211008161227419"></p><p>具体原理为</p><p>发送方</p><ul><li>发送的数据分组，进行编号。发送出去之后进行超时计时</li><li>收到0就发1，如果发了1之后还是收到0。就发0</li></ul><p>接收方</p><ul><li>接收数据分组。接收到0之后返回收到了0，发送方就会发1。</li><li>如果1发送错了。或者没发过来。发送方超时就会重发</li></ul><p>具体看图。就能理解</p><p><strong>性能</strong></p><p>虽然这个rdt能工作，但是链路容量大的话。性能很差。链路容量大，但是我们一次只发一个PDU，浪费的链路容量。</p><p>设 15ms端到端延迟-分组大小为1kB</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008162022117.png" alt="image-20211008162022117"></p><h3 id="流水线：提高链路利用率"><a href="#流水线：提高链路利用率" class="headerlink" title="流水线：提高链路利用率"></a>流水线：提高链路利用率</h3><p>流水线：允许发送方在<strong>未得到对方确认</strong>的情况下，一次发送<strong>多个</strong>分组</p><ul><li>但是需要增加序号的范围，用多个bit表示分组序号</li><li>在发送方/接收方要有缓冲区<ul><li>发送方缓冲，未得到确认，可能需要重传</li><li>接收方缓冲，上层用户取用的速率 和 接收数据速率不等，接受的数据可能乱序，缓冲实现排序交付</li></ul></li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008162237506.png" alt="image-20211008162237506"></p><p>两种通用的流水线协议：回退N步（GBN），选择重传（SR）</p><h4 id="回退N步GBN—-选择重传SR"><a href="#回退N步GBN—-选择重传SR" class="headerlink" title="回退N步GBN—-选择重传SR"></a>回退N步GBN—-选择重传SR</h4><p>也称为 滑动窗口（slide window)协议</p><p><strong>发送窗口</strong>-发送缓冲区</p><blockquote><p>这里虽然已经把绿色的部分全画出来了。实际工作是，没有数据时，后沿等于前沿。有一个分组进来，前沿+1。后沿的不动。等到低序号的确认到来，后沿再+1；</p></blockquote><p>允许发送方发送多个分组而不需要确认。但是不允许超过最大允许数N</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008163353238.png" alt="image-20211008163353238"></p><p>在这里，绿色框起来的就是最大允许数的内容。0之前的是已经发送且确认了的。绿色中的是发送了未确认，或一部分是空的。4之后就是未发送的内容。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008163543798.png" alt="image-20211008163543798"></p><p>像这样就是0已经确认，1234发送了未确认，5还没数据发送，等待数据来进行发送。</p><p><strong>接收窗口</strong>-接收缓冲区</p><p>只有收到的分组序号落入接收窗口才允许接收，若序号在接收窗口之外，则丢弃。</p><p>接收窗口尺寸Wr=1只能顺序接收，&gt;1可以乱序接收</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008164333168.png" alt="image-20211008164333168"></p><p>低序号到来，就移动。如果高序号先到，位置不动，要等最低的来了才动</p><p><strong>正常情况下的互动</strong></p><p><strong>发送窗口</strong></p><ul><li>新的分组落入发送缓冲区，发送，前沿移动</li><li>来了低序号的确认，后沿向前移动</li></ul><p><strong>接收窗口</strong></p><ul><li>收到分组，落入到接收窗口范围内，接收。</li><li>低序号，发送确认给对方</li></ul><p><strong>异常情况的互动</strong></p><p><strong>GBN</strong></p><p>发送窗口</p><ul><li>新分组落入发送缓冲区范围，发送-&gt;前沿滑动</li><li><strong>超时重发机制让发送端将发送窗口中的所有分组发送出去</strong></li><li>来了老分组的重复确认，后沿不动。新分组无法落入发送缓冲区的范围</li></ul><p>接收窗口</p><ul><li>收到乱序分组，没有落入到接收窗口范围内，抛弃</li><li>（重复）发送老分组的确认，累计确认</li></ul><p><strong>SR</strong></p><p>发送窗口</p><ul><li>新分组落入发送缓冲区范围，发送前沿滑动</li><li><strong>超时重发机制让发送端将超市的分组重新发出去</strong></li><li>来了乱序分组的确认，后沿不动，新的分组无法落入发送缓冲区的范围</li></ul><p>接受窗口</p><ul><li>收到乱序分组，落入到接收窗口范围内，接收</li><li>发送该分组的确认，单独确认</li></ul><p><strong>GBN协议和SR协议的异同</strong></p><p>相同</p><ul><li>发送窗口&gt;1</li><li>一次能够发送多个未经确认的分组</li></ul><p>不同</p><ul><li>GBN：接收窗口尺寸=1，接收端只能顺序接收。发送端一旦一个分组没有发送成功，其他的所有都发一次。一共只有一个定时器，在最低序号的位置</li><li>SR：接收窗口尺寸&gt;1，接收端可以乱序接收。发送端只发送没有收到的确认。也就是每个分组都有一个定时器</li></ul><h2 id="TCP-面向连接的传输"><a href="#TCP-面向连接的传输" class="headerlink" title="TCP-面向连接的传输"></a>TCP-面向连接的传输</h2><p><strong>概述</strong></p><ul><li>点对点</li><li>可靠的，按顺序的字节流。没有报文边界</li><li>管道化（流水线），TCP拥塞控制和流量控制设置窗口大小</li><li>发送和接收缓存</li><li>全双工数据：在同一连接中数据流双向流动。MSS：最大报文段大小</li><li>面向连接：在数据交换之前，通过握手（交换控制报文）初始化发送方、接收方的状态变量</li><li>有流量控制：发送方不会淹没接收方</li></ul><h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008215034655.png" alt="image-20211008215034655"></p><ul><li>序号：报文段首字节的在字节流的编号</li><li>确认号：期望从另一方收到的下一个字节的序号</li></ul><p><strong>TCP往返延迟和超时</strong></p><p>估计RTT：测量从报文段发出到收到确认的时间，如果有重传就忽略此次测量。对几次测量的样本取平均</p><p>TCP超市：设置的比RTT长，太早超时，会有不必要的重传。太长，报文段的丢失反应太慢。具体视情况定</p><h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>TCP在IP不可靠服务的基础上建立rdt</p><ul><li>管道化的报文段（GBN/SR）</li><li>累计确认（类似GBN）</li><li>单个重传定时器（类似GBN）</li></ul><p>通过超时，重复的确认来触发重传</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008225738753.png" alt="image-20211008225738753"></p><p><strong>快速重传</strong></p><p>问题：超时的周期往往很长（在重传丢失报文段之前的延时太长），发送方通常连续发送大量报文段，如果报文段丢失，会引起多个重复的ACK</p><p><strong>快速重传：</strong>在定时器过时之前重发报文段</p><p>假设在被确认的数据后面的数据丢失了。第一个ACK正常，第二个段的丢失，收到第三第四段的确认，大概率第二个ACK丢失。进行重传</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008230145503.png" alt="image-20211008230145503"></p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>接收方控制发送方，不让发送方发送的太多太快，以至于让接收方缓冲区溢出</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008230356531.png" alt="image-20211008230356531"></p><ul><li>接收方在其发送方的TCP段头的rwnd字段，告知其空闲buffer大小</li><li>发送方限制字节个数 &lt;=接收方发送来的rwnd值</li><li>保证接收方不会被淹没</li></ul><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>发送方和接收方握手建立通信关系，如下是同一连接参数</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008230752402.png" alt="image-20211008230752402"></p><p><strong>TCP可以两次握手吗？</strong></p><p><strong>两次握手有失败的场景</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008231008820.png" alt="image-20211008231008820"></p><p><strong>这个问题在三次握手中解决掉了</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008231042227.png" alt="image-20211008231042227"></p><p><strong>三次握手的建立方式</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008231118918.png" alt="image-20211008231118918"></p><p><strong>TCP关闭连接</strong></p><ul><li>客户端，服务器分别关闭它自己这一侧的连接，发送FIN bit=1 的TCP段</li><li>一旦接收到FIN，用ACK回应，ACK中带着FIN段一起发送。</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211008231300897.png" alt="image-20211008231300897"></p><h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><p>也是网络TOP10中的问题</p><p>简单来说就是，发的数据包超过了网络的处理能力。（不一定是我们一个人发的）</p><p>拥塞带来的问题就是，分组丢失，分组经历比较长的延迟（在路由器中排队）</p><p>例如：有两个主机，一个路由器，两个服务器。两个主机往服务器发送数据。都通过一个路由器，那如果路由器的缓冲区满了之后，其他的分组就会丢失了。虽然会重传数据。但是其中也浪费了时间。还有其他的一些例子</p><p><strong>解决方案</strong>，两个常用的拥塞控制方法</p><p><strong>端到端拥塞控制（TCP采用的方法）</strong>：没有来自网络的显示反馈，段系统根据延迟和丢失事件判断是否有拥塞</p><p><strong>网络辅助的拥塞控制</strong>：路由器提供给段系统以反馈信息，单个bit置位，显示有拥塞，显示提供发送端可以采用的速率。</p><h3 id="扩展ATM-ABR拥塞控制"><a href="#扩展ATM-ABR拥塞控制" class="headerlink" title="扩展ATM ABR拥塞控制"></a>扩展ATM ABR拥塞控制</h3><p><strong>ABR：available bit rate</strong></p><p>弹性服务，如果发送端的路径 “轻载”，发送方增加使用可用带宽。如果路径拥塞了，发送方限制发送速率到最小保障速率上。</p><p><strong>RM（资源管理）信元</strong></p><p>由发送端发送，在数据信元中间隔插入</p><p>RM信元中的比特被交换机设置（“网络辅助”）</p><ul><li>NI bit（no increase in rate）轻微拥塞，速率不要增加了</li><li>CI bit（congestion indication）拥塞指示</li></ul><p>在RM信元中的2个字节ER（explicit rate）字段，拥塞的交换机可能会降低信元中ER的值，发送端发送速度是最低的可支持速率</p><p>如果管理信元RM前面的数据信元EFCI被设置为1，接收端返回的RM信元中设置CI bit</p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p><strong>端到端的拥塞控制机制</strong></p><p>路由器不向主机发送有关拥塞的反馈信息，路由器负担较轻，符合网络核心简单的TCP/IP架构原则，端系统根据自身得到的信息，判断是否发生拥塞，从而采取动作</p><p><strong>拥塞感知</strong></p><ul><li>某个段丢失<ul><li>网络拥塞（某个路由器缓冲没空间，被丢弃）大概率</li><li>出错被丢弃（各级错误，没有通过校验，被丢弃）小概率</li></ul></li><li>收到某个段3次重复的ACK（轻微拥塞）<ul><li>第一个ACK1正常</li><li>收到第二个重复ACK，第三个重复的ACK1。大概率ACK2丢失。</li></ul></li></ul><p><strong>速率控制方法</strong></p><p>维持一个拥塞窗口的值：CongWin，发送端限制发送的数据量。CongWin’动态改变</p><ul><li>超时：CongWin降为1MSS，进入 SS阶段 然后再倍增到CongWin/2，从而进入CA阶段</li><li>3个重复ACK，CongWin降为CongWin/2，CA阶段</li></ul><p><strong>SS阶段：加倍增加</strong></p><p><strong>CA阶段：线性增加</strong></p><p><strong>具体策略概述</strong></p><ul><li>慢启动</li><li>AIMD：线性增，乘性减少</li><li>超时事件后的保守策略</li></ul><p><strong>慢启动</strong></p><p>连接刚建立CongWIn=1 MSS，连接开始时指数性增加发送速率，直到有丢失事件。</p><ul><li>每一个RTT，CongWin加倍</li><li>每收到一个ACK时，CongWin加1</li><li>慢启动阶段只要不超时或有3个重复ack，一个RTT，CongWin加倍</li></ul><p><strong>AIMD阶段</strong></p><ul><li>当收到<strong>3个重复的ACKs</strong><ul><li>CongWin减半</li><li>窗口（缓冲区大小）线性增长</li></ul></li><li>当超时事件发生时<ul><li>CongWin被设置成1MSS，进入SS阶段</li><li>之后窗口指数增长，增长到一个阈值（上次发生拥塞的窗口的一半）时，再线性增加。</li></ul></li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211009102302495.png" alt="image-20211009102302495"></p><h3 id="TCP公平性"><a href="#TCP公平性" class="headerlink" title="TCP公平性"></a>TCP公平性</h3><p>两个竞争的TCP会话</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211009103218507.png" alt="image-20211009103218507"></p><p>但是互联网中不只有TCP，还有UDP（没有拥塞控制）。这样就没办法公平</p><p>或者两个主机间，有一个主机有多个TCP并行连接，他获取的资源就不止R/2，而是大于R/2。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(自顶向下)第二章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="1-应用层协议原理"><a href="#1-应用层协议原理" class="headerlink" title="1.应用层协议原理"></a>1.应用层协议原理</h2><p><strong>可能的应用架构</strong></p><ul><li><p>客户-服务器模式（C/S：client/server）</p><ul><li>服务器：一直运行，固定的 Ip 地址和周知的端口号（约定），扩展性差</li><li>客户端：主动与服务器通信，与互联网有间歇性的连接，可能是动态Ip地址，不直接与其他客户端通信</li></ul></li><li><p>对等模式（P2P：Peer To Peer）</p><ul><li>（几乎）没有一直运行的服务器，任意端系统之间可以进行通信，每一个节点既是客户端又是服务器</li><li>自扩展性-新peer节点带来新的服务能力，也带来新的服务请求</li><li>参与的主机间歇性连接且可以改变Ip地址，但是难以管理</li></ul></li><li><p>混合体：客户-服务器和对等体系结构，C/S和P2P体系结构的混合体</p><ul><li><p>Napster：文件搜索：集中，主机在中心服务器上注册其资源，在中心服务器查询资源位置。</p><p>文件传输P2P：任意Peer节点之间</p></li><li><p>即时通信：在线检测：集中，当用户上线向服务器注册ip地址，用户与中心服务器连接，找到在线好友位置。</p><p>两个用户聊天：P2P</p></li></ul></li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程：在主机上运行的应用程序。分为客户端和服务器</p><ul><li>客户端：发起通信的进程</li><li>服务器：等待连接的进程</li></ul><p>同一个主机内，使用进程间的通信机制进行通信</p><p>不同主机，通过交换<strong>报文（Message）</strong>来通信</p><ul><li>使用OS提供的通信服务</li><li>按照应用协议交换报文，借助传输层提供的服务</li></ul><p><strong>但是这样进行通信，会有通信的问题需要解决</strong></p><ol><li>进程标示和寻址问题（服务用户）</li><li>传输层-应用层提供服务是如何（服务）<ul><li>位置：层间界面的SAP（TCP/IP：socket）</li><li>形式：应用程序接口API（TCP/IP：socket API）</li></ul></li><li>如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用（用户使用服务）<ul><li>定义应用层想协议：报文格式，解释，时序等</li><li>编制程序，使用OS提供的API，调用网络基础设施提供通信服务传报文，实现应用时序等；</li></ul></li></ol><p><strong>解决</strong></p><ol><li><p><strong>标识（Ip+Port）每个主机都有IP地址，和端口号，IP地址找到主机，端口号找到具体进程</strong></p></li><li><p><strong>传输层提供的服务-需要穿过层间的信息</strong></p><ul><li><p>层间接口必须携带各种信息</p><p>要传输的报文，谁传的，对方的IP+TCP/UDP端口，传给谁：对方的IP+TCP(UDP）端口号。传输层实体根据信息进行TCP报文段UDP数据报封装。等等</p></li></ul><p>每次传输这么多信息很麻烦。可以用socket代号标示双方或单方。用一个整数表示两个应用实体之间的通信关系，放在本地进行标示。</p><p><strong>TCP之上的套接字</strong>：对于TCP而言，套接字是4元组（源ip，源port，目标ip，目标port）的一个具有本地意义的标示，唯一的指定一个会话，应用只需要使用这个标示就可以进行通信。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210924144012076.png" alt="image-20210924144012076"></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210924144035137.png" alt="image-20210924144035137"></p><p><strong>UDP socket</strong></p><p>UDP服务是不需要建立连接的。每个报文都独立传输，可以只用一个整数就可以标示本应用实体的标示，socket只需要IP+本端口，传输报文时，需要对方的IP+Port</p><p>所以使用的是2元组具有本地意义的标示</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210924144435203.png" alt="image-20210924144435203"></p><blockquote><p>套接字的发送和接收进程都在传输层的设施中</p></blockquote></li><li><p><strong>如何使用传输层提供的服务实现应用</strong></p><ul><li>定义应用层协议：报文格式，解释，时序等</li><li>编制程序，通过API调用网络基础设施提供通信服务传报文，解析报文，实现应用时序等</li></ul></li></ol><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p><strong>定义了：运行在不同端系统上的应用进程，如何交换报文</strong>。如HTTP协议，SMTP等</p><p>分为公开协议和专用（私有）协议</p><p><strong>应用需要传输层提供的服务</strong></p><p>延迟，吞吐，数据丢失率，安全性等的要求</p><p><strong>传输层提供的服务</strong></p><ul><li><p>TCP服务</p></li><li><p>UDP服务</p><p>UDP必要性，能够区分不同的进程，IP服务不能。无需建立连接。不做可靠性的工作，应用能够按照设定的速度发送数据。</p></li></ul><p><strong>TCP安全</strong></p><p>TCP和UDP都是不加密的协议，明文传输密码等</p><p>SSL协议可以解决此问题，采用SSL库，在TCP上实现，提供加密的TCP连接。</p><h2 id="Web-and-HTTP"><a href="#Web-and-HTTP" class="headerlink" title="Web and HTTP"></a>Web and HTTP</h2><p>术语</p><ul><li>Web页：由一些对象组成</li><li>对象可以是HTML文件，JPEG图像，Java小程序，声音剪辑文件等</li><li>web页有一个基本的HTML文件，该基本HTMl文件又包含若干对象的引用（链接）</li><li>URL格式</li></ul><p><a href="https://user%40psw@blog.yvenxx.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html">https://user@psw@blog.yvenxx.cn/计算机网络.html</a> : port</p><p>协议名://用户:口令@主机名/路径名 : port</p><h3 id="HTTP-概括"><a href="#HTTP-概括" class="headerlink" title="HTTP 概括"></a>HTTP 概括</h3><p>HTTP：超文本传输协议</p><ul><li>Web的应用层协议</li><li>客户/服务器模式</li></ul><blockquote><p>HTTP是无状态的</p><p>服务器并不维护关于客户的任何信息</p></blockquote><p><strong>使用TCP</strong></p><ol><li>客户发起一个与服务器的TCP连接（建立套接字）80端口</li><li>服务器接手客户的TCP连接</li><li>在浏览器（HTTP客户端）与Web服务器交换HTTP报文（应用层协议报文）</li><li>TCP连接关闭</li></ol><p><strong>HTTP连接</strong></p><p>分为，非持久HTTP，持久HTTP</p><p>区别就是，持久HTTP多个对象可以在一个TCP连接上传输（HTTP/1.1默认使用持久连接）</p><p>非持久HTTP的 缺点 ，每个对象要2个RTT，操作系统必须为每个TCP连接分配资源。但浏览器通常并行的打开TCP连接，以获取资源。</p><p>持久化HTTP，在服务器发送响应后，保持TCP连接。之后的通信都用这个连接。分为流水和非流水</p><ul><li>流水方式的持久HTTP：HTTP/1.1默认模式，客户端遇到一个引用对象就立即产生一个请求，所有引用对象只花费一个RTT是可能的</li><li>非流水方式的持久HTTP：客户端只能在收到前一个响应后才能发出新的请求，每个引用对象话费一个RTT</li></ul><p><strong>HTTP具体笔记暂未写  后续放连接</strong></p><p><strong>Web缓存（代理服务器）</strong></p><p>不访问原始服务器，就满足客户的请求</p><p>具体实现</p><ol><li>用户设置浏览器：通过缓存访问Web</li><li>浏览器将所有的HTTP请求发给缓存<ul><li>在缓存中的对象：缓存直接返回对象</li><li>若对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端</li></ul></li></ol><p><strong>好处</strong></p><p>降低客户端的请求响应时间，减少一个机构内部网络与Internet接入链路上的流量，使用了缓存之后，较弱的ICP也能够有效提供内容</p><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>文件传输协议，端口号21。向远程服务器传输文件或下载文件</p><p><strong>控制连接与数据连接分开</strong></p><p>有状态的连接。</p><p>一个连接保持控制状态，一个连接进行传输文件。</p><p><strong>FTP返回码样例</strong></p><p>状态码和状态信息（同HTTP）</p><ul><li>331 Username OK, password required</li><li>125 data connection already open; transfer starting</li><li>425 Can’t open data connection</li><li>452 Error writing file</li></ul><h2 id="EMail"><a href="#EMail" class="headerlink" title="EMail"></a>EMail</h2><p>三个主要组成部分</p><ul><li>用户代理<ul><li>又名 邮件阅读器</li><li>输出和输入邮件保存在服务器</li></ul></li><li>邮件服务器<ul><li>邮箱中管理和维护发送给用户的邮件</li><li>输出报文队列保持待发送的报文</li><li>邮件服务器之间的SMTP协议：发送email报文。客户（发送方邮件服务器），服务器（接收端邮件服务器）</li></ul></li><li>简单邮件传输协议：SMTP<ul><li>使用TCP在客户端和服务器之间传送报文，端口为25。直接传输</li><li>三个阶段：握手-》传输报文-》关闭</li><li>命令/响应交互：命令（ASCII文本），响应（状态码和状态信息）</li><li>报文必须七位ASCII码</li><li>服务器使用，CRLF.CRLF决定报文的尾部</li></ul></li></ul><p>多媒体扩展：MIME多媒体邮件扩展</p><p>在报文首部使用额外的行申明MIME内容类型</p><p>SMTP与HTTP比较</p><ul><li><p>HTTP：拉（pull）</p></li><li><p>SMTP：推（push）</p></li><li><p>二者都是ASCII形式的命令/响应交互，状态码</p></li><li><p>HTTP：每个对象封装在各自的响应报文中</p></li><li><p>SMTP：多个对象包含在一个报文中</p></li></ul><p>邮件访问协议</p><p>用户代理<strong><strong>smtp</strong></strong>&gt;发送方邮件服务器<strong><strong>smtp</strong></strong>&gt;接收方邮件服务器____pop3、IMAP、HTTP_______&gt;用户代理</p><p>SMTP：传送到接收方的邮件服务器</p><p>邮件访问协议：从服务器访问邮件</p><ul><li>POP：邮局访问协议，用户身份确认（代理&lt;—&gt;服务器）并下载</li><li>IMAP：Internet邮件访问协议<ul><li>更多特性（更复杂），在服务器上处理存储的报文</li></ul></li><li>HTTP：Hotmail,Yahoo! Mail等<ul><li>方便</li></ul></li></ul><p>POP3（续）与 IMAP</p><p>POP3（续）本地管理文件夹</p><ul><li>下载并删除 模式，看完之后删除，改变了客户机，就不能访问了</li><li>下载并保留 模式，不同客户机上为报文的拷贝</li><li>POP3在会话中是无状态</li></ul><p>IMAP  远程管理文件夹</p><ul><li>IMAP服务器将每个报文与一个文件夹联系起来</li><li>允许用户用目录来组织报文</li><li>允许用户读取报文组件</li><li>IMAP在会话过程中保留用户状态，目录名，报文ID与目录名之间映射</li></ul><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>必要性</p><ul><li>IP地址标识主机，服务器。由于数字不好记，所以就定义一些有意义的字符串来标识Internet上的设备</li><li>存在着“字符串”—-IP地址转换的必要性，由DNS负责转换成为二进制的网络地址</li></ul><h3 id="DNS总体思路和目标"><a href="#DNS总体思路和目标" class="headerlink" title="DNS总体思路和目标"></a>DNS总体思路和目标</h3><p><strong>DNS主要思路</strong></p><ul><li><strong>分层</strong>的，基于域的命名机制</li><li>若干分布式的数据库完成名字到IP地址的转换</li><li>运行在UDP之上端口号为53的<strong>应用</strong>服务</li><li>核心的Internet功能，但以应用层协议实现，在网络边缘处理复杂性</li></ul><p>DNS<strong>主要目的</strong></p><ul><li>实现主机名-IP地址的转黄</li><li>主机别名到规范名字的转换，邮件服务器别名到邮件邮件服务器的正规名字的转换，负载均衡</li></ul><p><strong>DNS域名结构</strong></p><p>DNS采用层次树状结构的命名方法，Internet根被划分为几百个顶级域，分为通用的和国家的。每个子域下面可划分为若干子域，树叶是主机。</p><p>域名的管理</p><p>一个域管理其下的子域(.cn 可以划分为edu.cn  ,   com.cn)，域遵从组织界限，不是物理网络</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210928143223926.png" alt="image-20210928143223926"></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210928143204644.png" alt="image-20210928143204644"></p><p>根服务器下面还有很多其他的二级服务器，二级服务器往下还有下级等</p><p>TLD服务器：负责顶级域名和所有国家级顶级域名</p><p><strong>区域名字服务器维护资源记录</strong></p><p>资源记录：维护域名-ip地址的映射关系</p><p>RR格式（domain_name，ttl，type，class，value）</p><ul><li><p>domain_name:域名</p></li><li><p>TTL: time to live 生存时间（权威，缓冲记录）决定了资源记录应当从缓存中删除的时间</p></li><li><p>Class类别：对于Internet，值为In</p></li><li><p>Value值：可以是数字，域名或ASCII串</p></li><li><p>Type类别：</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210928153000820.png" alt="image-20210928153000820"></p></li></ul><p>DNS大致工作过程</p><p>应用调用解析器（resolver），解析器为客户 向Name Server发出查询报文（封装在UDP），Name Server 返回响应报文</p><p>本地名字服务器（Local Name Server）</p><p>其实并不严格属于层次结构，每个ISP都有一个本地DNS服务器，当一个主机发送DNS查询时，查询被送到DNS服务器。当本地服务器不能解析时，就顺着根-TLD找到权威名字服务器</p><p>有两种查询方法</p><ul><li><p>递归查询：</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210928153710375.png" alt="image-20210928153710375"></p></li><li><p>迭代查询：根服务器返回的不是查询结果，而是下一个DNS的地址，最后由名字服务器给出解析结果</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210928153737545.png" alt="image-20210928153737545"></p></li></ul><h3 id="DNS协议，报文"><a href="#DNS协议，报文" class="headerlink" title="DNS协议，报文"></a>DNS协议，报文</h3><p>DNS协议：查询和响应报文的报文格式相同</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210928153951029.png" alt="image-20210928153951029"></p><ul><li>identification：标识符（ID）16位</li><li>flags：查询/应答，希望递归……</li><li>questions：一个查询的Name，type字段</li><li>answers：对应查询的RR记录</li><li>authority：权威服务器的记录</li><li>additional info：附加的有用信息</li></ul><h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2><p>每一个Peer节点都可以当客户端和服务器。</p><h3 id="P2P文件分发：BitTorrent"><a href="#P2P文件分发：BitTorrent" class="headerlink" title="P2P文件分发：BitTorrent"></a>P2P文件分发：BitTorrent</h3><p>文件被分为一个个块，网络中的这些peers发送接收文件块，相互服务</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210928154612096.png" alt="image-20210928154612096"></p><p>Peer加入torrent：</p><ul><li>一开始没有块，但是将会通过其他节点处积累文件块</li><li>向跟踪服务器注册，获得peer节点列表，和部分peer节点构成邻居关系</li><li>当peer下载时，该peer可以同时向其他节点提供上载服务，peer可能会变换用于交换块的节点。</li><li>一旦一个peer拥有整个文件，他会离开或者保留在torrent中</li></ul><p><strong>请求块</strong></p><ul><li>在任何给定时间，不同peer节点拥有一个文件块的子集</li><li>周期性的，Alice节点向邻居询问它们拥有哪些块的信息。</li><li>Alice向peer节点请求它希望的块，稀缺的块。</li></ul><p><strong>发送块</strong></p><ul><li>Alice向4个peer发送块，这些服务向她提供过最大带宽服务。（其他的peer被Alice阻塞，不会从Alice处获得服务，每10秒评估一个前四位）</li><li>每隔30秒，随机选择其他peer节点，向这个节点发送块。</li><li>谁帮过我，我就优先帮谁（tit-for-tat)</li></ul><h3 id="P2P文件共享"><a href="#P2P文件共享" class="headerlink" title="P2P文件共享"></a>P2P文件共享</h3><p><strong>查询洪泛Gnutella</strong>（协议）</p><ul><li>全分布式，没有中心服务器</li><li>开放文件共享协议</li><li>许多Gnutella客户端实现了Gnutella协议。利用图来覆盖网络</li></ul><p><strong>Gnutella：协议</strong></p><p>在已有的TCP连接上发送查询报文，对等发转发查询报文，如果查到由最终的服务器返回。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210928161023284.png" alt="image-20210928161023284"></p><p><strong>利用不匀称性：KaZaA</strong></p><ul><li>每个对等方要么是一个组长，要么隶属一个组长。对等方与组长之间有TCP连接，组长对之间有TCP连接</li><li>组长跟踪所有的孩子的内容</li><li>组长与其他组长联系。转发查询到其他组长，活的其他组长的数据拷贝。</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210928161211361.png" alt="image-20210928161211361"></p><ol><li>每个文件有一个散列标识码和一个描述符，客户端向其组长发送关键字查询。</li><li>组长用匹配进行响应（元数据，散列标识码，IP地址）</li><li>如果组长将查询发送给其他组长，其他组长以匹配进行响应。</li><li>客户端选择要下载的文件（向拥有文件的对等方发送一个带散列标识符的HTTP请求）</li></ol><h2 id="CDN和视频"><a href="#CDN和视频" class="headerlink" title="CDN和视频"></a>CDN和视频</h2><p>视频编码</p><p>CBR（constant bit rate）：以固定速率编码</p><p>VBR（variable bit rate）：视频编码速率随时间变化而变化</p><h3 id="多媒体流化服务：DASH"><a href="#多媒体流化服务：DASH" class="headerlink" title="多媒体流化服务：DASH"></a>多媒体流化服务：DASH</h3><p>DASH：Dynamic，Adaptive Streaming over HTTP</p><p>服务器：</p><ul><li>将视频文件分隔为多个块</li><li>每个块独立存储，编码于不同码率</li><li>告示文件（manifest file）：提供不同块的URL</li></ul><p>客户端：客户端自适应决定</p><ul><li>先获取告示文件</li><li>周期性的测量服务器到客户端的带宽</li><li>查询告示文件，在一个时刻请求一个块，HTTP头部指定字节范围</li></ul><p>CDN，全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验。两种方式</p><ul><li>enter deep：将CDN服务器深入到许多接入网。更接近用户，数量多。离用户近，管理困难。</li><li>bring home ：部署在少数关键位置。采用租用线路，将服务器连接起来</li></ul><p>CDN：在CDN节点中存储内容的拷贝。用户从CDN请求内容。</p><p>案例Netflix</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210928172552365.png" alt="image-20210928172552365"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-广义表</title>
      <link href="2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
      <url>2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-图-笔记</title>
      <link href="2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE-%E7%AC%94%E8%AE%B0/"/>
      <url>2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>图：表示“多对多”的关系</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210925094453444.png" alt="image-20210925094453444"></p><p>顶点：通常用 V（Vertex）表示顶点集合</p><p>边：通常用E(Edge)表示边的集合</p><ul><li>边是顶点对 :无向边 (a,b)  a——b</li><li>有向边 &lt;a,b&gt; 表示从a指向b的边  （单行线） a—-&gt;b</li></ul><blockquote><p>不考虑重边（例如有向边两个顶点只有一条）和自回路（不会有自己到自己的边）</p></blockquote><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>利用<strong>邻接矩阵</strong>，来用一维数组存储图，就可以只用存储红色的部分。</p><p>在下面的图里，我们要找的是3列6行的元素。在数组中对应的下标为</p><p>(i * ( i + 2 ) ) / 2 + j ) </p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210925134051486.png" alt="image-20210925134051486"></p><p>邻接矩阵的优点</p><ol><li>直观，简单，方便检查任意一对顶点间是否存在边</li><li>方便找任一顶点的所有“邻接点”（有边直接相连的顶点）</li><li>方便计算任一节点的 “度” （从该点出发的边数为“出度”，指向该点的边数为“入度”<ul><li>无向图：对应行（列）的非0元素的个数</li><li>有向图：对应行非0元素的个数是“出度”，对应列非0元素的个数是“入度”</li></ul></li></ol><p><strong>缺点</strong></p><ul><li>浪费空间—存储稀疏的时候，有大量无效元素，但是如果稠密的话，就不会有这个问题</li><li>浪费时间—统计稀疏图中一共有多少边</li></ul><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>G[n]为指针数组，对应矩阵每行一个链表，存非零元素</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210925135626928.png" alt="image-20210925135626928"></p><p>方便找任一顶点所有的“邻接点”</p><p>节约稀疏图的空间</p><p>无向图：方便计算度</p><p>有向图：只能计算“出度”，入度需要构造“逆邻接表”来计算入度</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先搜索（Depth-First-Search，DFS）"><a href="#深度优先搜索（Depth-First-Search，DFS）" class="headerlink" title="深度优先搜索（Depth First Search，DFS）"></a>深度优先搜索（Depth First Search，DFS）</h3><p><strong>时间复杂度</strong>(N为顶点个数，E为边的个数)</p><ul><li>用邻接表存储图，有o(N+E)</li><li>用邻接矩阵存储图，有O(N^2)</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210925142830720.png" alt="image-20210925142830720"></p><p>从白方块那里设为入口，设为黄色，在视野内有三个节点没走过。走其中一个节点那边去，也设为黄色。以此类推，走到视野中没有没去过的节点，一个一个原路返回，看看还有没有没走过的节点。有就继续进入。直到回到初始位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 邻接表存储的图 - DFS */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">( Vertex V )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在访问顶点%d\n&quot;</span>, V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Visited[]为全局变量，已经初始化为false */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">( LGraph Graph, Vertex V, <span class="keyword">void</span> (*Visit)(Vertex) )</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 以V为出发点对邻接表存储的图Graph进行DFS搜索 */</span></span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    </span><br><span class="line">    Visit( V ); <span class="comment">/* 访问第V个顶点 */</span></span><br><span class="line">    Visited[V] = <span class="literal">true</span>; <span class="comment">/* 标记V已访问 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) <span class="comment">/* 对V的每个邻接点W-&gt;AdjV */</span></span><br><span class="line">        <span class="keyword">if</span> ( !Visited[W-&gt;AdjV] )    <span class="comment">/* 若W-&gt;AdjV未被访问 */</span></span><br><span class="line">            DFS( Graph, W-&gt;AdjV, Visit );    <span class="comment">/* 则递归访问之 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先搜索（Breadth-First-Search，BFS）"><a href="#广度优先搜索（Breadth-First-Search，BFS）" class="headerlink" title="广度优先搜索（Breadth First Search，BFS）"></a>广度优先搜索（Breadth First Search，BFS）</h3><p><strong>时间复杂度</strong>(N为顶点个数，E为边的个数)</p><ul><li>用邻接表存储图，有O(N+E)</li><li>用邻接矩阵存储图，有O(N^2)</li></ul><p>这是遍历的图，并非是图的存储结构</p><p>中心节点进入队列进行标示，然后出队，查看他的其他几条边，把几个顶点都入队并且标示，然后依次出队，重复操作。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210925143834719.png" alt="image-20210925143834719"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 邻接矩阵存储的图 - BFS */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* IsEdge(Graph, V, W)检查&lt;V, W&gt;是否图Graph中的一条边，即W是否V的邻接点。  */</span></span><br><span class="line"><span class="comment">/* 此函数根据图的不同类型要做不同的实现，关键取决于对不存在的边的表示方法。*/</span></span><br><span class="line"><span class="comment">/* 例如对有权图, 如果不存在的边被初始化为INFINITY, 则函数实现如下:         */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEdge</span><span class="params">( MGraph Graph, Vertex V, Vertex W )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Graph-&gt;G[V][W]&lt;INFINITY ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Visited[]为全局变量，已经初始化为false */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span> <span class="params">( MGraph Graph, Vertex S, <span class="keyword">void</span> (*Visit)(Vertex) )</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索 */</span></span><br><span class="line">    Queue Q;     </span><br><span class="line">    Vertex V, W;</span><br><span class="line"></span><br><span class="line">    Q = CreateQueue( MaxSize ); <span class="comment">/* 创建空队列, MaxSize为外部定义的常数 */</span></span><br><span class="line">    <span class="comment">/* 访问顶点S：此处可根据具体访问需要改写 */</span></span><br><span class="line">    Visit( S );</span><br><span class="line">    Visited[S] = <span class="literal">true</span>; <span class="comment">/* 标记S已访问 */</span></span><br><span class="line">    AddQ(Q, S); <span class="comment">/* S入队列 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( !IsEmpty(Q) ) &#123;</span><br><span class="line">        V = DeleteQ(Q);  <span class="comment">/* 弹出V */</span></span><br><span class="line">        <span class="keyword">for</span>( W=<span class="number">0</span>; W&lt;Graph-&gt;Nv; W++ ) <span class="comment">/* 对图中的每个顶点W */</span></span><br><span class="line">            <span class="comment">/* 若W是V的邻接点并且未访问过 */</span></span><br><span class="line">            <span class="keyword">if</span> ( !Visited[W] &amp;&amp; IsEdge(Graph, V, W) ) &#123;</span><br><span class="line">                <span class="comment">/* 访问顶点W */</span></span><br><span class="line">                Visit( W );</span><br><span class="line">                Visited[W] = <span class="literal">true</span>; <span class="comment">/* 标记W已访问 */</span></span><br><span class="line">                AddQ(Q, W); <span class="comment">/* W入队列 */</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="comment">/* while结束*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图不连通的情况"><a href="#图不连通的情况" class="headerlink" title="图不连通的情况"></a>图不连通的情况</h3><p><strong>连通</strong>：如果v到w存在一条（无向）<strong>路径</strong>，则称v和w连通。</p><p><strong>路径</strong>：v到w的路径是一系列的顶点（v，v1，v2，v3…..vn，w)的集合。其中任一对相邻的顶点间都有图中的边。<strong>路径的长度</strong>是路径中的边数。如果v到w之间的所有顶点都不同，称为<strong>简单路径</strong>。非简单路径就是有回路的。</p><p><strong>回路</strong>：起点等于终点的路径</p><p><strong>连通图</strong>：图中任意两顶点均连通</p><h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><p><strong>连通分量</strong>：无向图的<strong>极大</strong>连通子图</p><ul><li>极大顶点数：再加1个顶点就不连通了</li><li>极大边数：包含子图中所有顶点相连的所有边</li><li>例</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210925145633349.png" alt="image-20210925145633349"></p><h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><p><strong>强连通：</strong>有向图中顶点v和w之间存在双向路径，则称v和w是强连通的</p><p><strong>强连通图：</strong>有向图中任意两顶点均强连通</p><p><strong>强连通分量：</strong>有向图的极大强连通子图</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210925145925936.png" alt="image-20210925145925936"></p><p>这里后面两个图都是强连通图。</p><p>代码实现</p><p>原理：遍历DFS，然后图不连通的部分，因为这个程序会遍历图，所以不存在遍历不到的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">ListComponents</span>(<span class="params">Graph G</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(each V <span class="keyword">in</span> G)&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">DFS(V); <span class="comment">/*or BFS(V)*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="邻接矩阵-1"><a href="#邻接矩阵-1" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p><strong>数据类型 - 图 - 边</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode MGraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> *<span class="title">PtrToENode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToENode Edge;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;<span class="comment">//顶点数</span></span><br><span class="line">    <span class="keyword">int</span> Ne;<span class="comment">//边数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> G[MaxVertexNum][MaxVertexNum]; <span class="comment">//描述边</span></span><br><span class="line">    <span class="keyword">char</span> data[MaxVertexNum];  <span class="comment">//数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>&#123;</span></span><br><span class="line">    Vertex V1,V2;</span><br><span class="line">    <span class="keyword">int</span> Weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>数据类型 - 方法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图初始化</span></span><br><span class="line"><span class="function">MGraph <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> VertexNum)</span></span>&#123;</span><br><span class="line">    Vertex V,W;</span><br><span class="line">    MGraph Graph;</span><br><span class="line"></span><br><span class="line">    Graph = (MGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认从0开始</span></span><br><span class="line">    <span class="keyword">for</span>(V=<span class="number">0</span>; V&lt;Graph-&gt;Nv;V++)&#123;</span><br><span class="line">        <span class="keyword">for</span> ( W = <span class="number">0</span>; W &lt; Graph-&gt;Nv; W++)</span><br><span class="line">        &#123;</span><br><span class="line">            Graph-&gt;G[V][W] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向MGraph插入边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(MGraph Graph,Edge e)</span></span>&#123;</span><br><span class="line">    Graph-&gt;G[e-&gt;V1][e-&gt;V2]=e-&gt;Weight;</span><br><span class="line">    Graph-&gt;G[e-&gt;V2][e-&gt;V1]=e-&gt;Weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完整的建立图</span></span><br><span class="line"><span class="function">MGraph <span class="title">BuildGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    <span class="keyword">int</span> Nv,i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数 &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Nv);</span><br><span class="line">    Graph = CreateGraph(Nv);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入边的数量 &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Graph-&gt;Ne);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Graph-&gt;Ne!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        E = (Edge)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; Graph-&gt;Ne; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入边的V1,V2,Weight &quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight);</span><br><span class="line">            InsertEdge(Graph,E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( V = <span class="number">0</span>; V &lt; Graph-&gt;Nv; V++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入数据 &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c &quot;</span>,&amp;Graph-&gt;data[V]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻接表-1"><a href="#邻接表-1" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表有向图，因为无向图实现需要另起一个。所以就有向图进行实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Vertex data;</span><br><span class="line">    Edge next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Edge next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> <span class="title">AdjList</span>[<span class="title">MaxVertexNum</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjMatrix</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AdjMatrix</span>&#123;</span></span><br><span class="line">    AdjList adjList;</span><br><span class="line">    <span class="keyword">int</span> Nv,Ne;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode Graph;</span><br><span class="line"></span><br><span class="line"><span class="function">Graph <span class="title">createGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Graph G;</span><br><span class="line">    Edge edge;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    G = (Graph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AdjMatrix));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;顶点数nv 边数Ne &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;G-&gt;Nv,&amp;G-&gt;Ne);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; G-&gt;Nv; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顶点数据&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;data);</span><br><span class="line">        G-&gt;adjList[i].data=data;</span><br><span class="line">        G-&gt;adjList[i].next=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;边&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; G-&gt;Ne; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp,EdgeData;</span><br><span class="line">        <span class="comment">//顶点加入边</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入的边&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入的边数据&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;EdgeData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//头插入</span></span><br><span class="line">        edge = (Edge*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Edge));</span><br><span class="line">        edge-&gt;data=EdgeData;</span><br><span class="line"></span><br><span class="line">        edge-&gt;next=G-&gt;adjList[temp].next;</span><br><span class="line">        G-&gt;adjList[temp].next=edge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Graph G = createGraph();</span><br><span class="line">    <span class="comment">//未写遍历</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(自顶向下)第一章</title>
      <link href="2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>Internet从具体构成角度</p><ul><li><p>节点</p><ul><li>主机及其运行的应用程序</li><li>路由器，交换机等网络交换设备</li></ul></li><li><p>边，通信链路</p><ul><li>接入网链路，主机链接到互联网的链路</li><li>主干链路，路由器间的链路</li></ul></li><li><p>协议</p></li></ul><p><strong>网络结构</strong></p><ul><li>网络边缘<ul><li>主机</li><li>应用程序（客户端和服务器）</li></ul></li><li>网络核心<ul><li>互联着的路由器</li><li>网络的网络</li></ul></li><li>接入网，物理媒体<ul><li>有线或者无线通信链路</li></ul></li></ul><h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a><strong>网络边缘</strong></h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210923130211740.png" alt="image-20210923130211740"></p><ul><li>端系统（主机）<ul><li>运行应用程序</li></ul></li><li>C/S 模式<ul><li>客户端向服务器请求，接收服务</li></ul></li><li>对等（peer-peer）模式</li></ul><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a><strong>网络核心</strong></h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210923130236308.png" alt="image-20210923130236308"></p><p>路由器的网状网络</p><p>数据传输</p><ul><li><p><strong>电路交换</strong>：给每个呼叫预留一条专用网络。不共享资源。如果呼叫没有发送数据，分配的线路就会空闲被浪费。</p><p><strong>缺点</strong>：连接建立时间长，计算机之间的通信并不是一直在通信，可靠性不高</p><p>网络资源被分成<strong>片</strong>，为呼叫分配片。将带宽分成片。</p><ul><li><p>频分（Frequency-division multiplexing）</p></li><li><p>时分（Time-division multiplexing）</p></li><li><p>波分（Wave-division multiplexing）</p></li><li><p>例，下面就是FDM TDM的电路交换网。FDM频分，TDM时分。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210923130312349.png" alt="image-20210923130312349"></p></li></ul></li><li><p>分组交换：</p><p>以分组为单位存储-转发，资源共享，按需使用</p><p>网络带宽全部使用。不进行分片。传输的数据分为一个一个分组。分组在一个个路由器中存储-转发，分组每次移动一跳（hop）。</p><ul><li>转发之前，节点必须收到整个分组</li><li>延迟比线路交换更大</li><li>排队时间</li></ul><p>按照有无网络连接，分为</p><ul><li><p>数据报网络：分组的目标地址决定下一跳，在不同的阶段，路由可以改变。类似问路</p></li><li><p>虚电路网络：每个分组都带标签，标签决定下一跳，在呼叫建立时决定路径，在整个呼叫中路径保持不变，路由器维持每个呼叫的状态信息</p></li></ul></li></ul><p>  排队和延迟</p><p>  如果到达速率 &gt; 链路的输出速率，分组就会进行排队，如果路由器中缓存用完，分组会被抛弃。</p><p>  <img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210923131413170.png" alt="image-20210923131413170"></p><p><strong>网络核心关键功能</strong></p><p>路由：决定分组采用的源到目标的路径</p><p>转发：将分组从路由器的输入链路转移到输出链路</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210923183733149.png" alt="image-20210923183733149"></p><h3 id="接入网和物理媒体"><a href="#接入网和物理媒体" class="headerlink" title="接入网和物理媒体"></a><strong>接入网和物理媒体</strong></h3><ul><li>住宅接入网络 modem</li><li>单位接入网络（学校，公司）</li><li>无线接入网络</li></ul><p><strong>物理媒体</strong></p><p>Bit：在发送-接收对间传播</p><p>物理链路：连接每个发送-接收对之间的物理媒体</p><ul><li>导引型媒体：信号沿着固体媒介被引导：同轴电缆，光纤，双绞线</li><li>非导引型媒体：开放的空间传输电磁波或者光信号，在电磁或者光信号中承载数字数据</li></ul><h3 id="Internet结构和ISP"><a href="#Internet结构和ISP" class="headerlink" title="Internet结构和ISP"></a>Internet结构和ISP</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210923192647785.png" alt="image-20210923192647785"></p><p>IXP是内容提供商，如谷歌，微软在全球架构服务器。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210923192738024.png" alt="image-20210923192738024"></p><h3 id="分组延时，丢失和吞吐量"><a href="#分组延时，丢失和吞吐量" class="headerlink" title="分组延时，丢失和吞吐量"></a>分组延时，丢失和吞吐量</h3><p>四种分组延时</p><ol><li><p>节点处理延时</p><ul><li>检查bit级差错，检查分组首部和决定将分组导向何处</li></ul></li><li><p><strong>排队延时</strong></p><ul><li>在输出链路上等待传输的时间，依赖于路由器的拥塞程度</li><li>R=链路带宽  L=分组长度(bits)   a=分组到达队列的平均速率   流量强度= La/R<ul><li>La/R ~ 0 :平均排队延时很小</li><li>La/R -&gt; 1: 延时变的很大</li><li>La/R &gt; 1:比特到达队列的速率超过了从该队列输出的速率，平均排队延时趋向于无穷大</li></ul></li></ul></li><li><p>传输延时</p><ul><li><p>R=链路带宽(bps)  L=分组长度(bits) 将分组发送到链路上的时间=L/R</p></li><li><p>节点通过路由器所花的时间</p></li></ul></li><li><p>传播延时</p><ul><li><p>d=物理链路的长度   s=在媒体上的传播速度   传播延时=d/s</p></li><li><p>节点从这个路由器到下个路由器的传播时间</p></li></ul></li></ol><p><strong>分组丢失</strong></p><p>链路的队列缓冲区有限，当分组到达一个满的队列时，该分组将会丢失。丢失的分组可能会被前一个节点或源端重传，或者根本不重传。</p><p><strong>吞吐量</strong></p><p>在源端和目标端直接传输的速率（数据量/单位时间）</p><ul><li>瞬间吞吐量：在一个时间点的速率</li><li>平均吞吐量：在一个长时间内的平均值</li></ul><p>端到端的路径中，根据水桶原理，是最小的带宽决定的。</p><h3 id="协议层次及服务模型"><a href="#协议层次及服务模型" class="headerlink" title="协议层次及服务模型"></a>协议层次及服务模型</h3><ul><li>服务（service）：低层实体向上层实体提供它们之间的通信的能力。分为面向连接的服务和无连接的服务<ul><li>服务用户（Service User)</li><li>服务提供者（Service provider）</li></ul></li><li>原语（primitive）：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互</li><li>服务访问点SAP（Service Acess Point）：上层使用下层的服务通过层间的接口</li></ul><p>服务和协议的区别</p><ul><li>服务：低层实体向上层实体提供它们直接通信的能力，是通过原语来操作的。垂直</li><li>协议：对等层实体之间在相互通信的过程中，需要遵循的规则的集合。水平。</li></ul><p>它们直接的联系</p><ul><li>本层协议的实现要靠下层提供服务来实现</li><li>本层实体通过协议为上层提供更高级的服务</li></ul><h4 id="Internet协议栈"><a href="#Internet协议栈" class="headerlink" title="Internet协议栈"></a>Internet协议栈</h4><ul><li>应用层 <strong>报文（message）</strong>：网络应用<ul><li>为人类用户或其他应用进程提供网络应用服务</li><li>FTP，SMTP，HTTP，DNS</li></ul></li><li>传输层 <strong>报文段（segment）Tcp段，UDP数据报</strong>：主机之间的数据传输<ul><li>在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠的通信变为可靠的通信</li><li>TCP,UDP</li></ul></li><li>网络层 <strong>分组packet（如果无连接方式，：数据报datagram）</strong>：为数据报从源到目的选择路由<ul><li>主机之间的通信，端到端通信，不可靠</li><li>IP，路由协议</li></ul></li><li>链路层 <strong>帧（frame）</strong>：相邻网络节点间的数据传输<ul><li>2个相邻2点的通信，点到点通信，可靠或不可靠</li><li>点对点协议PPP，802.11（wifi），Ethernet</li></ul></li><li>物理层 <strong>位（bit）</strong>：在线路上传送bit</li></ul><p><strong>ISO/OSI参考模型</strong></p><p>表示层，会话层，在应用层和传输层中间。互联网协议栈没有这两层。</p><ul><li>表示层：允许应用解释传输的数据。e.g，加密，压缩，机器相关的表示转换</li><li>会话层：数据交换的同步，检查点，恢复</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210923200155311.png" alt="封装和解封装"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-树-笔记</title>
      <link href="2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E7%AC%94%E8%AE%B0/"/>
      <url>2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>基本术语</p><ol><li><strong>结点的度</strong>（Degree）：结点的<strong>子树个数</strong></li><li><strong>树的度</strong>：树的所有节点中最大的度数</li><li><strong>叶结点</strong>（Leaf）：<strong>度为0</strong>的节点</li><li><strong>父结点</strong>（Parent）：若一个节点含有子结点，则这个节点称为其节点的父节点</li><li><strong>子结点</strong>（Child）：若A结点是B节点的父结点，则B节点是A节点的子结点，也称孩子节点</li><li><strong>兄弟节点</strong>（Sibling）：具有同一父结点的各结点彼此是兄弟结点</li><li><strong>路径和路径长度</strong>：从结点N1到Nk的路径为一个节点序列，节点的个数为路径的长度</li><li><strong>祖先节点</strong>（Ancestor）：沿树根到某一节点路径上所有节点都是这个节点的祖先节点</li><li><strong>子孙节点</strong>（Descendant）：某一节点的子树中的所有节点是这个节点的子孙</li><li><strong>节点的层次</strong>（Level）：规定根节点在1层</li><li><strong>树的深度</strong>（Depth）：树中所有结点中的最大层次是这棵树的深度</li></ol><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>特殊二叉树</strong></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210902145632268.png" alt="image-20210902145632268"></p><p><strong>重要性质</strong></p><ul><li>一个二叉树第 i 层 的最大结点数为：2^(i-1) , i&gt;=1</li><li>深度为k的二叉树有最大结点总数为：2^k-1,k&gt;=1</li><li>对任何非空二叉树T，若n0表示叶结点的个数，n2是度为2的非叶结点个数，那么两者关系满足 n0=n2+1</li></ul><p><strong>遍历方法</strong></p><ol><li>先序——根，左子树，右子树</li><li>中序——左子树，根，右子树</li><li>后序—–左子树，右子树，根</li><li>层次遍历—从上到下，从左到右（一层一层的遍历，从左到右）</li></ol><h4 id="代码实现-递归-全部代码"><a href="#代码实现-递归-全部代码" class="headerlink" title="代码实现-递归-全部代码"></a>代码实现-递归-全部代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">createTree</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    Tree t;</span><br><span class="line">    <span class="comment">//分配堆栈空间</span></span><br><span class="line">    t=(Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TNode));</span><br><span class="line">    t-&gt;Data = value;</span><br><span class="line">    t-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTraversalRecursion</span><span class="params">(Tree t)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 先序遍历 递归 根 左 右</span></span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">        PreTraversalRecursion(t-&gt;Left);</span><br><span class="line">        PreTraversalRecursion(t-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiddleTraversalRecursion</span><span class="params">(Tree t)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 中序遍历 递归，左 根 右</span></span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        MiddleTraversalRecursion(t-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">        MiddleTraversalRecursion(t-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostTraversalRecursion</span><span class="params">(Tree t)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 后序遍历 递归，左 右 根</span></span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostTraversalRecursion(t-&gt;Left);</span><br><span class="line">        PostTraversalRecursion(t-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(Tree t,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 0 已有，1插入成功</span></span><br><span class="line">    <span class="keyword">if</span>(t-&gt;Data == data)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前节点数据已有&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;Data &gt; data)&#123;</span><br><span class="line">        <span class="comment">// 进左</span></span><br><span class="line">        <span class="comment">// printf(&quot;数据小于当前节点\n t.data = %d&quot;,t-&gt;Data);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;左\n&quot;);</span></span><br><span class="line">            judgeDataExistAndPosition(t-&gt;Left,data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Tree temp;</span><br><span class="line">            temp = createTree(data);</span><br><span class="line">            t-&gt;Left = temp;</span><br><span class="line">            <span class="comment">// free(temp);</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d进左\n&quot;</span>,t-&gt;Left-&gt;Data);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;Data &lt; data)&#123;</span><br><span class="line">        <span class="comment">// 进右</span></span><br><span class="line">        <span class="comment">// printf(&quot;\n数据大于当前节点\n t.data = %d&quot;,t-&gt;Data);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;右&quot;);</span></span><br><span class="line">            judgeDataExistAndPosition(t-&gt;Right,data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Tree temp;</span><br><span class="line">            temp = createTree(data);</span><br><span class="line">            t-&gt;Right = temp;</span><br><span class="line">            <span class="comment">// free(temp);</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d进右\n&quot;</span>,t-&gt;Right-&gt;Data);</span><br><span class="line">            <span class="comment">// t-&gt;Data = data;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Tree t = createTree(<span class="number">4</span>);</span><br><span class="line">    add(t,<span class="number">5</span>);</span><br><span class="line">    add(t,<span class="number">2</span>);</span><br><span class="line">    add(t,<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    PostTraversalRecursion(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码实现-非递归-全部代码"><a href="#代码实现-非递归-全部代码" class="headerlink" title="代码实现-非递归-全部代码"></a>代码实现-非递归-全部代码</h4><p>放上了堆栈的代码，所以看起来有点多。其中后序与中序先序不同。用了不一样的方法。</p><p>具体思路是。先入栈，到最左边之后判断右子树，遍历完全部右子树之后。再进行出栈。也就是说第一次回退不是出栈，只是取栈顶元素。等右子树判断之后再进行出栈操作。</p><ol><li>对当前节点判断是否存在左子树，存在压入栈中。置flag为1，表示判断过一次左子树。</li><li>当当前节点不存在，需要出栈了。分为两种情况，<ul><li>一种是flag=1时，是左子树到顶，取栈顶元素，我们设置flag为2，且进入右子树。</li><li>一种是flag=2时，右子树到顶，需要出栈。打印并出栈</li></ul></li></ol><p>即可解决后序非递归二叉树遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArrayStack</span> *<span class="title">Stack</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArrayStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Tree *data;</span><br><span class="line">    Position top;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">createStack</span><span class="params">(<span class="keyword">int</span> maxsize)</span></span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    <span class="comment">// 分配 堆栈和数据的空间</span></span><br><span class="line">    s=(Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ArrayStack));</span><br><span class="line">    s-&gt;data=(Tree *)<span class="built_in">malloc</span>(maxsize*<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    </span><br><span class="line">    s-&gt;top=<span class="number">-1</span>;</span><br><span class="line">    s-&gt;MaxSize=maxsize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isFull</span><span class="params">(Stack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s-&gt;top==s-&gt;MaxSize<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(Stack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s-&gt;top==<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">push</span><span class="params">(Stack s,Tree data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isFull(s))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s-&gt;data[++(s-&gt;top)]=data;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">pop</span><span class="params">(Stack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s-&gt;data[(s-&gt;top--)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">getNode</span><span class="params">(Stack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">createTree</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    Tree t;</span><br><span class="line">    <span class="comment">//分配堆栈空间</span></span><br><span class="line">    t=(Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TNode));</span><br><span class="line">    t-&gt;Data = value;</span><br><span class="line">    t-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(Tree bt)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;先序遍历&quot;</span>);</span><br><span class="line">    Tree t = bt;</span><br><span class="line">    Stack s = createStack(Maxsize);</span><br><span class="line">    <span class="keyword">while</span>(t || !isEmpty(s))&#123;</span><br><span class="line">        <span class="keyword">while</span>(t)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">            push(s,t);</span><br><span class="line">            t = t-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isEmpty(s))&#123;</span><br><span class="line">            t = pop(s);</span><br><span class="line">            t = t-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiddleOrderTraversal</span><span class="params">(Tree bt)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">    Tree t = bt;</span><br><span class="line">    <span class="comment">// 非递归中序遍历   使用堆栈</span></span><br><span class="line">    Stack s = createStack(Maxsize);</span><br><span class="line">    <span class="keyword">while</span>(t || !isEmpty(s))&#123;</span><br><span class="line">        <span class="keyword">while</span> (t)</span><br><span class="line">        &#123;</span><br><span class="line">            push(s,t);</span><br><span class="line">            t=t-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isEmpty(s))&#123;</span><br><span class="line">            t = pop(s);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">            t = t-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(Tree bt)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;后序遍历&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> flagTag[Maxsize];</span><br><span class="line">    Tree t = bt;</span><br><span class="line">    <span class="comment">// 非递归后序遍历   使用堆栈</span></span><br><span class="line">    Stack s = createStack(Maxsize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t || !isEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            push(s,t);</span><br><span class="line">            flagTag[s-&gt;top]=<span class="number">1</span>;</span><br><span class="line">            t=t-&gt;Left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(flagTag[s-&gt;top]==<span class="number">1</span>)&#123;</span><br><span class="line">                t = getNode(s);</span><br><span class="line">                flagTag[s-&gt;top]=<span class="number">2</span>;</span><br><span class="line">                t = t-&gt;Right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t = pop(s);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;Data);</span><br><span class="line">                t = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(Tree t,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 0 已有，1插入成功</span></span><br><span class="line">    <span class="keyword">if</span>(t-&gt;Data == data)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前节点数据已有&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;Data &gt; data)&#123;</span><br><span class="line">        <span class="comment">// 进左</span></span><br><span class="line">        <span class="comment">// printf(&quot;数据小于当前节点\n t.data = %d&quot;,t-&gt;Data);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;左\n&quot;);</span></span><br><span class="line">            add(t-&gt;Left,data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Tree temp;</span><br><span class="line">            temp = createTree(data);</span><br><span class="line">            t-&gt;Left = temp;</span><br><span class="line">            <span class="comment">// free(temp);</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d进左\n&quot;</span>,t-&gt;Left-&gt;Data);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;Data &lt; data)&#123;</span><br><span class="line">        <span class="comment">// 进右</span></span><br><span class="line">        <span class="comment">// printf(&quot;\n数据大于当前节点\n t.data = %d&quot;,t-&gt;Data);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;右&quot;);</span></span><br><span class="line">            add(t-&gt;Right,data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Tree temp;</span><br><span class="line">            temp = createTree(data);</span><br><span class="line">            t-&gt;Right = temp;</span><br><span class="line">            <span class="comment">// free(temp);</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d进右\n&quot;</span>,t-&gt;Right-&gt;Data);</span><br><span class="line">            <span class="comment">// t-&gt;Data = data;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Tree t = createTree(<span class="number">10</span>);</span><br><span class="line">    add(t,<span class="number">11</span>);</span><br><span class="line">    add(t,<span class="number">4</span>);</span><br><span class="line">    add(t,<span class="number">3</span>);</span><br><span class="line">    add(t,<span class="number">5</span>);</span><br><span class="line">    add(t,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    PostOrderTraversal(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>思路：根节点入队</p><ol><li>从队列里面取出元素，访问其左右节点。</li><li>将左右节点入队。输出队列拿出来的节点。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">(Tree bt)</span></span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    Tree t;</span><br><span class="line">    <span class="keyword">if</span>(!bt)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Q = createQueue(Maxsize);</span><br><span class="line">    AddQ(q,bt);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        T = DeleteQ(Q); <span class="comment">//取出队列中的节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Left) AddQ(Q,t-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Right) AddQ(Q,t-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树（BST-Binary-Search-Tree"><a href="#二叉搜索树（BST-Binary-Search-Tree" class="headerlink" title="二叉搜索树（BST, Binary Search Tree)"></a>二叉搜索树（BST, Binary Search Tree)</h4><p>也称二叉排序树，二叉查找树。两个条件</p><ul><li>非空左子树比父结点以及根节点小</li><li>非空右子树比父结点和根节点大</li></ul><h5 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h5><p>从根节点开始，树为空返回NULL。树非空则将节点与需要查找的字段左比较。</p><ul><li>如果相等，返回此节点指针</li><li>如果小于当前节点，则进入左子树</li><li>如果大于当前节点，则进入右子树</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法</span></span><br><span class="line"><span class="function">Tree <span class="title">Find</span><span class="params">(<span class="keyword">char</span> data,Tree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>( data &gt; BST-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> Find(data,BST-&gt;Right);<span class="comment">//进入右子树查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data &lt; BST-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> Find(data,BST-&gt;Left);<span class="comment">//进入左子树查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BST;<span class="comment">//查找成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归算法</span></span><br><span class="line"><span class="function">Tree <span class="title">Find</span><span class="params">(<span class="keyword">char</span> data,Tree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(BST)&#123;</span><br><span class="line">        <span class="keyword">if</span>(data &gt; BST-&gt;data)</span><br><span class="line">            BST=BST-&gt;Right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data &lt; BST-&gt;Left)</span><br><span class="line">            BST=BST-&gt;Left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> BST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找最大元素最小元素</span></span><br><span class="line"><span class="comment">//最小-只查找左子树，向最左边查找</span></span><br><span class="line"><span class="function">Tree <span class="title">FindMin</span><span class="params">(Tree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Left)</span><br><span class="line">        <span class="keyword">return</span> BST;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> FindMin(BST-&gt;Left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最大-只查找右子树，向最右边查找</span></span><br><span class="line"><span class="function">Tree <span class="title">FindMax</span><span class="params">(Tree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST)</span><br><span class="line">        <span class="keyword">while</span>(BST-&gt;Right) BST=BST-&gt;Right;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二叉搜索树插入与删除"><a href="#二叉搜索树插入与删除" class="headerlink" title="二叉搜索树插入与删除"></a>二叉搜索树插入与删除</h5><p>插入操作在上面二叉树的代码中，add就已经实现了。这里不进行实现</p><p>删除分多种情况</p><ol><li>删除叶结点，直接进行删除。将其父结点指针变成NULL</li><li>删除有一个孩子节点，将其父结点指向孩子节点</li><li>删除的节点有两个孩子节点，用左子树的最大元素，或者右子树的最小元素。代替此节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function">Tree <span class="title">Delete</span><span class="params">(<span class="keyword">char</span> data,Tree BST)</span></span>&#123;</span><br><span class="line">    Position Tmp;</span><br><span class="line">    <span class="keyword">if</span>(BST==<span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;要删除的元素未找到&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data &lt; BST-&gt;data)</span><br><span class="line">        BST-&gt;Left = Delete(data,BST-&gt;Left);<span class="comment">//左子树递归</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data &gt; BST-&gt;data)</span><br><span class="line">        BST-&gt;Right = Delete(data,BST-&gt;Right);<span class="comment">//右子树递归</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//找到删除的节点</span></span><br><span class="line">    <span class="keyword">if</span>(BST-&gt;Left &amp;&amp; BST-&gt;Right)&#123;</span><br><span class="line">            <span class="comment">//有一个节点或没有节点</span></span><br><span class="line">            Tmp = FindMin(BST-&gt;Right);</span><br><span class="line">            BST-&gt;data = Tmp-&gt;data;</span><br><span class="line">            BST-&gt;Right = Delete(BST-&gt;data,BST-&gt;Right);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//有两个节点</span></span><br><span class="line">            Tmp=BST;</span><br><span class="line">            <span class="keyword">if</span>(!BST-&gt;Left)</span><br><span class="line">                BST =BST-&gt;Right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Right)</span><br><span class="line">                BST=BST-&gt;Right;</span><br><span class="line">            <span class="built_in">free</span>(Tmp);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树-AVL树"></a>平衡二叉树-AVL树</h4><p><strong>平衡因子（BalanceFactor，BF)</strong>: BF(T) = h(l)-h(r)</p><p>平衡二叉树：空树，或者任一结点左，右子树的高度差绝对值不超过1，|BF(T)|&lt;=1。</p><p><strong>RR旋转</strong></p><p>因为是破坏了右子树的右子树，所以是RR。LL类似</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210921113634245.png" alt="image-20210921113634245"></p><p><strong>LR-RL</strong></p><p>其中 Jan破坏的是先左，后右。用红线标出来了。所以应该是将Mar，Aug，May取中间数，当做其根节点。进行旋转。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210921113904653.png" alt="image-20210921113904653"></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><blockquote><p><strong>优先队列</strong>（Priority Queue)：特殊的“队列”，取出元素的顺序是依照元素的<strong>优先权（关键字）</strong>大小，而不是元素进入队列的先后顺序</p></blockquote><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210921131806349.png" alt="image-20210921131806349"></p><p>两个特性</p><p>结构性：用数组表示的完全二叉树</p><p>有序性：任意借点的关键字是其子树节点的最大值或最小值。</p><ul><li>最大堆，也称大顶堆，最大值</li><li>最小堆，小顶堆，最小值</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210921132003686.png" alt="image-20210921132003686"></p><h4 id="最大堆创建"><a href="#最大堆创建" class="headerlink" title="最大堆创建"></a>最大堆创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大堆创建</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">MaxHeap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>&#123;</span></span><br><span class="line">    ElementType *Elements;<span class="comment">//存储的堆元素</span></span><br><span class="line">    <span class="keyword">int</span> size;<span class="comment">//当前堆大小</span></span><br><span class="line">    <span class="keyword">int</span> Capacity;<span class="comment">//堆的总大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MaxHeap <span class="title">Create</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>&#123;</span><br><span class="line">    MaxHeap H = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*struct HeapStruct));</span><br><span class="line">    H-&gt;Elements = <span class="built_in">malloc</span>((Maxsize+<span class="number">1</span>) * <span class="keyword">sizeof</span>(ElementType));<span class="comment">//这里+1是因为数组是从1开始的下标，0位置是存的哨兵</span></span><br><span class="line">    H-&gt;size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;Capacity = Maxsize;</span><br><span class="line">    H-&gt;Elements[<span class="number">0</span>] = MaxData;<span class="comment">//这里MaxData是自己设置的哨兵，定为所有元素中可能最大的值</span></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处哨兵的作用是，定义一个可能最大的值，防止后面调整位置的时候，会判断0位置，少做一次判断。</p><h4 id="最大堆插入"><a href="#最大堆插入" class="headerlink" title="最大堆插入"></a>最大堆插入</h4><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210921132625064.png" alt="image-20210921132625064"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(MaxHeap H,ElementType item)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将元素item存进H堆中。Elements[0]为哨兵</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(IsFull(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大堆已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;Size;<span class="comment">//i 指向堆在插入元素后的最后一个位置</span></span><br><span class="line">    <span class="keyword">for</span>( ; H-&gt;Elements[<span class="number">1</span>/<span class="number">2</span>] &lt; item; i/=<span class="number">2</span>)</span><br><span class="line">        B-&gt;Elements[i] = H-&gt;Elements[<span class="number">1</span>/<span class="number">2</span>];<span class="comment">//如果插入的元素比上面的元素大，就要交换其位置</span></span><br><span class="line">    H-&gt;Elements[i] = item;<span class="comment">//插入item</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里哨兵发挥了作用，因为他不小于任何堆里的元素。所以在i=1时，不用去判断是不是到1了。直接 i/2 就会与哨兵判断就可以少一次判断</p><h4 id="最大堆删除"><a href="#最大堆删除" class="headerlink" title="最大堆删除"></a>最大堆删除</h4><p>将44删除，将最下面的节点放到根节点。然后进行判断是否为最大堆，如果不是就进行排序。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210921133212514.png" alt="image-20210921133212514"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">DeleteMax</span><span class="params">(MaxHeap H)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从最大堆取出最大的元素，并删除一个节点</span></span><br><span class="line">    <span class="keyword">int</span> parent,child;</span><br><span class="line">    ElementType MaxItem,temp;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大堆已空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MaxItem = H-&gt;Elements[<span class="number">1</span>];<span class="comment">//取出根节点最大值</span></span><br><span class="line"> temp = H-&gt;Elements[H-&gt;Size--];<span class="comment">//获取下面的节点</span></span><br><span class="line">    <span class="comment">//parent*2就是左子树的下标。+1就是右子树</span></span><br><span class="line">    <span class="keyword">for</span>(parent=<span class="number">1</span>;parent*<span class="number">2</span>&lt;=H-&gt;Size; parent=child)&#123;</span><br><span class="line">        child = parent*<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//这里判断有没有左子树，并且判断左右子树谁大。</span></span><br><span class="line">        <span class="keyword">if</span>((child!=H-&gt;size) &amp;&amp; (H-&gt;Elements[child]&lt; H-&gt;Elements[child+<span class="number">1</span>]))</span><br><span class="line">            child++;</span><br><span class="line">        <span class="comment">//判断节点的大小。如果大于就不动，如果小了就进行换位</span></span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= H-&gt;Elements[child]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            H-&gt;Elements[parent] = H-&gt;Elements[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> Maxitem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>带权路径长度(WPL)：设二叉树有N个叶子节点，每个叶子节点带有权值W_k，从根节点到每个叶子节点长度为 l_k ，则每个叶子节点的带权路径长度只和就是：<br>$$<br>WPL=\sum_{i=1}^{n}{l_kW_k}<br>$$<br><strong>最优二叉树</strong>或<strong>哈夫曼树：WPL</strong>最小的二叉树</p><p>哈夫曼树特点</p><ul><li>没有度为1的节点</li><li>n个叶子节点的哈夫曼树共有2n-1个节点</li><li>哈夫曼树任意非叶子的左右子树交换仍然是哈夫曼树</li><li>同一组权值，存在不同构的哈夫曼树</li></ul><p>哈夫曼树的构造：每次吧<strong>权值最小的两颗二叉树合并</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    HuffmanTree Left,Right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffmanTree <span class="title">Huffman</span><span class="params">(MinHeap H)</span></span>&#123;</span><br><span class="line"><span class="comment">//我们所有节点假设权值已经算好在weight中</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    BuildMinHeap(H);<span class="comment">//构建最小堆</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt; H-&gt;size; i++)&#123;</span><br><span class="line">        T=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">        <span class="comment">//从最小堆删除节点，作为左节点和右节点</span></span><br><span class="line">        T-&gt;Left = DeleteMin(H);</span><br><span class="line">        T-&gt;Right = DeleteMin(H);</span><br><span class="line">        <span class="comment">//计算新的权值</span></span><br><span class="line">        T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight;</span><br><span class="line">        <span class="comment">//插入最小堆</span></span><br><span class="line">        Insert(H,T);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T = DeleteMin(H);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>哈夫曼编码</strong></p><p>使用不等长编码，利用前缀码perfix code（任何字符的编码都不是另一字符编码的前缀）</p><p>利用二叉树，只有叶子节点存值</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210925132454649.png" alt="image-20210925132454649"></p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>用树来表示集合</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210925132810197.png" alt="image-20210925132810197"></p><p>这三个分别是不同的集合。每个子节点指向父节点的下标</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 顶部导航栏</title>
      <link href="2021/Android-%E9%A1%B6%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F/"/>
      <url>2021/Android-%E9%A1%B6%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>顶部应用栏，有两种可以实现的方法，一种是用5.0之后的Toolbar，一种是我们自己写导航。</p><h2 id="自定义ActionBar"><a href="#自定义ActionBar" class="headerlink" title="自定义ActionBar"></a>自定义ActionBar</h2><ol><li><p>取消系统自带的主题，在values/theme中，改为NoActionBar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.LazyBookkeeping&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在layout中创建导航栏的布局</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/navigationbar_title&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;</span><br><span class="line">        android:textColor=&quot;@color/white&quot;</span><br><span class="line">        android:textSize=&quot;20sp&quot;</span><br><span class="line">        app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/monthly_expenditure&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_marginEnd=&quot;300dp&quot;</span><br><span class="line">        android:layout_marginRight=&quot;300dp&quot;</span><br><span class="line">        android:textColor=&quot;@color/white&quot;</span><br><span class="line">        android:textSize=&quot;20sp&quot;</span><br><span class="line">        app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toBottomOf=&quot;@+id/navigationbar_title&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在activity_main.xml中定义导航栏</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;cn.yvenxx.lazybookkeeping.topGlobalNavigationBar</span><br><span class="line">                android:id=&quot;@+id/topNavigation_bar&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;</span><br><span class="line">                android:fitsSystemWindows=&quot;true&quot;</span><br><span class="line">                app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">                app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">                app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义导航栏相对的Java类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">topGlobalNavigationBar</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TextView tvTitle;</span><br><span class="line">    <span class="keyword">private</span> View view;</span><br><span class="line">    <span class="keyword">private</span> TextView monthly_expenditure;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">topGlobalNavigationBar</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">topGlobalNavigationBar</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">topGlobalNavigationBar</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        view = inflate(context, R.layout.topnavigationbar, <span class="keyword">this</span>);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span></span>&#123;</span><br><span class="line">        tvTitle = view.findViewById(R.id.navigationbar_title);</span><br><span class="line">        monthly_expenditure = view.findViewById(R.id.monthly_expenditure);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTvTitle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String date = Utils.getDate();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        tvTitle.setText(date);</span><br><span class="line"></span><br><span class="line">        monthly_expenditure.setGravity(Gravity.START);</span><br><span class="line">        monthly_expenditure.setText(<span class="string">&quot;月支出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在MainActivity类中实现ActionBar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//        顶部自定义栏</span></span><br><span class="line">    topGlobalNavigationBar topGlobalNavigationBar = findViewById(R.id.topNavigation_bar);</span><br><span class="line">    topGlobalNavigationBar.setTvTitle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);<span class="comment">//设置透明导航栏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这就可以实现基本的导航栏。可以自行更改界面配置。</p></li></ol><h2 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h2><p>Toolbar在应用窗口的顶部提供的是一个固定的位置，可以随着页面改变而改变。</p><ol><li><p>先取消主题，在res/value/theme 中，改为NoActionBar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.LazyBookkeeping&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在active_main.xml中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;Toolbar</span><br><span class="line">         android:id=&quot;@+id/tool_bar&quot;</span><br><span class="line">         android:layout_width=&quot;match_parent&quot;</span><br><span class="line">         android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">         android:minHeight=&quot;?attr/actionBarSize&quot;</span><br><span class="line">         android:background=&quot;#FFFFFF&quot;</span><br><span class="line">         app:popupTheme=&quot;@menu/topbar&quot;</span><br><span class="line">         android:fitsSystemWindows=&quot;true&quot;&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/tool_bar_title&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:layout_gravity=&quot;center&quot;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">Toolbar</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在res/menu 创建menu文件。没有menu文件夹可以创建。这里没添加内容，可以自行添加。</p><p>[文档]: <a href="https://developer.android.com/guide/topics/ui/menus">https://developer.android.com/guide/topics/ui/menus</a>    “”文档””</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>MainActivity.java，记得调用init()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        toolbar = (Toolbar) findViewById(R.id.tool_bar);</span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line"></span><br><span class="line">        setTitle();</span><br><span class="line"></span><br><span class="line">        toolbar.inflateMenu(R.menu.topbar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO流</title>
      <link href="2021/Java-IO%E6%B5%81/"/>
      <url>2021/Java-IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><p>IO是指 Input  –  Output，即输入和输出，以内存为中心</p><p>input从外部读入数据到内存。output从内存输出到外部。</p><p>这些输入输出流的来源地和目的地可以是文件，也可以是网络连接，甚至是内存块。</p><p>其中Stream是进行处理字节的，而Reader和Writer是用来处理字符的，他们衍生的子类命名也都是以这些后缀结束的。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201119153701157.png" alt="image-20201119153701157"></p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="读字节-InputStream"><a href="#读字节-InputStream" class="headerlink" title="读字节 InputStream"></a>读字节 InputStream</h3><p>读（IputStream） 类有一个抽象方法，read()，这个方法读入一个字节，并返回读入的字节。或者在输入源结尾时返回-1。</p><p>一个读取操作如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用try finally</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    InputStream is =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用try resource</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算机系统中，我们打开了一个资源使用完了需要进行关闭。以便让操作系统把资源释放到，否则应用程序占用的资源会越来越多。</p><p>InputStream,OutputStream都是通过close关闭资源的。</p><p>在我们第一个代码中，我们看到 InputStream is = null;  然后在try里面进行了数据的读操作。但是如果读操作失败了。程序就会跳到finally中，如果我们没有对is进行不等于null的判断，那么就是is操作还没有完成就会被关闭掉。这是不正常的关闭。</p><p>而第二个代码块中，我们使用的是java 7之后支持的 try(resource) 的写法，只需要编写try语句，编译器就会为我们自动关闭资源。</p><blockquote><p>实际上，编译器并不会特别地为<code>InputStream</code>加上自动关闭。编译器只看<code>try(resource = ...)</code>中的对象是否实现了<code>java.lang.AutoCloseable</code>接口，如果实现了，就自动加上<code>finally</code>语句并调用<code>close()</code>方法。<code>InputStream</code>和<code>OutputStream</code>都实现了这个接口，因此，都可以用在<code>try(resource)</code>中。</p></blockquote><h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><p>在我们读取流的时候，一个一个读取并不是最高效的。大多数流支持一次性读取多个字节到缓冲区。InputStream支持读取多个字节填充到byte数据中。</p><ul><li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li><li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li></ul><p>利用上述方法一次读取多个字节时，需要先定义一个<code>byte[]</code>数组作为缓冲区，<code>read()</code>方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。<code>read()</code>方法的返回值不再是字节的<code>int</code>值，而是返回实际读取了多少个字节。如果返回<code>-1</code>，表示没有更多的数据了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BufferInputStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">//三个字节读一次</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写字节-OutputStream"><a href="#写字节-OutputStream" class="headerlink" title="写字节-OutputStream"></a>写字节-OutputStream</h3><p>OutputStream也是一个抽象类，抽象了write(int b)方法</p><p>要注意的是 int b虽然是int参数。但是每次写入还是只能写入一个字节。</p><p>OutputStream还定义了一个flush()方法，目的是将缓冲区中的内容输出到目的地。因为在写入数据的时候，处于效率的考虑，操作系统不是写入一个字节就发送一个字节。而是当缓冲区满了之后在发出去。而flush方法可以强制性的将缓冲区的内容发送到目的地。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次读入一个字节</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        os.write(<span class="number">10</span>);</span><br><span class="line">        os.write(<span class="number">108</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次读入多个字节</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        os.write(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>在InputStream和outputStream中，读写的操作是阻塞的。也就是说，这个线程在进行读取的时候，不能进行下面的操作，需要等到读写完毕之后，才能运行下面的语句。</p><h3 id="copy文件的实现"><a href="#copy文件的实现" class="headerlink" title="copy文件的实现"></a>copy文件的实现</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">copy</span>(<span class="params"><span class="built_in">String</span> path,<span class="built_in">String</span> copyPath</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">try</span>(<span class="params">InputStream is = <span class="keyword">new</span> FileInputStream(path)</span>)</span> &#123;</span><br><span class="line">        int len;</span><br><span class="line">        byte[] buf = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="function"><span class="title">try</span>(<span class="params">OutputStream os = <span class="keyword">new</span> FileOutputStream(copyPath)</span>)</span> &#123;</span><br><span class="line">                os.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Filter-组合输入-输出流过滤器"><a href="#Filter-组合输入-输出流过滤器" class="headerlink" title="Filter 组合输入/输出流过滤器"></a>Filter 组合输入/输出流过滤器</h2><p>DataInputStream只能读入数据类型，而FileInputStream可以提供在磁盘上读取文件的一个输入流。</p><p>其中DataInputStream不能进行读写磁盘，FileInputStream不能进行数值的读写。</p><p>但是Java使用了一种灵巧的机制可以将二者进行结合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream file = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(file);</span><br><span class="line"></span><br><span class="line">file.readInt(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这样的话FileInputStream基础智商高，可以附加额外的功能。</p><p>还可以使用这样的嵌套机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">    <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)));</span><br></pre></td></tr></table></figure><p>我们将DataInputStream放在构造器链的最后，是希望使用DataInputStream的read方法且带有缓冲机制。</p><h2 id="输入输出字符"><a href="#输入输出字符" class="headerlink" title="输入输出字符"></a>输入输出字符</h2><h3 id="输入-Reader"><a href="#输入-Reader" class="headerlink" title="输入-Reader"></a>输入-Reader</h3><p>Reader是Java Io库中的另外一个输入流。和InputStream的区别是，InputStream是byte为单位进行读取。而Reader是字符流，字符单位进行读取的(char);</p><p>使用时需要指定编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取单个字符</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReaderTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;test.txt&quot;</span>,StandardCharsets.UTF-<span class="number">8</span>))&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fileReader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取多个字符</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReaderTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;test.txt&quot;</span>),,StandardCharsets.UTF-<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = fileReader.read(chars))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(chars);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-Writer"><a href="#输出-Writer" class="headerlink" title="输出-Writer"></a>输出-Writer</h3><p>基本原理和输入流的概念相同===直接上例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(Writer w = <span class="keyword">new</span> FileWriter(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        w.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e )&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="copy文件的实现-1"><a href="#copy文件的实现-1" class="headerlink" title="copy文件的实现"></a>copy文件的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Reader r = <span class="keyword">new</span> FileReader(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = r.read(chars))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> (Writer w = <span class="keyword">new</span> FileWriter(<span class="string">&quot;test2.txt&quot;</span>))&#123;</span><br><span class="line">                w.write(chars,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓冲流-提高流的读取写入的速度"><a href="#缓冲流-提高流的读取写入的速度" class="headerlink" title="缓冲流-提高流的读取写入的速度"></a>缓冲流-提高流的读取写入的速度</h2><p>内部提供了一个缓冲区。增加读写速度。</p><p>使用用例：copy文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BufferStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)))&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(buf)) != -<span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">try</span> (BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>)))&#123;</span><br><span class="line">                bos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符流操作基本相同，不进行演示。</p><h2 id="IO转换流"><a href="#IO转换流" class="headerlink" title="IO转换流"></a>IO转换流</h2><p>属于字符流</p><p>inputStreamReader，将一个字节的输入流转换为字符的输入流</p><p>OutputStreamWriter，将一个字符的输出流转换为字节的输出流</p><p>inputStreamReader用例，用字节流读出文件，使用转换流进行转换并输出，其中用了嵌套调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InputStreamReaderTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStreamReader is = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(cbuf))!= -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(cbuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>outputStreamWriter用例，将字符文件读取出来，用另外一种编码方式，使用转换流进行编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputStreamWriterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStreamReader is = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)))&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(cbuf))!= -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> (OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>),<span class="string">&quot;gbk&quot;</span>))&#123;</span><br><span class="line">                osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标准输入输出流（了解）"><a href="#标准输入输出流（了解）" class="headerlink" title="标准输入输出流（了解）"></a>标准输入输出流（了解）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStreamReader is = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(is);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        String s = br.readLine();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equals(s)||<span class="string">&quot;exit&quot;</span>.equals(s))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;------finish------&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>DataInputStream，DataOutputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line">    dos.writeUTF(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">    dos.writeInt(<span class="number">1</span>);</span><br><span class="line">    dos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>ObjectInputStream，ObjectOutputStream，用于存储和读取<strong>基本数据类型数据</strong>或<strong>对象</strong>的处理流。可以吧Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p><ul><li><p>序列化：用ObjectOutputStream类<strong>保存</strong>基本类型数据或对象的机制</p></li><li><p>反序列化：用ObjectInputStream类<strong>读取</strong>基本类型数据或对象的机制</p></li></ul><p>ObjectOutputStream和ObjectInputStream不能序列化<strong>static</strong>和<strong>transient</strong>修饰的成员变量</p><ul><li><p>对象的序列化机制：允许吧内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久的保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其他程序获得了这个二进制流，就可以恢复成原来的Java对象</p></li><li><p>序列化的好处在于可将任何实现了Serializable接口的对象转换为字节数据，使其在保存和传输时可被还原。</p></li><li><p>要想某个类能够被序列化，需要实现序列化接口。加上序列端口号（serialVersionUID)</p><ul><li>必须加上serialVersionUID，如果没加上，在实例的时候会自动给serialVersionUID赋值，但是如果类的实例变量做了修改，serialVersionUID可能发生变化。</li><li>而且，除了本类需要序列化，类中的属性也必须都支持序列化</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ObjectOutputStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;object.dat&quot;</span>)))&#123;</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ObjectInputStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;object.dat&quot;</span>))) &#123;</span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        String str = (String) o;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h2><ul><li><p>直接继承与Object，实现了DataInput，DataOutput接口，既可以作为输入流，也可以作为输出流</p></li><li><p>如果RandomAccessFile类作为一个输出流，写出的文件不存在时，则在执行过程中自动创建。如果写出的文件存在，则会对原油文件内容覆盖，从头覆盖。</p></li></ul><p>方法</p><ul><li>seek(int x);  seek可以将指针调整到x的位置。</li></ul><p>文件的复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RandomAccessFile r1 = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    RandomAccessFile r2 = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test1.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = r1.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        r2.write(buf,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    r1.close();</span><br><span class="line">    r2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为了看起来方便所以没用使用try-catch-finally，实际使用中需要使用try-catch-finally</p><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>Java NIO（new IO)是从java1.4版本开始引入的新io api。与原有的io有同样的作用和目的。但是会有一些区别</p><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流(Stream Oriented)</td><td>面向缓冲区(Buffer Oriented)</td></tr><tr><td>阻塞IO(blocking IO)</td><td>非阻塞IO(Non Blocking IO)</td></tr><tr><td>无</td><td>选择器(Selectors)</td></tr></tbody></table><h2 id="通道和缓冲区"><a href="#通道和缓冲区" class="headerlink" title="通道和缓冲区"></a>通道和缓冲区</h2><p>通道（channel）负责传输，buffer（缓冲区）负责存储</p><p>核心在于，通道表示打开到IO设备的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。</p><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><ul><li><p>缓冲区(Buffer)：一个用于<strong>特定基本类型的容器</strong>。由java.nio包定义的。所有缓冲区都是Buffer抽象类的子类。</p></li><li><p>Java Nio中的Buffer主要用于与Nio通道进行交互，数据是从<strong>通道读入缓冲区</strong>，从<strong>缓冲区写入通道中</strong>的。</p></li></ul><ol><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ol><p>都采用相似的方法进行管理数据，只是各自管理的数据类型不同。</p><p>通过如下方法获取一个Buffer对象</p><p><strong>static xxxBuffer  allocate(int capacity); 创建一个容量为capacity的xxxBuffer对象</strong></p><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><ul><li>容量(Capacity)：表示Buffer最大数据容量，缓冲区容量不能为负，且创建后不能更改</li><li>限制(limit)：不应该被读取或写入的数据的索引，也就是说，位于limit后的数据不可读写，缓冲区的限制不能为负，并且不能大于其容量</li><li>位置(position):下一个要读写数据的索引，缓冲区的位置不能为负，并且不能大于其限制。</li><li>标记(mark)与重置(reset)：标记是一个索引，通过mark方法标记一个位置，通过reset可以回到这个位置。</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120143549483.png" alt="image-20201120143549483"></p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120143929945.png" alt="image-20201120143929945"></p><h4 id="缓冲区的数据操作"><a href="#缓冲区的数据操作" class="headerlink" title="缓冲区的数据操作"></a>缓冲区的数据操作</h4><p>Buffer所有子类提供了俩个用于数据操作的方法：get()与put()方法</p><ul><li>获取Buffer中的数据<ul><li>get()：获取单个字节</li><li>get(byte[] dst): 批量读取多个字节到dst中</li><li>get(int index)：读取指定索引位置的字节（不会移动position)</li></ul></li><li>放入数据到Buffer中<ul><li>​    put(byte b ); 将给定单个字节写入缓冲区的当前位置</li><li>put(byte[] src) 将src中的字节写入缓冲区的当前位置</li><li>put(int index, byte b) 将指定字节写入缓冲区的索引位置（不会移动position）</li></ul></li></ul><h2 id="直接缓冲区和非直接缓冲区"><a href="#直接缓冲区和非直接缓冲区" class="headerlink" title="直接缓冲区和非直接缓冲区"></a>直接缓冲区和非直接缓冲区</h2><ul><li>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则java虚拟机会尽最大努力直接在此缓冲区上执行本机I/O操作。也就是说，在每次调用基础操作系统的一个本机I/O操作之前 / 之后   ，虚拟机都会尽量避免缓冲区的内容复制到中间缓冲区中。（或从中间缓冲区复制内容）</li><li>直接字节缓冲区可以通过调用此类的<strong>allocateDirect()工厂方法</strong>来创建。此方法返回的<strong>缓冲区进行分配和取消分配所需成本通常 高于 非直接缓冲区</strong>。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，他们对应用程序的内存需求造成的影响可能不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机I/O操作影响的大型持久的缓冲区，一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显的好处时分配他们。</li><li>直接字节缓冲区还可以通过<strong>FileChannel的map()方法</strong>将文件区域直接映射到内存中来创建。该方法返回<strong>MappedByteBuffer</strong>。Java平台的实现有助于通过JNI从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。</li><li>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其isDirect()方法来确定。提供此方法为了能够在性能关键型代码中执行显式缓冲区管理。</li></ul><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120192145057.png" alt="image-20201120192145057"></p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120192154588.png" alt="image-20201120192154588"></p><h2 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h2><p>通道：由java.nio.channels包定义。表示io源与目标打开的连接。类似于传统的”流“。只不过不能直接访问数据，只能与buffer进行交互。</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120194239570.png" alt="image-20201120194239570"></p><ul><li>FileChannel：用于读取，写入，映射和操作文件的通道</li><li>DatagramChannel：通过UDP读写网络中的数据通道</li><li>SocketChannel：通过Tcp读写网络中的数据</li><li>ServerSocketChannel：可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel</li></ul><h3 id="获取通道"><a href="#获取通道" class="headerlink" title="获取通道"></a>获取通道</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120194520338.png" alt="image-20201120194520338"></p><h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120194533240.png" alt="image-20201120194533240"></p><h2 id="分散（Scatter）聚集（Gather"><a href="#分散（Scatter）聚集（Gather" class="headerlink" title="分散（Scatter）聚集（Gather)"></a>分散（Scatter）聚集（Gather)</h2><p>分散是指一个channel的数据，分散到多个缓冲区。</p><p>聚集是指多个buffer聚集到一个channel中。</p><p>所有操作都需要try-catch，这里只是为了看的层次感。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分散读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ScatterAndGatherTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    FileChannel fisChannel = fis.getChannel();</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">    ByteBuffer buffer2 = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    ByteBuffer[] buffers = &#123;buffer1,buffer2&#125;;</span><br><span class="line">    fisChannel.read(buffers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分散读取</span></span><br><span class="line">    <span class="keyword">for</span> (ByteBuffer buffer : buffers) &#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//聚集写入</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line">    FileChannel fosChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">    fosChannel.write(buffers);</span><br><span class="line"></span><br><span class="line">    fis.close();</span><br><span class="line">    fisChannel.close();</span><br><span class="line">    fos.close();</span><br><span class="line">    fosChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TransferTo—-TransferFrom"><a href="#TransferTo—-TransferFrom" class="headerlink" title="TransferTo—-TransferFrom"></a>TransferTo—-TransferFrom</h2><p>将数据从源通道传输到其他Channel</p><h3 id="TransferFrom"><a href="#TransferFrom" class="headerlink" title="TransferFrom"></a>TransferFrom</h3><p>使用输出流的channel，from表示从哪里来，所以用输出流调用此方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransferFrom</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TransferFromTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FileChannel fisChannel = fis.getChannel();</span><br><span class="line">    FileChannel fosChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">    fosChannel.transferFrom(fisChannel,<span class="number">0</span>, fisChannel.size());</span><br><span class="line"></span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">    fisChannel.close();</span><br><span class="line">    fosChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="TransferTo"><a href="#TransferTo" class="headerlink" title="TransferTo"></a>TransferTo</h3><p>使用输入流channel调用，表示数据到哪里去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransferTo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TransferToTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FileChannel fisChannel = fis.getChannel();</span><br><span class="line">    FileChannel fosChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">    fisChannel.transferTo(<span class="number">0</span>, fisChannel.size(),fosChannel);</span><br><span class="line"></span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">    fisChannel.close();</span><br><span class="line">    fosChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FileChannel常用方法"><a href="#FileChannel常用方法" class="headerlink" title="FileChannel常用方法"></a>FileChannel常用方法</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201120205445563.png" alt="image-20201120205445563"></p><h2 id="NIO非阻塞式网络通信"><a href="#NIO非阻塞式网络通信" class="headerlink" title="NIO非阻塞式网络通信"></a>NIO非阻塞式网络通信</h2><p>传统的IO流都是阻塞式的。而JavaNIO是非阻塞的。当线程从某同道进行读写数据时，若没有数据可同时，该线程可以进行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行Io操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO可以让服务器端使用一个或有限几个线程来同时处理连接到服务端的所有客户端。</p><h3 id="选择器Selector"><a href="#选择器Selector" class="headerlink" title="选择器Selector"></a>选择器Selector</h3><p>选择器（Selector） 是 SelectableChannle 对象的多路复用器，<strong>Selector 可以同时监控多个 SelectableChannel 的 IO 状况</strong>，也就是说，利用 <strong>Selector 可使一个单独的线程管理多个 Channel</strong>。Selector 是非阻塞 IO 的核心。</p><p>Selector结构</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201122135131145.png" alt="image-20201122135131145"></p><h3 id="Tcp模式的Selector非阻塞"><a href="#Tcp模式的Selector非阻塞" class="headerlink" title="Tcp模式的Selector非阻塞"></a>Tcp模式的Selector非阻塞</h3><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SocketChannel sChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9898</span>))) &#123;</span><br><span class="line">        <span class="comment">//设置非阻塞模式</span></span><br><span class="line">        sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            String s = sc.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;exit&quot;</span>.equals(s))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf.put(s.getBytes());</span><br><span class="line">            buf.flip();</span><br><span class="line">            sChannel.write(buf);</span><br><span class="line">            buf.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SocketChannel sChannel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> (ServerSocketChannel ssChannel = ServerSocketChannel.open())&#123;</span><br><span class="line"><span class="comment">//设置非阻塞模式</span></span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//绑定端口</span></span><br><span class="line">        ssChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line"><span class="comment">//获取选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"><span class="comment">//向选择器注册通道</span></span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否有选择器被注册</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select()&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//获取注册器的SelectedKeys迭代器</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                SelectionKey sk = it.next();</span><br><span class="line">                <span class="comment">//是否接受就绪</span></span><br><span class="line">                <span class="keyword">if</span> (sk.isAcceptable())&#123;</span><br><span class="line">                    sChannel = ssChannel.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    sChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//是否可读就绪</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sk.isReadable())&#123;</span><br><span class="line">                    sChannel = (SocketChannel)sk.channel();</span><br><span class="line">                    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                    ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((len = sChannel.read(buf))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        buf.flip();</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(buf.array(),<span class="number">0</span>,len));</span><br><span class="line">                        buf.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定</p><p>可以监听的事件类型（<strong>可使用</strong> <strong>SelectionKey</strong> <strong>的四个常量表示</strong>）：</p><ul><li><p> 读 : SelectionKey.OP_READ （1） </p></li><li><p> 写 : SelectionKey.OP_WRITE （4） </p></li><li><p> 连接 : SelectionKey.OP_CONNECT （8） </p></li><li><p> 接收 : SelectionKey.OP_ACCEPT （16） </p></li></ul><h4 id="Selector常用方法"><a href="#Selector常用方法" class="headerlink" title="Selector常用方法"></a>Selector常用方法</h4><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201122152338158.png" alt="image-20201122152338158"></p><h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p>连接到Tcp网络套接字的通道</p><p>操作步骤</p><ol><li>打开SocketChannel</li><li>读写数据</li><li>关闭SocketChannel</li></ol><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h4><ul><li><p>能发送Udp包的通道</p></li><li><p>操作步骤</p><ol><li>打开DatagramChannel</li><li>接受/发送数据</li></ol></li></ul><p>UDP基本和Tcp一样</p><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramChannel dc = DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">    dc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (scan.hasNext())&#123;</span><br><span class="line">        String s = scan.nextLine();</span><br><span class="line">        buf.put(s.getBytes());</span><br><span class="line"></span><br><span class="line">        buf.flip();</span><br><span class="line">        dc.send(buf,<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9898</span>));</span><br><span class="line">        buf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    dc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramChannel dc = DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">    dc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    dc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line"></span><br><span class="line">    Selector selector= Selector.open();</span><br><span class="line"></span><br><span class="line">    dc.register(selector,SelectionKey.OP_READ);</span><br><span class="line">    <span class="keyword">while</span> (selector.select()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            SelectionKey sk = it.next();</span><br><span class="line">            <span class="keyword">if</span> (sk.isReadable())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">                ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                dc.receive(buf);</span><br><span class="line">                buf.flip();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(buf.array(),<span class="number">0</span>,buf.limit()));</span><br><span class="line">                buf.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    dc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pipe（管道）"><a href="#Pipe（管道）" class="headerlink" title="Pipe（管道）"></a>Pipe（管道）</h2><p>管道是俩个线程之间的单向数据连接。Pipe有一个Source通道和一个Sink通道。</p><p>数据会被写入Sink通道，从Source通道接收读取</p><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20201122152654073.png" alt="image-20201122152654073"></p><p>这里将sink和source放在一个方法中了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String s = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Pipe pipe = Pipe.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sink</span></span><br><span class="line">    Pipe.SinkChannel sink = pipe.sink();</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    buffer.put(s.getBytes());</span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">        sink.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//source</span></span><br><span class="line">    Pipe.SourceChannel source = pipe.source();</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    source.read(buffer1);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(buffer1.array(),<span class="number">0</span>,buffer1.limit()));</span><br><span class="line"></span><br><span class="line">    source.close();</span><br><span class="line">    sink.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7 安装python3.x</title>
      <link href="2021/Centos7-%E5%AE%89%E8%A3%85python3-x/"/>
      <url>2021/Centos7-%E5%AE%89%E8%A3%85python3-x/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>Centos自带的是2.x的python，升级到3.x的版本</p><hr><p>下载python 官网地址:<a href="https://www.python.org/">https://www.python.org/</a></p><p>这里使用3.7版本的python</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#在Linux中运行</span><br><span class="line">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.7.3&#x2F;Python-3.7.3.tgz</span><br><span class="line"></span><br><span class="line">#解压 x.x.x是你的版本</span><br><span class="line">tar -xzvf Python-x.x.x.tgz </span><br><span class="line"></span><br><span class="line">#安装 其他python需要的包</span><br><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc  libffi-devel</span><br><span class="line"></span><br><span class="line">#编译安装 进入解压之后的python目录中</span><br><span class="line"># --prefix 指定安装位置</span><br><span class="line"># --enable-shared 共享库</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3.7 --enable-shared</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>make install之后 使用命令  echo $?</p><p>终端输出0就是没错。如果不是0就是有报错</p><p>没有报错的话。在/usr/local/ 中会有python3.7目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#安装完成之后</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><p><strong>备份系统自带的python2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv &#x2F;usr&#x2F;bin&#x2F;python &#x2F;usr&#x2F;bin&#x2F;python.bak</span><br></pre></td></tr></table></figure><p><strong>创建python3的软连接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python3.7&#x2F;bin&#x2F;python3.7 &#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"></span><br><span class="line">#检验一下 --如果是3.7版本就是成功了</span><br><span class="line">python -v</span><br></pre></td></tr></table></figure><p><strong>如果有报共享库错误，或者找不到xxx.lib文件</strong></p><h3 id="使用ldconfig命令"><a href="#使用ldconfig命令" class="headerlink" title="使用ldconfig命令"></a>使用ldconfig命令</h3><p>​    ldconfig /usr/local/python3.7/lib<br>​    即可</p><h3 id="因为python升级了，yum也需要改一下配置"><a href="#因为python升级了，yum也需要改一下配置" class="headerlink" title="因为python升级了，yum也需要改一下配置"></a>因为python升级了，yum也需要改一下配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;bin&#x2F;yum</span><br><span class="line">vim &#x2F;usr&#x2F;libexec&#x2F;urlgrabber-ext-down</span><br></pre></td></tr></table></figure><p>将开头的#/usr/bin/python 改为/usr/bin/python2</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言：指针</title>
      <link href="2021/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E6%8C%87%E9%92%88/"/>
      <url>2021/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>学习数据结构顺带记下。</p></blockquote><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针也可以理解为一个数据类型。指针类型，他不是一个具体的值，他保存的是一个地址。这个地址保存了其他的数据。（有点抽象）</p><p>可以这么理解。一个数组的下标就是地址。数组里面的值，才是保存的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *b = &amp;a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%d\n&quot;</span>,*b);</span><br><span class="line"></span><br><span class="line">    *b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%d\n&quot;</span>,*b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------输出结果——--------------</span><br><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="number">10</span></span><br><span class="line">a=<span class="number">20</span></span><br><span class="line">b=<span class="number">20</span></span><br></pre></td></tr></table></figure><p>可以看到，<em>b赋值20的时候，a也变为20了。\</em>b指向了a的地址。当改变b的值时，改变的是*b指向的地址那里的值。</p><ul><li><strong>“ &amp;（取址运算符）”:  取出变量的地址</strong></li><li>*<em>“ <em>+变量名 “ :  指针</em></em></li></ul><h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> temp)</span></span>&#123;</span><br><span class="line">    temp=<span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> *temp)</span></span>&#123;</span><br><span class="line">    temp=<span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    test1(a);</span><br><span class="line">    test2(&amp;b);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d&quot;</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line">--------------输出-------------</span><br><span class="line">a=<span class="number">10</span> b=<span class="number">999</span></span><br></pre></td></tr></table></figure><p>test1函数，并没有改变a的值。因为test1的temp是一个临时变量，改变的只是temp的值。</p><p>test2函数，是用指针来接收b的地址，修改了值之后，修改的是b位置的值。</p><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ary_set</span><span class="params">(<span class="keyword">int</span> v[],<span class="keyword">int</span> n ,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v[i]=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = a;</span><br><span class="line">    ary_set(&amp;a[<span class="number">2</span>],<span class="number">5</span>,<span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\na[%d] = %d  *(p+i)=%d&quot;</span>,i,a[i],*(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=========输出-=================</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>  *(p+i)=<span class="number">1</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span>  *(p+i)=<span class="number">2</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">99</span>  *(p+i)=<span class="number">99</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">99</span>  *(p+i)=<span class="number">99</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">99</span>  *(p+i)=<span class="number">99</span></span><br><span class="line">a[<span class="number">5</span>] = <span class="number">99</span>  *(p+i)=<span class="number">99</span></span><br><span class="line">a[<span class="number">6</span>] = <span class="number">99</span>  *(p+i)=<span class="number">99</span></span><br><span class="line">a[<span class="number">7</span>] = <span class="number">0</span>  *(p+i)=<span class="number">0</span></span><br></pre></td></tr></table></figure><ol><li>*p = a，指向 a[0]的地址  相当于  *p = &amp;a[0]。</li><li>p+1 = a[0+1]</li><li>思考：可以看到 数组只有5位，但是我们是从下标2开始赋值99，后面下标为6的值也为99。6已经超过了我们的数组长度。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Meta 的标签理解总结- Html</title>
      <link href="2021/Meta-%E7%9A%84%E6%A0%87%E7%AD%BE%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93-Html/"/>
      <url>2021/Meta-%E7%9A%84%E6%A0%87%E7%AD%BE%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93-Html/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>这俩天在搜索自己博客的时候，发现只有自己网页显示的内容。但是看了一下别人网页的首页和我一样没什么信息。但是在搜索引擎搜索的时候却有很多没看到的信息显示在上面。于是看了一下网页的源代码。发现搜索引擎出来的数据都是在meta标签中。于是重新去看了一下html的meta标签。</p><p>在之前的理解中，meta只有这个作用</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attribute">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="MDN中"><a href="#MDN中" class="headerlink" title="MDN中"></a>MDN中</h2><blockquote><p><strong>HTML meta 元素</strong>表示那些不能由其它HTML元相关元素 (style, base, link, script, title)之一表示的任何元数据信息。</p></blockquote><p>其中 meta 中文名 也叫 元数据（Metadata)</p><hr><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><p>meta 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。</p><hr><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="必要属性"><a href="#必要属性" class="headerlink" title="必要属性"></a>必要属性</h3><p><a href="https://imgchr.com/i/dEPgun"><img src="https://s1.ax1x.com/2020/08/16/dEPgun.md.png" alt="dEPgun.md.png"></a></p><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p><a href="https://imgchr.com/i/dEP2Bq"><img src="https://s1.ax1x.com/2020/08/16/dEP2Bq.md.png" alt="dEP2Bq.md.png"></a></p><hr><h4 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h4><ol><li><p>application-name，定义运行在该网页上的网络应用名称</p><p>这个没试过，就不写例子了。防止耽误人。</p></li></ol><ol start="2"><li><p>author，这个网页的作者。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yvenxx&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>description，包含网页中的精简的描述，网站的主要内容是什么，其中Firefox和Opera，将其用作书签的描述。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yven的个人博客，写一写技术总结，存放一些个人作品&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>keywords，搜索引擎所提取网页关键字。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yven，博客，后端，java&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>rebots，定义搜索引擎蜘蛛的的索引方式。告诉它哪些要索引哪些不要索引（值有很多）</p><p>值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.index----允许蜘蛛索引页面,也就是索引此页面。</span><br><span class="line">2.noindex----防止蜘蛛索引该页面</span><br><span class="line">3.follow----允许蜘蛛通过此页面的链接。索引其他页面。</span><br><span class="line">4.nofollow----防止蜘蛛索引此页面上的链接。</span><br><span class="line">5.noodp----禁止将Open Directory Project的描述，用作搜索引擎结果页面中页面的描述</span><br><span class="line">6.noarchive----防止搜索引擎缓存页面的内容</span><br><span class="line">7.nocache----与noarchive相同。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;rebots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>viewport，提供有关视图的初始大小，但仅对移动设备生效。</p><p>值</p><p><a href="https://imgchr.com/i/dEPRH0"><img src="https://s1.ax1x.com/2020/08/16/dEPRH0.md.png" alt="dEPRH0.md.png"></a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>copyright，版权信息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;copyright&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yvenxx&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><p>revisit-after，设置蜘蛛重新访问的时间</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;revisit-after&quot;</span> <span class="attr">content</span>=<span class="string">&quot;2 days&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="http-equiv属性–特定的Http头部"><a href="#http-equiv属性–特定的Http头部" class="headerlink" title="http-equiv属性–特定的Http头部"></a>http-equiv属性–特定的Http头部</h4><ol><li><p>content-type ,使用这个属性，值必须是”<code>text/html; charset=utf-8</code>“。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span></span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>x-ua-compatible，如果指定内容属性值必须为 IE=edge</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x-ua-compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span>&gt;</span>//指定ie和chrome渲染当前页</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>refresh，指定网页自动载入页面的时间间隔。有俩种用法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1，如果content只包含一个正整数，就是重新载入网页的时间。</span><br><span class="line">2，如果content包含了一个正整数，外加 ;url=xxxxx 则是重定向到那个网页的间隔时间。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;2;url=http://yvenxx.cn&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中还有部分的属性没有提到，还没有完全的了解。把常用的一些属性总结在了里面。</p><p>如果文章有错误的地方，希望各位指正。感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
