<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一些我的计算机笔记，JAVA/Python/Linux/后端/计算机基础"><title>计算机网络(自顶向下)第五章 | 懒人瑜恩</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '2059a4484fb666484cf5e9fba7e20ce6';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">计算机网络(自顶向下)第五章</h1><a id="logo" href="/.">懒人瑜恩</a><p class="description">sometimes code, sometimes English</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/history/"><i class="fa fa-book"> 历史</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">计算机网络(自顶向下)第五章</h1><div class="post-meta">2021-10-15<span> | </span><span class="category"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">网络控制平面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">路由选择算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">路由概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.2.</span> <span class="toc-text">路由的原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.3.</span> <span class="toc-text">路由算法分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Link-state%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">Link state算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#distance-vector%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.5.</span> <span class="toc-text">distance vector算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LS%E5%92%8CDV%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.1.6.</span> <span class="toc-text">LS和DV算法的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E7%89%B9%E7%BD%91%E4%B8%AD%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="toc-number">1.2.</span> <span class="toc-text">因特网中自治系统内部的路由选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RIP%EF%BC%88Routing-Information-Protocol%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">RIP（Routing Information Protocol）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSPF"><span class="toc-number">1.2.2.</span> <span class="toc-text">OSPF</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ISP%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%EF%BC%9ABGP"><span class="toc-number">1.3.</span> <span class="toc-text">ISP之间的路由选择：BGP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AS%E9%97%B4%E8%B7%AF%E7%94%B1%EF%BC%9ABGP"><span class="toc-number">1.3.1.</span> <span class="toc-text">AS间路由：BGP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP%EF%BC%9A%E5%9B%A0%E7%89%B9%E7%BD%91%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.4.</span> <span class="toc-text">ICMP：因特网控制报文协议</span></a></li></ol></li></ol></div></div><div class="post-content"><a id="more"></a>

<h2 id="网络控制平面"><a href="#网络控制平面" class="headerlink" title="网络控制平面"></a>网络控制平面</h2><h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><h4 id="路由概念"><a href="#路由概念" class="headerlink" title="路由概念"></a>路由概念</h4><p>按照某种指标（站数，延迟，费用，队列长度等，或者是一些单纯指标的加权平均）找到一条从源节点到目标节点的较好路径（按照某种指标较小的路径）</p>
<p>以<strong>网络</strong>为单位进行路由（计算机网络 到其他网络怎么走），路由器—路由器之间的路由。</p>
<blockquote>
<p>在一个网络中：路由器—主机之间的通信，链路层解决。其他的就是到路由器，到了路由器就是到了这个网络，里面有很多主机。</p>
</blockquote>
<p><strong>网络的图抽象</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211015110859673.png" alt="image-20211015110859673"></p>
<p>路由的输入：拓扑，边的代价，源节点</p>
<p>输出的输出：源节点的汇集树</p>
<p>最优化原则：算法可以参考图里面的最短路径算法</p>
<h4 id="路由的原则"><a href="#路由的原则" class="headerlink" title="路由的原则"></a>路由的原则</h4><p>正确性：算法必须<strong>正确</strong>和<strong>完整</strong>的。</p>
<p>简单性：算法在计算机上实现简单。</p>
<p>健壮性：算法应能适应<strong>通信量</strong>和网络拓扑的变化。例如不向很挤的链路发数据，不向断了的链路发数据</p>
<p>稳定性：产生的路由不应该摇摆</p>
<p>公平性：对每个站点公平</p>
<p>最优性：某一个指标的最优，或者综合最优。</p>
<h4 id="路由算法分类"><a href="#路由算法分类" class="headerlink" title="路由算法分类"></a>路由算法分类</h4><p>全局：所有路由器拥有完整的拓扑和边的代价的信息。Linkstate算法</p>
<p>分布式：路由器只知道与他有物理连接关系的领居路由器，distance vector算法</p>
<p>静态或动态</p>
<p>静态：路由随时间变化缓慢</p>
<p>动态：路由变化很快，周期性更新，根据链路代价的变化而变化</p>
<h4 id="Link-state算法"><a href="#Link-state算法" class="headerlink" title="Link state算法"></a>Link state算法</h4><p><strong>LS路由选择算法</strong>的路由工作过程</p>
<ul>
<li>各点通过各种渠道获得<strong>整个网络拓扑</strong>，网络中所有链路<strong>代价</strong>等信息（协议和实现）</li>
<li>使用<strong>LS路由算法</strong>，计算本站点到其他站点的最优路径（汇集树），得到路由表</li>
<li>按照此路由表转发分组（datagram方式），分发到输入端口的网络层（不能算一个步骤）</li>
</ul>
<p><strong>Link state routing链路状态路由选择</strong></p>
<p>LS路由的基本工作过程</p>
<ol>
<li><p>发送相邻节点，获知对方网络地址</p>
<ul>
<li>一个路由器接上电，向所有线路发送HELLO分组</li>
<li>其他路由器收到HELLO分组，回送应答，在应答分组中稿纸自己的名字（全局唯一）</li>
<li>在LAN中，通过广播HELLO分组，获得其他路由器的信息</li>
</ul>
</li>
<li><p>测量到相邻节点的代价（延迟，开销）</p>
<ul>
<li>实测法，发送一个分组要求对方立即响应，回送一个ECHO分组，通过测量时间估算出延迟情况</li>
</ul>
</li>
<li><p>组装一个分组，描述相邻节点的情况</p>
<ul>
<li>发送者名称，序号，年龄</li>
<li>列表：给出他相邻节点，和它到相邻节点的延迟</li>
</ul>
</li>
<li><p>将分组通过扩散的方法发到所有其他路由器</p>
<ul>
<li><p>设置顺序号：防止无穷的扩散，每个路由器都记录（源路由器，顺序号），发现重复的或老的就不扩散。</p>
<p>生成一个分组，设置一个年龄字段/顺序号，不为0，每过一个路由器，顺序号减1，当顺序号为0时分组被抛弃</p>
</li>
<li><p>分组的数据结构</p>
<ul>
<li>Source：从哪个节点收到LS分组</li>
<li>Seq，Age：序号，年龄</li>
<li>Send flags：发送标记，必须向指定的那些相邻站点转发LS分组</li>
<li>ACK flags：本站点必须向哪些站点发送应答</li>
<li>DATA：来自source站点的LS分组</li>
</ul>
</li>
</ul>
</li>
<li><p>通过Dijkstra算法找出最短路径</p>
<ul>
<li>路由器获得各站点LS分组和整个网络拓扑。通过Dijkstra算法计算出到其他各路由器的最短路径（汇集树）</li>
<li>将计算结果安装到路由表中</li>
</ul>
</li>
</ol>
<p><strong>链路状态路由选择算法工作原理</strong></p>
<p>符号标记:</p>
<ul>
<li><p>c(i,j): 从节点i 到j链路代价(初始状态下非相邻节点之间的</p>
<p>链路代价为∞)</p>
</li>
<li><p>D(v): 从源节点到节点V的当前路径代价(节点的代价)</p>
</li>
<li><p>p(v): 从源到节点V的路径前序节点</p>
</li>
<li><p>N’: 当前已经知道最优路径的的节点集合(永久节点的集合)</p>
</li>
</ul>
<p><strong>工作原理</strong></p>
<p>节点标记：每一个节点使用（D(v) , p(v)) 如(3,B)，Dv从源节点由已知的最优路径到达本节点的距离，pv为前序节点</p>
<p>分为两类节点</p>
<p>临时节点（tentative node）还没有找到从源节点到此节点的最优路径的节点</p>
<p>永久节点（permanent node）N’：已经找到了从源节点到此节点的最优路径的节点</p>
<blockquote>
<p>初始化</p>
<ul>
<li><p>除了源节点外,所有节点都为临时节点</p>
</li>
<li><p>节点代价除了与源节点代价相邻的节点外,都为∞ </p>
</li>
</ul>
<p>从所有临时节点中找到一个节点代价最小的临时节点,将之变成永久节点(当前节点)W</p>
<p>对此节点的所有在临时节点集合中的邻节点(V) </p>
<ul>
<li><p>如 D(v)&gt;D(w) + c(w,v), 则重新标注此点, (D(W)+C(W,V), W) </p>
</li>
<li><p>否则，不重新标注</p>
</li>
</ul>
<p>开始一个新的循环</p>
</blockquote>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211015201158511.png" alt="image-20211015201158511"></p>
<h4 id="distance-vector算法"><a href="#distance-vector算法" class="headerlink" title="distance vector算法"></a>distance vector算法</h4><p><strong>距离矢量路由选择（distance vector routing）</strong></p>
<p>基本思想</p>
<p>各路由器维护一张路由表（如图），各路由器与相邻路由器交换路由表，根据获得的路由信息，更新路由表</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211015202014231.png" alt="image-20211015202014231"></p>
<p>路由信息的更新（定期测量）</p>
<ol>
<li>根据实测，得到本节点A到相邻节点的代价（如：延迟）</li>
<li>根据各相邻节点声称他们到B节点的代价</li>
<li>计算出A经过相邻站点到达B的代价，选择最小的代价和相应下一个节点。</li>
</ol>
<p><strong>距离矢量算法</strong></p>
<p>核心思路：</p>
<p>每个节点将自己的距离矢量估计值传送给邻居，定时或者DV有变化时，让对方算。当x从邻居收到DV时，自己计算，更新他自己的距离矢量</p>
<p><strong>异步式，迭代</strong>，本地链路代价变化，从邻居来了DV的更新消息</p>
<p><strong>分布式：</strong>每个节点在自己的DV改变后向邻居通告，然后邻居在有必要的时候再通知他们其他的邻居</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211015203614861.png" alt="image-20211015203614861"></p>
<p>DV的特点</p>
<p>好消息传的快，坏消息传的慢。好消息的传播以每一个交换周期的速度进行。</p>
<p>坏消息的传播速度非常慢，例如 A&lt;———B&lt;———-C，C有个坏消息要传A，他会传给B，B又给C，这样循环往复，到A的距离不可达</p>
<p><strong>水平分裂（split horizon）算法</strong></p>
<p>对无穷计算问题的解决方案</p>
<blockquote>
<p>注：某些拓扑形式下会失败（存在环路）</p>
</blockquote>
<p>例：</p>
<p>A，B到D的距离为2，C到D的距离为1，如果C-D失败，C知道到D是INF，A，B从C知道到D是INF，但是A从B以为到D可达，A就会从B走（B也有类似的问题），经过无限次之后，A和B都知道D不可到</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211015221220033.png" alt="image-20211015221220033"></p>
<h4 id="LS和DV算法的比较"><a href="#LS和DV算法的比较" class="headerlink" title="LS和DV算法的比较"></a>LS和DV算法的比较</h4><p>两种算法都有优缺点。</p>
<p>消息复杂度（DV胜出）</p>
<p>收敛时间（LS胜出）</p>
<p>健壮性（LS胜出）</p>
<h3 id="因特网中自治系统内部的路由选择"><a href="#因特网中自治系统内部的路由选择" class="headerlink" title="因特网中自治系统内部的路由选择"></a>因特网中自治系统内部的路由选择</h3><h4 id="RIP（Routing-Information-Protocol）"><a href="#RIP（Routing-Information-Protocol）" class="headerlink" title="RIP（Routing Information Protocol）"></a>RIP（Routing Information Protocol）</h4><p>DV算法</p>
<ul>
<li>距离矢量：每条链路cost=1，# of hops (max= 15hops) 跳数</li>
<li>DV每隔30秒和邻居交换DV，通告</li>
<li>每个通告包括：最多25个目标子网</li>
<li>通告：DV：在邻居之间每30秒交换通告报文<ul>
<li>定期，而且在改变路由的时候发送通告报文</li>
<li>在对方的请求下也可发送通告报文</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211015224223020.png" alt="image-20211015224223020"></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211015224349738.png" alt="image-20211015224349738"></p>
<p><strong>RIP：链路失效和恢复</strong></p>
<p>如果180秒没有收到通告信息—&gt;邻居或者链路失效</p>
<p>发现经过这个邻居的路由失效，新的通告报文会传递给邻居，邻居因此会发出新的通告（如果路由发生变化），链路失效快速的在整网中传输，使用<strong>毒性逆转</strong>阻止ping-pong回路（不可达的距离：跳数无线=16段）</p>
<p><strong>RIP：进程处理</strong></p>
<p>RIP以应用进程方式实现：route-d（daemon），通告报文通过UDP报文传送，周期性重复，网络层的协议使用了传输层的服务，以应用层实体的方式实现</p>
<h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><p>Open Shortest Path First</p>
<p>open：标准可公开获得</p>
<p>使用LS算法，LS分组在网络中（一个AS内部）分发，全局网络在拓扑，代价在每一个节点中保持，路由计算采用Dijkstra算法</p>
<p>OSPF通告信息中携带：每一个邻居路由器的一个表项，通告信息会传遍AS全部（通过泛洪）（在IP数据报上直接传送OSPF报文，而不是通过UDP和TCP）</p>
<p><strong>IS-IS路由协议</strong>：几乎和OSPF一样</p>
<p>—<strong>“高级特性”</strong>（在RIP中没有的）</p>
<p><strong>安全</strong>：所有的OSPF报文都是经过认证的</p>
<p>允许有<strong>多个代价相同的</strong>路径存在（RIP只有一个），对于每一个链路，对不同的TOS有<strong>多重代价矩阵</strong>。对单播和多播集成支持Multicast OSPF。在大型网络中支持<strong>层次性</strong>OSPF</p>
<p><strong>层次性OSPF</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211016132602160.png"></p>
<p>2个级别的层次性：本地，骨干</p>
<p>链路状态通告仅仅在本地Area范围内进行，每一个节点拥有本地区域的拓扑信息</p>
<p><strong>区域边界路由器：</strong>“汇总“到自己区域内网络的距离，向其他区域边界路由器通告</p>
<p><strong>骨干路由器：</strong>仅仅在骨干区域内，运行OSPF路由</p>
<p>边界路由器：连接其他的AS’s</p>
<h3 id="ISP之间的路由选择：BGP"><a href="#ISP之间的路由选择：BGP" class="headerlink" title="ISP之间的路由选择：BGP"></a><strong>ISP之间的路由选择：BGP</strong></h3><p><strong>层次路由</strong>：将互联网分成一个个AS（路由器区域）</p>
<p>某个区域内的路由器集合 autonomous systems（AS），一个AS用AS Number（ASN）唯一标识，且一个ISP内可能有多个AS</p>
<p><strong>AS内部路由</strong>：在同一个AS内，路由器运行相同的路由协议。不同的AS可能运行不同的内部网关协议</p>
<p>AS间运行<strong>AS间路由协议</strong></p>
<p><strong>优点</strong></p>
<p>AS内部<strong>数量有限</strong>的路由器相互到达的问题，AS<strong>内部规模可控</strong></p>
<p>AS之间的路由，增加一个AS也只是增加一个节点，AS内部的多少不影响AS间路由</p>
<h4 id="AS间路由：BGP"><a href="#AS间路由：BGP" class="headerlink" title="AS间路由：BGP"></a>AS间路由：BGP</h4><p>Border Gateway Protocol：自治区域间路由协议，将互联网各个AS连接在一起的胶水</p>
<p>BGP方法：</p>
<ul>
<li><p>eBGP：从相邻的ASes那里获得子网可达信息</p>
</li>
<li><p>iBGP：将获得的子网可达信息传遍到AS内部的所有路由器</p>
</li>
<li><p>根据子网可达信息和策略来决定到达子网的好路径</p>
</li>
</ul>
<p>基于距离矢量算法，允许子网向互联网通告”我在这里“</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211016143409789.png" alt="image-20211016143409789"></p>
<p><strong>BGP会话</strong>：2个BGP路由器在一个半永久的TCP连接上交换BGP报文</p>
<p>如当AS3网关路由器3a向AS2的网关路由器2c通告路径：AS3.X</p>
<p>通告的时候，通告包含BGP属性</p>
<ul>
<li>prefix+attributes=”route“</li>
<li>重要属性<ul>
<li>AS-PATH：前缀通告所经过的AS列表</li>
<li>NEXT-HOP：从当前AS下吓一跳AS有多少个链路</li>
</ul>
</li>
</ul>
<p><strong>BGP报文</strong></p>
<p>使用TCP协议交换BGP报文</p>
<ul>
<li>OPEN：打开TCP连接，认证发送方</li>
<li>UPDATE：通告新路径（或者撤销原路径）</li>
<li>KEEPALIVE：在没有更新时保持连接，也用于对OPEN请求确认</li>
<li>NOTIFICATION：报告以前消息的错误，也用来关闭连接</li>
</ul>
<p>路由器转发表项</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211016144742050.png" alt="image-20211016144742050"></p>
<p><strong>BGP路径选择</strong></p>
<p>路由器可能获得一个网络前缀的多个路径，路由器必须进行路径的选择，路由选择可以基于：</p>
<ol>
<li><p>本地偏好值属性: 偏好策略决定</p>
</li>
<li><p>最短AS-PATH ：AS的跳数</p>
</li>
<li><p>最近的NEXT-HOP路由器:热土豆路由</p>
<ul>
<li><strong>热土豆策略</strong>：选择具备最小内部区域代价的网关作为往X的出口（如：2d选择2a，即使往X可能有比较多的AS跳数）：不要操心域间的代价！</li>
</ul>
</li>
<li><p>附加的判据：使用BGP标示</p>
</li>
</ol>
<p><strong>通过路径通告执行策略</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211016145139366.png" alt="image-20211016145139366"></p>
<p>例如A通知BC路径Aw，B可以选择不向C通知路径BAw</p>
<p>策略: </p>
<ul>
<li><p>Inter-AS: 管理员需要控制通信路径，谁在使用它的网络进行数据传输；</p>
</li>
<li><p>Intra-AS: 一个管理者，所以无需策略; </p>
<ul>
<li>AS内部的各子网的主机尽可能地利用资源进行快速路由</li>
</ul>
</li>
</ul>
<p>规模: </p>
<ul>
<li><p>AS间路由必须考虑规模问题，以便支持全网的数据转发</p>
</li>
<li><p>AS内部路由规模不是一个大的问题 </p>
<ul>
<li>如果AS 太大，可将此AS分成小的AS；规模可控</li>
<li>AS之间只不过多了一个点而已</li>
<li>或者AS内部路由支持层次性，层次性路由节约了表空间, 降低了更新的数据流量</li>
</ul>
</li>
</ul>
<p>性能: </p>
<ul>
<li><p>Intra-AS: 关注性能</p>
</li>
<li><p>Inter-AS: 策略可能比性能更重要</p>
</li>
</ul>
<h3 id="ICMP：因特网控制报文协议"><a href="#ICMP：因特网控制报文协议" class="headerlink" title="ICMP：因特网控制报文协议"></a>ICMP：因特网控制报文协议</h3><p>由主机，路由器，网关用于传达网络层控制信息（错误报告，Echo请求和回复）</p>
<p>ICMP处在网络层，但是是在IP协议的上面，ICMP消息由IP数据报承载</p>
<p><strong>ICMP报文</strong></p>
<ul>
<li>类型</li>
<li>编码</li>
<li>加上IP数据报的头 8B，第一个导致该ICMP报文的IP数据报</li>
</ul>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211016150646484.png" alt="image-20211016150646484"></p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><p><span>本文标题：</span>计算机网络(自顶向下)第五章</p><p><span>文章作者：</span>懒人瑜恩</p><p><span>发布时间：</span>2021-10-15</p><p><span>最后更新：</span>2021-12-17</p><p><span>原始链接：</span><a href="/2021/计算机网络-自顶向下-第五章/">https://yvenxx.github.io/yvenxx/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://yvenxx.github.io/yvenxx/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0/"></i></span></p><p><span>版权声明：</span>版权所有，转载请注明出处。</p></div><br><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://yvenxx.github.io/yvenxx/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0/" data-id="cl1p05sgd00123ku397bphzp7" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASYAAAEmCAAAAADqr2IGAAAEoUlEQVR42u3aS3LjOBAFQN//0pqI2bbMfq+Kjhbo5MpBSwKQWAD1+fqKn9f/T/v562/9+ZnvvvXdJ69n+Prjma3lCxMmTJgwHc70unySIa+nkk/ru09eUyZbkvzad2vBhAkTJkzPYJpNLj+wr/mS4zz5zevNy7cQEyZMmDD9TqZ8GbMrQn6NeAXPXduJCRMmTJh+G1OePG3TsnlIPEvyYsKECROm38zUHqubel9Of28omySpb8iFY8KECROmD2OalQCf8fcP9jdhwoQJE6YPYHqVT57ezRtlkiO/Xcv1+3rVmDBhwoTpWKY2abtJv16XFdtREqbZiEWGABMmTJgwfTzT9Zc314JZUD17syGIUsaYMGHChOlwprzJ5q6wtg1T8xGTedYbhgkTJkyYDmfKw8XNIjdB9eb43zf0YMKECROm05nygPOGIUdLmh3neR9OlAXHhAkTJkzHMrUL2Fwg8mC1Dcjzy0ob8GPChAkTpnOZ8sJkvsh8irPSZt4MlIe+dfsOJkyYMGE6lmmWbN2377RJ4bsSuMW2YcKECROmA5naY7L9ZMLaBttJ6nb2O1E5ExMmTJgwHcWU1Ozy9GjSypOE07PrQj6f/A0mTJgwYXoG0ywszBHzsDZP1CaJ5iRtXaSAMWHChAnTgUztgT0LaPMiZRumzujrWWHChAkTpkcwtcXITWNoHtbe+2b4X0yYMGHCdCxTvvgkgZtfL/Kj/SfeJKH+X7YWEyZMmDAdwpRM8ScO1HtHSbZ21jiLCRMmTJhOZ0qKebMD+66DuS15tqMXTbqYMGHChOlAplmrTXu0J0HyrJUnSRa3Y60y0JgwYcKE6UCmWeo2v3DkF4JNuTS/6Lz5NUyYMGHC9CCmG5Kh8aE+GyuH3qzlTTkTEyZMmDAdyHRXyJoQzFqC9qXK/EIz3EhMmDBhwnQU02wB+4tCm9htW13bBqDVrQETJkyYMH0Y02xCm+TsrDDZMm3C6WFGHBMmTJgwfRhTG47mk07eb1p5EuhZOfPNfDBhwoQJ0+FMs8O4TbbmCdxNwncG8RcHTJgwYcL0CKa7yn53IQ4P70XCuu4PwoQJEyZMH8+UH/l560weJOfL3i+1Ddff/BcTJkyYMB3IlC8+8c5/p92Y/OqQlzbz8B4TJkyYMJ3LlBf/8oA5P8hnMeasqJmM2EJjwoQJE6bPZ0qO9gRodhjPEribZO6w3QcTJkyYMD2CqQ3/2gTrZjNm6ePZ1eTNKJgwYcKE6XCmWZtL+922QSfZpHbbhiE6JkyYMGF6BFNemLwLKEfZH+rtBr9J8mLChAkTpgOZZvnMfTK3ranOCpazkmc0K0yYMGHCdAjTq3xmZPviaIuSfDcPvzFhwoQJ07lMbe9Kfty2BPnhnSO2486uEZgwYcKE6fOZkktAe+S35cY2rbxp9JmVSzFhwoQJ0+lMszaXTRjZJnnv+rXZpQcTJkyYMP0GpgSuDYDzpbZJ2z398EKACRMmTJgezTSDmLWQJmH5LFDHhAkTJkzPY2qTvG0wnIeaeSJ401RUh9OYMGHChOlYpjYB2h7YmzRxlH4t3yRwN+SJMWHChAnTv2f6D/6p5rg0E6OQAAAAAElFTkSuQmCC">分享</a><div class="tags"></div><div class="post-nav"><a class="pre" href="/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0/">计算机网络(自顶向下)第六章</a><a class="next" href="/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0/">计算机网络(自顶向下)第四章</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://yvenxx.github.io/yvenxx"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">6</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">数据库原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/Redis%E5%9F%BA%E7%A1%80/">Redis基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/">操作系统 第五章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0/">操作系统 第四章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/">操作系统-第三章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%8C%E7%AB%A0/">操作系统-第二章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%80%E7%AB%A0/">操作系统-第一章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%83%E7%AB%A0/">计算机组成原理-第七章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E5%85%AD%E7%AB%A0/">计算机组成原理-第六章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%94%E7%AB%A0/">计算机组成原理-第五章</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.yvenxx.cn/" title="懒人瑜恩" target="_blank">懒人瑜恩</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">懒人瑜恩.</a> Powered by Hexo.</div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>