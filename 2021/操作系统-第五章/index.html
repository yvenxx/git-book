<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="一些我的计算机笔记，JAVA/Python/Linux/后端/计算机基础">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        操作系统 第五章 - undefined
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.3.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> sometimes code, sometimes English </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/" />
        </div>
        <div class="name">
            <i>懒人瑜恩</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E8%AE%BE%E5%A4%87"><span class="toc-text">IO设备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-text">基本概念和分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-text">IO控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">IO控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">程序直接控制方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">中断驱动方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DMA%E6%96%B9%E5%BC%8F"><span class="toc-text">DMA方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">通道控制方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">IO软件层次结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-text">IO核心子系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-text">假脱机技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-text">设备的分配与回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-text">考虑的因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-text">静态&#x2F;动态分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">设备分配中的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E6%AD%A5%E9%AA%A4"><span class="toc-text">设备分配步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BC%93%E5%86%B2"><span class="toc-text">单缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="toc-text">双缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">循环缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-text">缓冲池</span></a></li></ol></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> sometimes code, sometimes English </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        操作系统 第五章
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2021-12-05 18:43:42</span></span>
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <a id="more"></a>

<h1 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h1><h2 id="基本概念和分类"><a href="#基本概念和分类" class="headerlink" title="基本概念和分类"></a>基本概念和分类</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118205440632.png" alt="image-20211118205440632"></p>
<h2 id="IO控制器"><a href="#IO控制器" class="headerlink" title="IO控制器"></a>IO控制器</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118210210053.png" alt="image-20211118210210053"></p>
<p><strong>机械部件</strong>：主要用来执行具体IO操作</p>
<p><strong>电子部件：</strong>通常是一块插入主板扩展槽的印刷电路板</p>
<p><strong>IO控制器（电子部件）</strong></p>
<p>CPU无法直接控制设备机械部件，需要通过IO控制器（设备控制器）</p>
<p>功能</p>
<ul>
<li>接受和识别CPU发出的命令（控制寄存器）</li>
<li>向CPU报告设备状态（状态寄存器）</li>
<li>数据交换（数据寄存器）</li>
<li>地址识别（类似于内存的地址），为了区分内部各个寄存器，会给他们设置特定地址</li>
</ul>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118205926032.png" alt="image-20211118205926032"></p>
<blockquote>
<p>小细节</p>
<ol>
<li>一个IO控制器可能会对应多个设备</li>
<li>数据寄存器，控制寄存器，状态寄存器可能有多个。有的计算机会让这些寄存器占用内存地址的一部分，称为<strong>内存映像IO</strong>；另一些计算机用IO专用地址，<strong>寄存器独立编织</strong></li>
</ol>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118210157110.png" alt="image-20211118210157110"></p>
</blockquote>
<h2 id="IO控制方式"><a href="#IO控制方式" class="headerlink" title="IO控制方式"></a>IO控制方式</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118210731830.png" alt="image-20211118210731830"></p>
<h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118210437961.png" alt="image-20211118210437961"></p>
<p><strong>读写操作的流程（轮询）</strong></p>
<ul>
<li>优点：实现简单。在读/写指令后，加上实现循环检查的一系列指令即可</li>
<li><strong>缺点：CPU和IO设备只能串行工作，CPU需要一直轮询检查，长期处于 “忙 等”状态，</strong>CPU利用率低</li>
<li>数据流向：读( IO –&gt;  CPU—-&gt; 内存)     写（内存—-&gt;CPU—-&gt;IO设备）</li>
</ul>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118210513353.png" alt="image-20211118210513353"></p>
<h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><p>引入<strong>中断机制</strong>，在CPU发出读写命令后，<strong>将等待IO的进程阻塞</strong>，切换到其他进程执行。当IO完成后，发出中断信号，<strong>CPU检测中断信号</strong>，去执行中断处理程序。CPU从IO控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，<strong>CPU恢复等待IO的进程（或其他进程）的运行环境，继续执行</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118210937368.png" alt="image-20211118210937368"></p>
<blockquote>
<ol>
<li>CPU会在每个指令周期的末尾检查中断</li>
<li>中断处理过程中需要保存、恢复进程的运行环境</li>
</ol>
</blockquote>
<ul>
<li>数据流向：读（IO —&gt; CPU—&gt; 内存） 写（内存—&gt; CPU—&gt;IO设备）</li>
<li>优点：CPU不需要轮询检查，<strong>可与IO设备并行工作</strong></li>
<li><strong>缺点：</strong>每个字在IO设备与内存之间的传输，都需要经过CPU。而<strong>频繁的中断处理会消耗较多的CPU时间</strong></li>
</ul>
<h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><p>与 “中断驱动方式”相比，DMA方式（直接存储器存取）。主要用于块设备的（IO控制）。改进如下</p>
<ol>
<li><strong>数据的传送单位是 “块”。</strong></li>
<li>数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU来进行传输</li>
<li>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</li>
</ol>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118211828323.png" alt="image-20211118211828323"></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118211836585.png" alt="image-20211118211836585"></p>
<ul>
<li>数据传送的单位：每次读入一个/多个块（每次读写的只能是连续的块，且这些块读入内存后在内存中也必须是连续的，如果要离散的块，就需要多次读写）</li>
<li>优点：数据传输以块为单位，CPU介入频率降低。数据传输不需要线经过CPU再进入内存。CPU和IO设备并行性得到提升</li>
<li><strong>缺点：</strong>CPU发出一条IO指令，只能读写一个或多个连续的数据块。如果读写多个离散存储的数据块，或者将数据写到不同的内存区域时，CPU要分别发出多条指令</li>
</ul>
<h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><p><strong>通道：一种硬件</strong>，组原 里面有这个解释。可以理解为小型的CPU，通道可以识别一系列<strong>通道指令</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118212128149.png" alt="image-20211118212128149"></p>
<p>数据传送单位：<strong>一组数据块</strong></p>
<p><strong>优点：CPU，通道，IO设备可以并行工作，资源利用率很高</strong></p>
<p>缺点：实现复杂，需要专门的通道硬件支持</p>
<h2 id="IO软件层次结构"><a href="#IO软件层次结构" class="headerlink" title="IO软件层次结构"></a>IO软件层次结构</h2><p>硬件上面，是IO软件的层次。每一层会利用其下层提供的服务，实现某些功能，并屏蔽实现的具体细节，向高层提供服务。</p>
<p><strong>重要的：设备独立性软件，设备驱动程序，中断处理程序。统称为IO系统 /  IO核心子系统</strong></p>
<ul>
<li><p>用户层：<strong>实现了与用户交互的借口</strong>，用户可直接使用该层提供的，与IO操作相关的库函数对设备进行操作（例如printf库函数）</p>
</li>
<li><p><strong>设备独立性软件：设备无关性软件</strong>。与设备的硬件特性无关的功能基本在这一层实现</p>
<ul>
<li><p>向上层提供统一的调用接口（read/write…..调用）</p>
</li>
<li><p>设备的保护</p>
</li>
<li><p>差错处理</p>
</li>
<li><p>设备的分配与回收</p>
</li>
<li><p>数据缓冲区管理</p>
</li>
<li><p>建立逻辑设备名到物理设备名的映射关系：根据设备类型选择调用相应的驱动程序</p>
<ul>
<li>逻辑设备表LUT（可以整个系统只设置一张LUT）</li>
<li>也可以为每个用户设置一张LUT</li>
</ul>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118212821828.png" alt="image-20211118212821828"></p>
</li>
</ul>
</li>
<li><p>设备驱动程序：主要负责对硬件设备的具体控制，将上层发出的一系列指令，转化为特定设备的”执行“ 的一系列操作。包括设置设备寄存器等</p>
</li>
<li><p>中断处理程序：当IO任务完成时，io控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序执行。</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118213136380.png" alt="image-20211118213136380"></p>
</li>
</ul>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118212430222.png" alt="image-20211118212430222"></p>
<h2 id="IO核心子系统"><a href="#IO核心子系统" class="headerlink" title="IO核心子系统"></a>IO核心子系统</h2><p>考研中，我们需要重点理解和掌握的功能是：I/O调度、设备保护、假脱机技术（SPOOLing技术）、设备分配与回收、缓冲区管理（即缓冲与高速缓存</p>
<p><strong>IO调度，设备保护</strong>，设备分配与回收、缓冲区管理。都是在IO核心子系统完成。</p>
<p>假脱机（SPOOLing技术）：实际是在用户层实现，但是考纲中 归为 IO核心子系统中</p>
<ul>
<li>IO调度：用某种算法确定一个顺序来处理IO请求，如前面磁盘调度的算法</li>
<li>设备保护：UNIX系统中，<strong>设备被看作是一种特殊的文件</strong>，每个设备也有对应的FCB。会根据访问权限来实现保护功能</li>
</ul>
<h2 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119091015737.png" alt="image-20211119091015737"></p>
<p>用软件的方式模拟脱机技术。批处理阶段引入了 <strong>脱机输入/脱机输出</strong>。</p>
<p>实现SPOOLing技术，<strong>必须要有多道程序技术的支持。</strong>系统会建立 “输入输出进程”</p>
<ul>
<li>输出缓冲区：暂存从输入设备输入的数据</li>
<li>输入缓冲区：暂存从输出井送来的数据</li>
</ul>
<blockquote>
<p>输入缓冲区和输出缓冲区是在内存中的缓冲区</p>
</blockquote>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119090250963.png" alt="image-20211119090250963"></p>
<p>独占式设备：<strong>只允许各个进程串行使用的设备。</strong>一段时间内只能满足一个进程需要</p>
<p>共享设备：<strong>允许多个进程 “同时” 使用的设备</strong>（微观上可能与CPU一样，交替运行）</p>
<p>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备。</p>
<h2 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119094424849.png" alt="image-20211119094424849"></p>
<h3 id="考虑的因素"><a href="#考虑的因素" class="headerlink" title="考虑的因素"></a>考虑的因素</h3><ol>
<li>独占，共享，虚拟设备</li>
<li>设备分配算法（先来先服务，优先级高者优先……</li>
<li>设备分配的安全性<ul>
<li>安全分配方式：为进程分配一个设备后将进程阻塞，本次IO完成后才将进程唤醒</li>
<li>不安全分配方式：进程发出IO请求后，系统为其分配IO设备，进程可继续执行，还可发出新的IO请求。只有某个IO请求得不到满足时才将进程阻塞。</li>
</ul>
</li>
</ol>
<h3 id="静态-动态分配"><a href="#静态-动态分配" class="headerlink" title="静态/动态分配"></a>静态/动态分配</h3><p>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源（不会发生死锁）</p>
<p>动态分配：进程运行过程中动态申请设备资源</p>
<h3 id="设备分配中的数据结构"><a href="#设备分配中的数据结构" class="headerlink" title="设备分配中的数据结构"></a>设备分配中的数据结构</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119091810922.png" alt="image-20211119091810922"></p>
<p><strong>–设备控制表DCT–</strong></p>
<p>系统为每个设备配置一张DCT，用于记录设备情况</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119091909278.png" alt="image-20211119091909278"></p>
<p><strong>–控制器控制表（COCT）–</strong></p>
<p>每个设备都会对应一张COCT，操作系统根据COCT的信息对控制器进行操作和管理。</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119092146712.png" alt="image-20211119092146712"></p>
<p><strong>–通道控制表CHCT–</strong></p>
<p>每个通道对应一张CHCT，操作系统根据CHCT的信息对通道进行管理</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119092257070.png" alt="image-20211119092257070"></p>
<p><strong>–系统设备表SDT–</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119092558200.png" alt="image-20211119092558200"></p>
<h3 id="设备分配步骤"><a href="#设备分配步骤" class="headerlink" title="设备分配步骤"></a>设备分配步骤</h3><ol>
<li>根据进程请求的<strong>物理设备名</strong>查找SDT（物理设备名是进程请求分配设备时提供的参数）</li>
<li>根据SDT找到DCT，若<strong>设备</strong>忙碌则将进程PCB挂到<strong>设备等待队列</strong>中，不忙碌则将<strong>设备</strong>分配给进程</li>
<li>根据DCT找到COCT，若<strong>控制器</strong>忙碌则将进程PCB挂到<strong>控制器等待队列</strong>，不忙碌则将<strong>控制器</strong>分配给进程</li>
<li>根据COCT找到CHCT，若<strong>通道</strong>忙碌则将进程PCB挂到<strong>通道等待队列</strong>中，不忙碌则将<strong>通道</strong>分配给进程</li>
</ol>
<p>缺点：</p>
<ul>
<li>用户编程时必须使用 “物理设备名” ，低层细节对用户不透明，不方便编程</li>
<li>若换了一个物理设备，程序无法运行</li>
<li>若进程亲求的物理设备正在忙碌，则即使系统中还有同类型空闲设备，进程也必须阻塞等待</li>
</ul>
<p>改进</p>
<p>上面第一步，改为，根据进程请求的<strong>逻辑设备名</strong>查找SDT（逻辑设备名实际就是设备类型）</p>
<p><strong>逻辑设备表（LUT）建立了逻辑设备名和物理设备名之间的映射关系。</strong></p>
<p>某用户进程第一次使用逻辑设备名向系统发请求，查找系统设备表，分配给进程，并在LUT中增加相应表项。</p>
<p><strong>之后用户进程再次通过相同的逻辑设备名请求使用设备。则操作系统通过LUT表即可知道用户进程实际要使用哪个物理设备，也能知道该设备的驱动程序入口地址。</strong></p>
<p>整个系统只有一张LUT / 每个用户都有一张LUT。</p>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119132128642.png" alt="image-20211119132128642"></p>
<p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区</p>
<p>使用<strong>硬件作为缓冲区</strong>的<strong>成本较高，容量也较小</strong>。一般情况下，更多的是利用<strong>内存作为缓冲区</strong>，”设备独立性软件“ 的缓冲区管理就是要组织管理好这些缓冲区。</p>
<p>缓冲区的作用</p>
<ul>
<li><strong>缓和CPU与IO设备之间速度不匹配的矛盾</strong></li>
<li><strong>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</strong></li>
<li><strong>解决数据粒度不匹配的问题</strong></li>
<li><strong>提高CPU与IO设备之间的并行性</strong></li>
</ul>
<p>CPU可以把要输出的数据快速的放入缓冲区，之后就可以做别的事情。</p>
<h3 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h3><p>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>单缓冲</strong>的策略，操作系统会<strong>在主存中为其分配一个缓冲区</strong>（若题目中没有特别说明，一个缓冲区的大小就是一个块）</p>
<p><strong>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出</strong>。</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119130759284.png" alt="image-20211119130759284"></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119131006073.png" alt="image-20211119131006073"></p>
<p><strong>采用单缓冲策略，处理一块数据平均耗时 Max（C,T)+M</strong></p>
<h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p>若采用<strong>双缓冲</strong>的策略，操作系统会<strong>在主存中为其分配两个缓冲区</strong></p>
<p>双缓冲题目中，假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空。</p>
<p><strong>假设 T&gt;C+M</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119131522261.png" alt="image-20211119131522261"></p>
<p><strong>假设T&lt;C+M</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119131545212.png" alt="image-20211119131545212"></p>
<p><strong>结论：采用双缓冲策略，处理一个数据块的平均耗时为Max（T,C+M）</strong></p>
<h3 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h3><p>将多个<strong>大小相等</strong>的缓冲区链接称一个<strong>循环队列</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119131713433.png" alt="image-20211119131713433"></p>
<h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>由系统中共用的缓冲区组成。</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119132047583.png" alt="image-20211119132047583"></p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.xml"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
