<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="懒人瑜恩/JAVA/Python/Linux/后端"><title>数据结构-图-笔记 | 懒人瑜恩</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '2059a4484fb666484cf5e9fba7e20ce6';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">数据结构-图-笔记</h1><a id="logo" href="/.">懒人瑜恩</a><p class="description">sometimes code, sometimes English</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/history/"><i class="fa fa-book"> 历史</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">数据结构-图-笔记</h1><div class="post-meta">2021-09-25<span> | </span><span class="category"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">2.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88Depth-First-Search%EF%BC%8CDFS%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">深度优先搜索（Depth First Search，DFS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88Breadth-First-Search%EF%BC%8CBFS%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">广度优先搜索（Breadth First Search，BFS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E4%B8%8D%E8%BF%9E%E9%80%9A%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">4.3.</span> <span class="toc-text">图不连通的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-number">4.3.1.</span> <span class="toc-text">无向图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">4.3.2.</span> <span class="toc-text">有向图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5-1"><span class="toc-number">5.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8-1"><span class="toc-number">5.2.</span> <span class="toc-text">邻接表</span></a></li></ol></li></ol></div></div><div class="post-content"><a id="more"></a>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>图：表示“多对多”的关系</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210925094453444.png" alt="image-20210925094453444"></p>
<p>顶点：通常用 V（Vertex）表示顶点集合</p>
<p>边：通常用E(Edge)表示边的集合</p>
<ul>
<li>边是顶点对 :无向边 (a,b)  a——b</li>
<li>有向边 &lt;a,b&gt; 表示从a指向b的边  （单行线） a—-&gt;b</li>
</ul>
<blockquote>
<p>不考虑重边（例如有向边两个顶点只有一条）和自回路（不会有自己到自己的边）</p>
</blockquote>
<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>利用<strong>邻接矩阵</strong>，来用一维数组存储图，就可以只用存储红色的部分。</p>
<p>在下面的图里，我们要找的是3列6行的元素。在数组中对应的下标为</p>
<p>(i * ( i + 2 ) ) / 2 + j ) </p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210925134051486.png" alt="image-20210925134051486"></p>
<p>邻接矩阵的优点</p>
<ol>
<li>直观，简单，方便检查任意一对顶点间是否存在边</li>
<li>方便找任一顶点的所有“邻接点”（有边直接相连的顶点）</li>
<li>方便计算任一节点的 “度” （从该点出发的边数为“出度”，指向该点的边数为“入度”<ul>
<li>无向图：对应行（列）的非0元素的个数</li>
<li>有向图：对应行非0元素的个数是“出度”，对应列非0元素的个数是“入度”</li>
</ul>
</li>
</ol>
<p><strong>缺点</strong></p>
<ul>
<li>浪费空间—存储稀疏的时候，有大量无效元素，但是如果稠密的话，就不会有这个问题</li>
<li>浪费时间—统计稀疏图中一共有多少边</li>
</ul>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>G[n]为指针数组，对应矩阵每行一个链表，存非零元素</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210925135626928.png" alt="image-20210925135626928"></p>
<p>方便找任一顶点所有的“邻接点”</p>
<p>节约稀疏图的空间</p>
<p>无向图：方便计算度</p>
<p>有向图：只能计算“出度”，入度需要构造“逆邻接表”来计算入度</p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先搜索（Depth-First-Search，DFS）"><a href="#深度优先搜索（Depth-First-Search，DFS）" class="headerlink" title="深度优先搜索（Depth First Search，DFS）"></a>深度优先搜索（Depth First Search，DFS）</h3><p><strong>时间复杂度</strong>(N为顶点个数，E为边的个数)</p>
<ul>
<li>用邻接表存储图，有o(N+E)</li>
<li>用邻接矩阵存储图，有O(N^2)</li>
</ul>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210925142830720.png" alt="image-20210925142830720"></p>
<p>从白方块那里设为入口，设为黄色，在视野内有三个节点没走过。走其中一个节点那边去，也设为黄色。以此类推，走到视野中没有没去过的节点，一个一个原路返回，看看还有没有没走过的节点。有就继续进入。直到回到初始位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 邻接表存储的图 - DFS */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">( Vertex V )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在访问顶点%d\n&quot;</span>, V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Visited[]为全局变量，已经初始化为false */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">( LGraph Graph, Vertex V, <span class="keyword">void</span> (*Visit)(Vertex) )</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 以V为出发点对邻接表存储的图Graph进行DFS搜索 */</span></span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    </span><br><span class="line">    Visit( V ); <span class="comment">/* 访问第V个顶点 */</span></span><br><span class="line">    Visited[V] = <span class="literal">true</span>; <span class="comment">/* 标记V已访问 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) <span class="comment">/* 对V的每个邻接点W-&gt;AdjV */</span></span><br><span class="line">        <span class="keyword">if</span> ( !Visited[W-&gt;AdjV] )    <span class="comment">/* 若W-&gt;AdjV未被访问 */</span></span><br><span class="line">            DFS( Graph, W-&gt;AdjV, Visit );    <span class="comment">/* 则递归访问之 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="广度优先搜索（Breadth-First-Search，BFS）"><a href="#广度优先搜索（Breadth-First-Search，BFS）" class="headerlink" title="广度优先搜索（Breadth First Search，BFS）"></a>广度优先搜索（Breadth First Search，BFS）</h3><p><strong>时间复杂度</strong>(N为顶点个数，E为边的个数)</p>
<ul>
<li>用邻接表存储图，有O(N+E)</li>
<li>用邻接矩阵存储图，有O(N^2)</li>
</ul>
<p>这是遍历的图，并非是图的存储结构</p>
<p>中心节点进入队列进行标示，然后出队，查看他的其他几条边，把几个顶点都入队并且标示，然后依次出队，重复操作。</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210925143834719.png" alt="image-20210925143834719"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 邻接矩阵存储的图 - BFS */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* IsEdge(Graph, V, W)检查&lt;V, W&gt;是否图Graph中的一条边，即W是否V的邻接点。  */</span></span><br><span class="line"><span class="comment">/* 此函数根据图的不同类型要做不同的实现，关键取决于对不存在的边的表示方法。*/</span></span><br><span class="line"><span class="comment">/* 例如对有权图, 如果不存在的边被初始化为INFINITY, 则函数实现如下:         */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEdge</span><span class="params">( MGraph Graph, Vertex V, Vertex W )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Graph-&gt;G[V][W]&lt;INFINITY ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Visited[]为全局变量，已经初始化为false */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span> <span class="params">( MGraph Graph, Vertex S, <span class="keyword">void</span> (*Visit)(Vertex) )</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索 */</span></span><br><span class="line">    Queue Q;     </span><br><span class="line">    Vertex V, W;</span><br><span class="line"></span><br><span class="line">    Q = CreateQueue( MaxSize ); <span class="comment">/* 创建空队列, MaxSize为外部定义的常数 */</span></span><br><span class="line">    <span class="comment">/* 访问顶点S：此处可根据具体访问需要改写 */</span></span><br><span class="line">    Visit( S );</span><br><span class="line">    Visited[S] = <span class="literal">true</span>; <span class="comment">/* 标记S已访问 */</span></span><br><span class="line">    AddQ(Q, S); <span class="comment">/* S入队列 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( !IsEmpty(Q) ) &#123;</span><br><span class="line">        V = DeleteQ(Q);  <span class="comment">/* 弹出V */</span></span><br><span class="line">        <span class="keyword">for</span>( W=<span class="number">0</span>; W&lt;Graph-&gt;Nv; W++ ) <span class="comment">/* 对图中的每个顶点W */</span></span><br><span class="line">            <span class="comment">/* 若W是V的邻接点并且未访问过 */</span></span><br><span class="line">            <span class="keyword">if</span> ( !Visited[W] &amp;&amp; IsEdge(Graph, V, W) ) &#123;</span><br><span class="line">                <span class="comment">/* 访问顶点W */</span></span><br><span class="line">                Visit( W );</span><br><span class="line">                Visited[W] = <span class="literal">true</span>; <span class="comment">/* 标记W已访问 */</span></span><br><span class="line">                AddQ(Q, W); <span class="comment">/* W入队列 */</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="comment">/* while结束*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="图不连通的情况"><a href="#图不连通的情况" class="headerlink" title="图不连通的情况"></a>图不连通的情况</h3><p><strong>连通</strong>：如果v到w存在一条（无向）<strong>路径</strong>，则称v和w连通。</p>
<p><strong>路径</strong>：v到w的路径是一系列的顶点（v，v1，v2，v3…..vn，w)的集合。其中任一对相邻的顶点间都有图中的边。<strong>路径的长度</strong>是路径中的边数。如果v到w之间的所有顶点都不同，称为<strong>简单路径</strong>。非简单路径就是有回路的。</p>
<p><strong>回路</strong>：起点等于终点的路径</p>
<p><strong>连通图</strong>：图中任意两顶点均连通</p>
<h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><p><strong>连通分量</strong>：无向图的<strong>极大</strong>连通子图</p>
<ul>
<li>极大顶点数：再加1个顶点就不连通了</li>
<li>极大边数：包含子图中所有顶点相连的所有边</li>
<li>例</li>
</ul>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210925145633349.png" alt="image-20210925145633349"></p>
<h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><p><strong>强连通：</strong>有向图中顶点v和w之间存在双向路径，则称v和w是强连通的</p>
<p><strong>强连通图：</strong>有向图中任意两顶点均强连通</p>
<p><strong>强连通分量：</strong>有向图的极大强连通子图</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20210925145925936.png" alt="image-20210925145925936"></p>
<p>这里后面两个图都是强连通图。</p>
<p>代码实现</p>
<p>原理：遍历DFS，然后图不连通的部分，因为这个程序会遍历图，所以不存在遍历不到的情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">ListComponents</span>(<span class="params">Graph G</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(each V <span class="keyword">in</span> G)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">			DFS(V); <span class="comment">/*or BFS(V)*/</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="邻接矩阵-1"><a href="#邻接矩阵-1" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p><strong>数据类型 - 图 - 边</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode MGraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> *<span class="title">PtrToENode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToENode Edge;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;<span class="comment">//顶点数</span></span><br><span class="line">    <span class="keyword">int</span> Ne;<span class="comment">//边数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> G[MaxVertexNum][MaxVertexNum]; <span class="comment">//描述边</span></span><br><span class="line">    <span class="keyword">char</span> data[MaxVertexNum];  <span class="comment">//数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>&#123;</span></span><br><span class="line">    Vertex V1,V2;</span><br><span class="line">    <span class="keyword">int</span> Weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>数据类型 - 方法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图初始化</span></span><br><span class="line"><span class="function">MGraph <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> VertexNum)</span></span>&#123;</span><br><span class="line">    Vertex V,W;</span><br><span class="line">    MGraph Graph;</span><br><span class="line"></span><br><span class="line">    Graph = (MGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认从0开始</span></span><br><span class="line">    <span class="keyword">for</span>(V=<span class="number">0</span>; V&lt;Graph-&gt;Nv;V++)&#123;</span><br><span class="line">        <span class="keyword">for</span> ( W = <span class="number">0</span>; W &lt; Graph-&gt;Nv; W++)</span><br><span class="line">        &#123;</span><br><span class="line">            Graph-&gt;G[V][W] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向MGraph插入边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(MGraph Graph,Edge e)</span></span>&#123;</span><br><span class="line">    Graph-&gt;G[e-&gt;V1][e-&gt;V2]=e-&gt;Weight;</span><br><span class="line">    Graph-&gt;G[e-&gt;V2][e-&gt;V1]=e-&gt;Weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完整的建立图</span></span><br><span class="line"><span class="function">MGraph <span class="title">BuildGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    <span class="keyword">int</span> Nv,i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数 &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Nv);</span><br><span class="line">    Graph = CreateGraph(Nv);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入边的数量 &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Graph-&gt;Ne);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Graph-&gt;Ne!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        E = (Edge)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; Graph-&gt;Ne; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入边的V1,V2,Weight &quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight);</span><br><span class="line">            InsertEdge(Graph,E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( V = <span class="number">0</span>; V &lt; Graph-&gt;Nv; V++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入数据 &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c &quot;</span>,&amp;Graph-&gt;data[V]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="邻接表-1"><a href="#邻接表-1" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表有向图，因为无向图实现需要令起一个。所以就有向图进行实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Vertex data;</span><br><span class="line">    Edge next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Edge next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> <span class="title">AdjList</span>[<span class="title">MaxVertexNum</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjMatrix</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AdjMatrix</span>&#123;</span></span><br><span class="line">    AdjList adjList;</span><br><span class="line">    <span class="keyword">int</span> Nv,Ne;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode Graph;</span><br><span class="line"></span><br><span class="line"><span class="function">Graph <span class="title">createGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Graph G;</span><br><span class="line">    Edge edge;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    G = (Graph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AdjMatrix));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;顶点数nv 边数Ne &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;G-&gt;Nv,&amp;G-&gt;Ne);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; G-&gt;Nv; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顶点数据&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;data);</span><br><span class="line">        G-&gt;adjList[i].data=data;</span><br><span class="line">        G-&gt;adjList[i].next=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;边&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; G-&gt;Ne; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp,EdgeData;</span><br><span class="line">        <span class="comment">//顶点加入边</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入的边&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入的边数据&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;EdgeData);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//头插入</span></span><br><span class="line">        edge = (Edge*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Edge));</span><br><span class="line">        edge-&gt;data=EdgeData;</span><br><span class="line"></span><br><span class="line">        edge-&gt;next=G-&gt;adjList[temp].next;</span><br><span class="line">        G-&gt;adjList[temp].next=edge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Graph G = createGraph();</span><br><span class="line">    <span class="comment">//未写遍历</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><p><span>本文标题：</span>数据结构-图-笔记</p><p><span>文章作者：</span>懒人瑜恩</p><p><span>发布时间：</span>2021-09-25</p><p><span>最后更新：</span>2021-09-29</p><p><span>原始链接：</span><a href="/2021/数据结构-图-笔记/">https://yvenxx.github.io/yvenxx/2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE-%E7%AC%94%E8%AE%B0/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://yvenxx.github.io/yvenxx/2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE-%E7%AC%94%E8%AE%B0/"></i></span></p><p><span>版权声明：</span>版权所有，转载请注明出处。</p></div><br><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://yvenxx.github.io/yvenxx/2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE-%E7%AC%94%E8%AE%B0/" data-id="cku580hhd00095ku3a6msax3q" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADH0lEQVR42u3ay27jQAwEwPz/T2eBnHII7G5SWUSj0smwrUdNgLSH5MdHfHx+Hd9ff3/n9fdnn74+8idZHdjY2Ng3Yec3yJcgedDkrOQKyac/LA02Njb2cew8tGY3y5GvsyZ5zigysbGxsR/Jnm0A8o1EG2zY2NjY2LMAm8Hac/PvYGNjY2NvSjnFbcpl3b9zWS0NGxsb+8+zZ43ev/n61/vb2NjY2H+M/VkebaGnbeXOwqZWYGNjYx/Eft2C/Y15xbyFnC9Esjn5SHZL2NjY2Ddk7wdrrt39zEIxbxX8kNvY2NjYN2dvRnCSKPqNJkQ7AISNjY39BHbyK/2qck+7T5q1BOpnxsbGxr4tOy8JzdayDar2LrNmBjY2NvZJ7FkAJFGUh1byiG0LARsbG/uZ7HbLMWv3ziIqWaY8GrGxsbFPYs+CYT9G087PJNFYBCo2Njb2w9j5//y2WZsX+tsS1Zsww8bGxj6InYy25IX7/HWyqWhDsV16bGxs7JPYsyGbGW/fPG6vj42Njf0EdvvjPgmbTROiXYJhoQobGxv7CHZesm8LRvsSVRtRxR8DGxsb+1D2rHiUz3VuykzJp0WDGRsbG/sg9mYUcjMcmTcD8nNn4YeNjY19d/b/Ke5fFV3587xZOGxsbOyD2LNwam+fX2FzneHIDjY2NvYD2JumbH5WC26D6s2MEjY2NvbN2XmctO+3BaD8mm0nFxsbG/uZ7Latm7PbNvC1i46NjY19Ejv/+d7+0M8jKo+r/VjPm64INjY29kHs1w+U37ht625KUcUzY2NjYx/EnrVON+3b2XXy7U2xjcHGxsY+gt1uAGYxdm1QbVoI2NjY2Key21J+215ti1D5XYbfxMbGxj6OnR8Jr91CtIM+syUu9l7Y2NjYt2Jvwikfl5k1GzbFo334YWNjY9+LPQutWfM1521CNIoubGxs7OPYeZGoLSS177dLljQ2sLGxsbHbEs+sSBQNTcah+8aIjY2Njb0YypkVrfIhoahdgY2NjX0cOyni5MX3vOF61ahl3YrAxsbGPoi9CZj9udc2HvKzsLGxsY9g/wNpAfOHgzRaqwAAAABJRU5ErkJggg==">分享</a><div class="tags"></div><div class="post-nav"><a class="pre" href="/2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%BF%E4%B9%89%E8%A1%A8/">数据结构-广义表</a><a class="next" href="/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0/">计算机网络(自顶向下)第一章</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://yvenxx.github.io/yvenxx"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0/">计算机网络(自顶向下)第三章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0/">计算机网络(自顶向下)第二章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%BF%E4%B9%89%E8%A1%A8/">数据结构-广义表</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE-%E7%AC%94%E8%AE%B0/">数据结构-图-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0/">计算机网络(自顶向下)第一章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E7%AC%94%E8%AE%B0/">数据结构-树-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/Android-%E9%A1%B6%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F/">Android 顶部导航栏</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/Java-IO%E6%B5%81/">Java IO流</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/Centos7-%E5%AE%89%E8%A3%85python3-x/">Centos7 安装python3.x</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E6%8C%87%E9%92%88/">C语言：指针</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.yvenxx.cn/" title="懒人瑜恩" target="_blank">懒人瑜恩</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">懒人瑜恩.</a> Powered by Hexo.</div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>