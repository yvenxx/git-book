<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一些我的计算机笔记，JAVA/Python/Linux/后端/计算机基础"><title>操作系统 第五章 | 懒人瑜恩</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '2059a4484fb666484cf5e9fba7e20ce6';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">操作系统 第五章</h1><a id="logo" href="/.">懒人瑜恩</a><p class="description">sometimes code, sometimes English</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/history/"><i class="fa fa-book"> 历史</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">操作系统 第五章</h1><div class="post-meta">2021-12-05<span> | </span><span class="category"><a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E8%AE%BE%E5%A4%87"><span class="toc-number">1.</span> <span class="toc-text">IO设备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念和分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">IO控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">IO控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">程序直接控制方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">中断驱动方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DMA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">DMA方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.4.</span> <span class="toc-text">通道控制方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">IO软件层次结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.</span> <span class="toc-text">IO核心子系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">1.6.</span> <span class="toc-text">假脱机技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">1.7.</span> <span class="toc-text">设备的分配与回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-number">1.7.1.</span> <span class="toc-text">考虑的因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">1.7.2.</span> <span class="toc-text">静态&#x2F;动态分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.3.</span> <span class="toc-text">设备分配中的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.7.4.</span> <span class="toc-text">设备分配步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.8.</span> <span class="toc-text">缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BC%93%E5%86%B2"><span class="toc-number">1.8.1.</span> <span class="toc-text">单缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="toc-number">1.8.2.</span> <span class="toc-text">双缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.8.3.</span> <span class="toc-text">循环缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-number">1.8.4.</span> <span class="toc-text">缓冲池</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><a id="more"></a>

<h1 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h1><h2 id="基本概念和分类"><a href="#基本概念和分类" class="headerlink" title="基本概念和分类"></a>基本概念和分类</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118205440632.png" alt="image-20211118205440632"></p>
<h2 id="IO控制器"><a href="#IO控制器" class="headerlink" title="IO控制器"></a>IO控制器</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118210210053.png" alt="image-20211118210210053"></p>
<p><strong>机械部件</strong>：主要用来执行具体IO操作</p>
<p><strong>电子部件：</strong>通常是一块插入主板扩展槽的印刷电路板</p>
<p><strong>IO控制器（电子部件）</strong></p>
<p>CPU无法直接控制设备机械部件，需要通过IO控制器（设备控制器）</p>
<p>功能</p>
<ul>
<li>接受和识别CPU发出的命令（控制寄存器）</li>
<li>向CPU报告设备状态（状态寄存器）</li>
<li>数据交换（数据寄存器）</li>
<li>地址识别（类似于内存的地址），为了区分内部各个寄存器，会给他们设置特定地址</li>
</ul>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118205926032.png" alt="image-20211118205926032"></p>
<blockquote>
<p>小细节</p>
<ol>
<li>一个IO控制器可能会对应多个设备</li>
<li>数据寄存器，控制寄存器，状态寄存器可能有多个。有的计算机会让这些寄存器占用内存地址的一部分，称为<strong>内存映像IO</strong>；另一些计算机用IO专用地址，<strong>寄存器独立编织</strong></li>
</ol>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118210157110.png" alt="image-20211118210157110"></p>
</blockquote>
<h2 id="IO控制方式"><a href="#IO控制方式" class="headerlink" title="IO控制方式"></a>IO控制方式</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118210731830.png" alt="image-20211118210731830"></p>
<h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118210437961.png" alt="image-20211118210437961"></p>
<p><strong>读写操作的流程（轮询）</strong></p>
<ul>
<li>优点：实现简单。在读/写指令后，加上实现循环检查的一系列指令即可</li>
<li><strong>缺点：CPU和IO设备只能串行工作，CPU需要一直轮询检查，长期处于 “忙 等”状态，</strong>CPU利用率低</li>
<li>数据流向：读( IO –&gt;  CPU—-&gt; 内存)     写（内存—-&gt;CPU—-&gt;IO设备）</li>
</ul>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118210513353.png" alt="image-20211118210513353"></p>
<h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><p>引入<strong>中断机制</strong>，在CPU发出读写命令后，<strong>将等待IO的进程阻塞</strong>，切换到其他进程执行。当IO完成后，发出中断信号，<strong>CPU检测中断信号</strong>，去执行中断处理程序。CPU从IO控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，<strong>CPU恢复等待IO的进程（或其他进程）的运行环境，继续执行</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118210937368.png" alt="image-20211118210937368"></p>
<blockquote>
<ol>
<li>CPU会在每个指令周期的末尾检查中断</li>
<li>中断处理过程中需要保存、恢复进程的运行环境</li>
</ol>
</blockquote>
<ul>
<li>数据流向：读（IO —&gt; CPU—&gt; 内存） 写（内存—&gt; CPU—&gt;IO设备）</li>
<li>优点：CPU不需要轮询检查，<strong>可与IO设备并行工作</strong></li>
<li><strong>缺点：</strong>每个字在IO设备与内存之间的传输，都需要经过CPU。而<strong>频繁的中断处理会消耗较多的CPU时间</strong></li>
</ul>
<h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><p>与 “中断驱动方式”相比，DMA方式（直接存储器存取）。主要用于块设备的（IO控制）。改进如下</p>
<ol>
<li><strong>数据的传送单位是 “块”。</strong></li>
<li>数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU来进行传输</li>
<li>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</li>
</ol>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118211828323.png" alt="image-20211118211828323"></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118211836585.png" alt="image-20211118211836585"></p>
<ul>
<li>数据传送的单位：每次读入一个/多个块（每次读写的只能是连续的块，且这些块读入内存后在内存中也必须是连续的，如果要离散的块，就需要多次读写）</li>
<li>优点：数据传输以块为单位，CPU介入频率降低。数据传输不需要线经过CPU再进入内存。CPU和IO设备并行性得到提升</li>
<li><strong>缺点：</strong>CPU发出一条IO指令，只能读写一个或多个连续的数据块。如果读写多个离散存储的数据块，或者将数据写到不同的内存区域时，CPU要分别发出多条指令</li>
</ul>
<h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><p><strong>通道：一种硬件</strong>，组原 里面有这个解释。可以理解为小型的CPU，通道可以识别一系列<strong>通道指令</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118212128149.png" alt="image-20211118212128149"></p>
<p>数据传送单位：<strong>一组数据块</strong></p>
<p><strong>优点：CPU，通道，IO设备可以并行工作，资源利用率很高</strong></p>
<p>缺点：实现复杂，需要专门的通道硬件支持</p>
<h2 id="IO软件层次结构"><a href="#IO软件层次结构" class="headerlink" title="IO软件层次结构"></a>IO软件层次结构</h2><p>硬件上面，是IO软件的层次。每一层会利用其下层提供的服务，实现某些功能，并屏蔽实现的具体细节，向高层提供服务。</p>
<p><strong>重要的：设备独立性软件，设备驱动程序，中断处理程序。统称为IO系统 /  IO核心子系统</strong></p>
<ul>
<li><p>用户层：<strong>实现了与用户交互的借口</strong>，用户可直接使用该层提供的，与IO操作相关的库函数对设备进行操作（例如printf库函数）</p>
</li>
<li><p><strong>设备独立性软件：设备无关性软件</strong>。与设备的硬件特性无关的功能基本在这一层实现</p>
<ul>
<li><p>向上层提供统一的调用接口（read/write…..调用）</p>
</li>
<li><p>设备的保护</p>
</li>
<li><p>差错处理</p>
</li>
<li><p>设备的分配与回收</p>
</li>
<li><p>数据缓冲区管理</p>
</li>
<li><p>建立逻辑设备名到物理设备名的映射关系：根据设备类型选择调用相应的驱动程序</p>
<ul>
<li>逻辑设备表LUT（可以整个系统只设置一张LUT）</li>
<li>也可以为每个用户设置一张LUT</li>
</ul>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118212821828.png" alt="image-20211118212821828"></p>
</li>
</ul>
</li>
<li><p>设备驱动程序：主要负责对硬件设备的具体控制，将上层发出的一系列指令，转化为特定设备的”执行“ 的一系列操作。包括设置设备寄存器等</p>
</li>
<li><p>中断处理程序：当IO任务完成时，io控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序执行。</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118213136380.png" alt="image-20211118213136380"></p>
</li>
</ul>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211118212430222.png" alt="image-20211118212430222"></p>
<h2 id="IO核心子系统"><a href="#IO核心子系统" class="headerlink" title="IO核心子系统"></a>IO核心子系统</h2><p>考研中，我们需要重点理解和掌握的功能是：I/O调度、设备保护、假脱机技术（SPOOLing技术）、设备分配与回收、缓冲区管理（即缓冲与高速缓存</p>
<p><strong>IO调度，设备保护</strong>，设备分配与回收、缓冲区管理。都是在IO核心子系统完成。</p>
<p>假脱机（SPOOLing技术）：实际是在用户层实现，但是考纲中 归为 IO核心子系统中</p>
<ul>
<li>IO调度：用某种算法确定一个顺序来处理IO请求，如前面磁盘调度的算法</li>
<li>设备保护：UNIX系统中，<strong>设备被看作是一种特殊的文件</strong>，每个设备也有对应的FCB。会根据访问权限来实现保护功能</li>
</ul>
<h2 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119091015737.png" alt="image-20211119091015737"></p>
<p>用软件的方式模拟脱机技术。批处理阶段引入了 <strong>脱机输入/脱机输出</strong>。</p>
<p>实现SPOOLing技术，<strong>必须要有多道程序技术的支持。</strong>系统会建立 “输入输出进程”</p>
<ul>
<li>输出缓冲区：暂存从输入设备输入的数据</li>
<li>输入缓冲区：暂存从输出井送来的数据</li>
</ul>
<blockquote>
<p>输入缓冲区和输出缓冲区是在内存中的缓冲区</p>
</blockquote>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119090250963.png" alt="image-20211119090250963"></p>
<p>独占式设备：<strong>只允许各个进程串行使用的设备。</strong>一段时间内只能满足一个进程需要</p>
<p>共享设备：<strong>允许多个进程 “同时” 使用的设备</strong>（微观上可能与CPU一样，交替运行）</p>
<p>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备。</p>
<h2 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119094424849.png" alt="image-20211119094424849"></p>
<h3 id="考虑的因素"><a href="#考虑的因素" class="headerlink" title="考虑的因素"></a>考虑的因素</h3><ol>
<li>独占，共享，虚拟设备</li>
<li>设备分配算法（先来先服务，优先级高者优先……</li>
<li>设备分配的安全性<ul>
<li>安全分配方式：为进程分配一个设备后将进程阻塞，本次IO完成后才将进程唤醒</li>
<li>不安全分配方式：进程发出IO请求后，系统为其分配IO设备，进程可继续执行，还可发出新的IO请求。只有某个IO请求得不到满足时才将进程阻塞。</li>
</ul>
</li>
</ol>
<h3 id="静态-动态分配"><a href="#静态-动态分配" class="headerlink" title="静态/动态分配"></a>静态/动态分配</h3><p>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源（不会发生死锁）</p>
<p>动态分配：进程运行过程中动态申请设备资源</p>
<h3 id="设备分配中的数据结构"><a href="#设备分配中的数据结构" class="headerlink" title="设备分配中的数据结构"></a>设备分配中的数据结构</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119091810922.png" alt="image-20211119091810922"></p>
<p><strong>–设备控制表DCT–</strong></p>
<p>系统为每个设备配置一张DCT，用于记录设备情况</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119091909278.png" alt="image-20211119091909278"></p>
<p><strong>–控制器控制表（COCT）–</strong></p>
<p>每个设备都会对应一张COCT，操作系统根据COCT的信息对控制器进行操作和管理。</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119092146712.png" alt="image-20211119092146712"></p>
<p><strong>–通道控制表CHCT–</strong></p>
<p>每个通道对应一张CHCT，操作系统根据CHCT的信息对通道进行管理</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119092257070.png" alt="image-20211119092257070"></p>
<p><strong>–系统设备表SDT–</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119092558200.png" alt="image-20211119092558200"></p>
<h3 id="设备分配步骤"><a href="#设备分配步骤" class="headerlink" title="设备分配步骤"></a>设备分配步骤</h3><ol>
<li>根据进程请求的<strong>物理设备名</strong>查找SDT（物理设备名是进程请求分配设备时提供的参数）</li>
<li>根据SDT找到DCT，若<strong>设备</strong>忙碌则将进程PCB挂到<strong>设备等待队列</strong>中，不忙碌则将<strong>设备</strong>分配给进程</li>
<li>根据DCT找到COCT，若<strong>控制器</strong>忙碌则将进程PCB挂到<strong>控制器等待队列</strong>，不忙碌则将<strong>控制器</strong>分配给进程</li>
<li>根据COCT找到CHCT，若<strong>通道</strong>忙碌则将进程PCB挂到<strong>通道等待队列</strong>中，不忙碌则将<strong>通道</strong>分配给进程</li>
</ol>
<p>缺点：</p>
<ul>
<li>用户编程时必须使用 “物理设备名” ，低层细节对用户不透明，不方便编程</li>
<li>若换了一个物理设备，程序无法运行</li>
<li>若进程亲求的物理设备正在忙碌，则即使系统中还有同类型空闲设备，进程也必须阻塞等待</li>
</ul>
<p>改进</p>
<p>上面第一步，改为，根据进程请求的<strong>逻辑设备名</strong>查找SDT（逻辑设备名实际就是设备类型）</p>
<p><strong>逻辑设备表（LUT）建立了逻辑设备名和物理设备名之间的映射关系。</strong></p>
<p>某用户进程第一次使用逻辑设备名向系统发请求，查找系统设备表，分配给进程，并在LUT中增加相应表项。</p>
<p><strong>之后用户进程再次通过相同的逻辑设备名请求使用设备。则操作系统通过LUT表即可知道用户进程实际要使用哪个物理设备，也能知道该设备的驱动程序入口地址。</strong></p>
<p>整个系统只有一张LUT / 每个用户都有一张LUT。</p>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119132128642.png" alt="image-20211119132128642"></p>
<p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区</p>
<p>使用<strong>硬件作为缓冲区</strong>的<strong>成本较高，容量也较小</strong>。一般情况下，更多的是利用<strong>内存作为缓冲区</strong>，”设备独立性软件“ 的缓冲区管理就是要组织管理好这些缓冲区。</p>
<p>缓冲区的作用</p>
<ul>
<li><strong>缓和CPU与IO设备之间速度不匹配的矛盾</strong></li>
<li><strong>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</strong></li>
<li><strong>解决数据粒度不匹配的问题</strong></li>
<li><strong>提高CPU与IO设备之间的并行性</strong></li>
</ul>
<p>CPU可以把要输出的数据快速的放入缓冲区，之后就可以做别的事情。</p>
<h3 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h3><p>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>单缓冲</strong>的策略，操作系统会<strong>在主存中为其分配一个缓冲区</strong>（若题目中没有特别说明，一个缓冲区的大小就是一个块）</p>
<p><strong>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出</strong>。</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119130759284.png" alt="image-20211119130759284"></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119131006073.png" alt="image-20211119131006073"></p>
<p><strong>采用单缓冲策略，处理一块数据平均耗时 Max（C,T)+M</strong></p>
<h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p>若采用<strong>双缓冲</strong>的策略，操作系统会<strong>在主存中为其分配两个缓冲区</strong></p>
<p>双缓冲题目中，假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空。</p>
<p><strong>假设 T&gt;C+M</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119131522261.png" alt="image-20211119131522261"></p>
<p><strong>假设T&lt;C+M</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119131545212.png" alt="image-20211119131545212"></p>
<p><strong>结论：采用双缓冲策略，处理一个数据块的平均耗时为Max（T,C+M）</strong></p>
<h3 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h3><p>将多个<strong>大小相等</strong>的缓冲区链接称一个<strong>循环队列</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119131713433.png" alt="image-20211119131713433"></p>
<h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>由系统中共用的缓冲区组成。</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211119132047583.png" alt="image-20211119132047583"></p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><p><span>本文标题：</span>操作系统 第五章</p><p><span>文章作者：</span>懒人瑜恩</p><p><span>发布时间：</span>2021-12-05</p><p><span>最后更新：</span>2021-12-05</p><p><span>原始链接：</span><a href="/2021/2021/操作系统-第五章/">https://yvenxx.github.io/yvenxx/2021/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://yvenxx.github.io/yvenxx/2021/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/"></i></span></p><p><span>版权声明：</span>版权所有，转载请注明出处。</p></div><br><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://yvenxx.github.io/yvenxx/2021/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/" data-id="ckxomrdoh000eisu3fgjb72df" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ4AAAEOCAAAAABd2qZ5AAAD60lEQVR42u3awW7jMAwE0Pz/T3evBQonM6S02wWeT0XaytbzQeGQr1d8fX27fn6SXE+rzdbJP3nduHDgwIEDR7zV5Pbtg+Z33D/b7OXhwIEDB44bHE+Pkv/N043fr7m5y42VceDAgQPHv+JIjsl8nXuFIg4cOHDg+P0cRTkU3GUfTc5eAw4cOHDguM2RBHBtQZWsk291Fl9ezEpx4MCBA8fns+nVHlr/y89X5jtw4MCBA0c5LrAZd5vd/X3Z1haE9e5w4MCBA8ehg6JdOinb2sGCDVZSLub7woEDBw4ce45ZwZaXfPkR2A46tGHisA2GAwcOHDhKjn0rKC+68ubQhnL1mnHgwIEDx4JjM3YwC+Y2AwrvD8g8Xnx8AThw4MCB4xDHrAxLHiIfqssJkteTjzsUKSkOHDhw4IgrrOSQ2xdXs9JuHyC2rTIcOHDgwHGKoy172rGDzSBCu/6scYUDBw4cOPYceaNoU27d+/lU0RjNzeHAgQMHjoBjFvy17ai24XS2NbUvTXHgwIEDR87RtnBavja2a2PBNnz8sCMcOHDgwHGUIw8HZ6z7sYNZmFjEjjhw4MCB4xDHptCaxYuzwmyDm+wUBw4cOHDsOZItza7ZlvLm0Cb1/ACEAwcOHDgWHPkhmh9jOU3+efuEw+gTBw4cOHCsOdrxhTwozA/LWcCXt7LaAg8HDhw4cOw5ZgdtfgDvN5YPPbQhIw4cOHDgOMvRDi7kiWO+yeSorguw0fPjwIEDB449Rx7nJXDtQ7djEDnZZrgBBw4cOHBsONqYL4/k9k2mTZmXfPI40IADBw4cOBYcs/GFdpRhVm7lsWO77eF3DRw4cODAMeJoo7T88/bhZod6O05RjMrhwIEDB47gyfMmUH68tW2kduV2w8Vrw4EDBw4ca472BsmhNfttW0zm/1vvCAcOHDhwrDmS5ZLN5CXTbGBiVl5uRitw4MCBA8eGo2jJlCVWHue10PvCDwcOHDhw3OCYRWx5syf/m33h177CIhzEgQMHDhwBRxultVjJgEKL2A7nFYc6Dhw4cOA4xJGHbu1B25Z/t0crPrxUHDhw4MCx5mjbNrP2Uhs+btpFMxQcOHDgwHGK46u8NjRtyTcLLvN4cTjNgQMHDhw4Dl3t8bkfWchjxPabxeZ4xoEDBw4cbRqWjyAkYWLbFspjxOSrQL4+Dhw4cOC4wdGWT8mhOCul8qGETZH2+F84cODAgeMXcOTVYb6BzVG6+tKAAwcOHDj+Okc7Qpc3n04d6nkb7DEcxIEDBw4ca468WEqOzHyTm+KtbT4lLwMHDhw4cOw58igtj9hOlWebwPHUYAQOHDhw4Ig5/gC8BCCCsI0JNQAAAABJRU5ErkJggg==">分享</a><div class="tags"></div><div class="post-nav"><a class="pre" href="/2021/2021/Redis%E5%9F%BA%E7%A1%80/">Redis基础</a><a class="next" href="/2021/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0/">操作系统 第四章</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://yvenxx.github.io/yvenxx"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">6</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">数据库原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/2021/Redis%E5%9F%BA%E7%A1%80/">Redis基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/">操作系统 第五章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0/">操作系统 第四章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/">操作系统-第三章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%8C%E7%AB%A0/">操作系统-第二章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%80%E7%AB%A0/">操作系统-第一章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%83%E7%AB%A0/">计算机组成原理-第七章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E5%85%AD%E7%AB%A0/">计算机组成原理-第六章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%94%E7%AB%A0/">计算机组成原理-第五章</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.yvenxx.cn/" title="懒人瑜恩" target="_blank">懒人瑜恩</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">懒人瑜恩.</a> Powered by Hexo.</div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>