<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="一些我的计算机笔记，JAVA/Python/Linux/后端/计算机基础">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        计算机组成原理-第二章 - undefined
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.3.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> sometimes code, sometimes English </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/" />
        </div>
        <div class="name">
            <i>懒人瑜恩</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0%E5%88%B6"><span class="toc-text">进位计数制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BCD%E7%A0%81"><span class="toc-text">BCD码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8421%EF%BC%88%E5%8A%A0%E6%B3%95%EF%BC%89"><span class="toc-text">8421（加法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%993%E7%A0%81"><span class="toc-text">余3码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2421%E7%A0%81"><span class="toc-text">2421码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASCII%E7%A0%81"><span class="toc-text">ASCII码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%89%E5%AD%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E7%BC%96%E7%A0%81"><span class="toc-text">汉字的表示和编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C"><span class="toc-text">校验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="toc-text">奇偶校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C%E7%A0%81"><span class="toc-text">海明校验码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CRC%E7%A0%81%EF%BC%88%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%E7%A0%81%EF%BC%89"><span class="toc-text">CRC码（循环冗余校验码）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">定点数的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0"><span class="toc-text">无符号数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E8%A1%A8%E7%A4%BA"><span class="toc-text">有符号数的定点表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E7%A0%81"><span class="toc-text">反码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81"><span class="toc-text">补码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E7%A0%81"><span class="toc-text">移码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97"><span class="toc-text">运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">移位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E7%A7%BB%E4%BD%8D"><span class="toc-text">算数移位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%A7%BB%E4%BD%8D"><span class="toc-text">逻辑移位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D"><span class="toc-text">循环移位</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="toc-text">加减运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E5%88%A4%E6%96%AD"><span class="toc-text">溢出判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%B1%95"><span class="toc-text">符号扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E4%B9%98%E6%B3%95"><span class="toc-text">原码乘法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E4%B9%98%E6%B3%95"><span class="toc-text">补码乘法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E9%99%A4%E6%B3%95"><span class="toc-text">原码除法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E9%99%A4%E6%B3%95"><span class="toc-text">补码除法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E6%8E%92%E5%88%97"><span class="toc-text">数据的存储和排列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-text">浮点数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IEEE754"><span class="toc-text">IEEE754</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="toc-text">浮点数加减运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8F%82%E4%B8%8E%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">浮点数参与的强制类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83ALU"><span class="toc-text">算数逻辑单元ALU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8"><span class="toc-text">一位全加器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="toc-text">串行加法器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="toc-text">并行加法器</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> sometimes code, sometimes English </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        计算机组成原理-第二章
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2021-10-21 08:03:33</span></span>
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <a id="more"></a>





<h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018081735509.png" alt="image-20211018081735509"></p>
<h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><h3 id="8421（加法）"><a href="#8421（加法）" class="headerlink" title="8421（加法）"></a>8421（加法）</h3><blockquote>
<p><strong>加法超过1-9的表示范围需要加6来表示</strong></p>
</blockquote>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018082549357.png" alt="image-20211018082549357"></p>
<h3 id="余3码"><a href="#余3码" class="headerlink" title="余3码"></a>余3码</h3><p><strong>在8421码基础上加上一个3</strong></p>
<h3 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h3><p>2421分别为每一位的权值，表示0-4时最高位为0，5-9时最高位为1</p>
<h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018083836835.png" alt="image-20211018083836835"></p>
<h2 id="汉字的表示和编码"><a href="#汉字的表示和编码" class="headerlink" title="汉字的表示和编码"></a>汉字的表示和编码</h2><p><strong>GB2312-80</strong></p>
<p>+80H为了高位为1，与ASCII码进行区分</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018084425246.png" alt="image-20211018084425246"></p>
<p><strong>输入：输入编码</strong></p>
<p><strong>输出：汉字字形码</strong></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>大端模式：将数据的最高有效字节存放在低地址单元中</p>
<p>小端模式：将数据的最高有效字节存放在高地址单元中</p>
<p>字符串：计算机按字节编址，以 “\0” 结尾，在所有计算机中，<strong>多字节数据</strong>都被<strong>存放在连续的字节序列中</strong></p>
<p>例如 “abc啊”，B0H A1H表示为啊，这里是大端模式</p>
<table>
<thead>
<tr>
<th>61H</th>
<th>62H</th>
<th>63H</th>
<th>B0H</th>
<th>A1H</th>
<th>00H</th>
</tr>
</thead>
</table>
<h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><p>原理</p>
<p>若干位代码组成的一个字叫<strong>码字</strong>，将两个码字逐位进行对比，具有不同的位的个数称为<strong>两个码字j间的距离</strong>，各合法码字间的最小距离称为<strong>码距（d）</strong></p>
<p>d=1时，无检错能力。d=2时，有检错能力。d&gt;=3时，设计合理，可能具有检错纠错能力</p>
<h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>奇校验码：整个校验码（有效信息位和校验位）中”1“的个数为奇数，偶校验码类似</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018091039245.png" alt="image-20211018091039245"></p>
<p>例：奇校验，给出1001101和1010111的两个二进制数</p>
<p>设最高位是校验位，7位是信息位。1001101—&gt;<strong>1</strong>1001101，1010111—-&gt;<strong>0</strong>1010111。也就是用校验位保证为1为奇数个，当发送数据时，如果发生数据跳变，其中一个位变化，就会变成偶数个，就可以看到是否有出错。</p>
<blockquote>
<p>但是如果有偶数个bit发生跳变，是无法发现错误</p>
</blockquote>
<p>计算机中的实现，各信息进行异或，算出是否需要校验位。如下</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018091638976.png" alt="image-20211018091638976"></p>
<h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><p>思路：将信息位分组进行偶校验，将数据进行分组，每个分组都设置校验位，多个校验位标注出错位置</p>
<p>其中分组按照2的n次方来计算的。四位是2的3次方，所以分为3个组。</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018094018035.png" alt="image-20211018094018035"></p>
<p>校验原理是：按照数据存放的位置，例如H3（011）其中两个1，对应1位和2位，所以与校验码 p1,p2进行对应</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018095035901.png" alt="image-20211018095035901"></p>
<p>数据存放方法，上面为从大到小。如下是从小到大</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018094218710.png" alt="image-20211018094218710"></p>
<blockquote>
<p>补充</p>
<p>无法确定是一位出错还是两位出错，如果p1,p2同时出错，就为110，但是实际不是那个位置出错。</p>
<p>所以需要加上<strong>全校验位</strong>，也就是在加上一个最高位为全校验位，进行偶校验。</p>
<p>000=无错误</p>
<p>不为000就代表有错误，如果校验失败，就纠错。</p>
<p>如果校验成功，有两位错，需重传。</p>
</blockquote>
<h3 id="CRC码（循环冗余校验码）"><a href="#CRC码（循环冗余校验码）" class="headerlink" title="CRC码（循环冗余校验码）"></a>CRC码（循环冗余校验码）</h3><p>基本思想：数据接收方和发送方约定一个 ”<strong>除数</strong>“，且给   k个信息位+R个校验位作为 ”<strong>被除数</strong>“，添加校验位后<strong>保证除法的余数为0</strong>。</p>
<p>收到数据后，进行除法检查余数是否为0，如果为0是为出错，非0表示出错。</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018103751182.png" alt="image-20211018103751182"></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018103910642.png" alt="image-20211018103910642"></p>
<blockquote>
<p>这里010表示C2出错，是有依据的。但是也不完全正确。如果2^R &gt;= K+R+1，则CRC码可纠错一位的错误。如果不是，则010可能不是表示2的位置，也可能表示9（按照上题）</p>
<p>001001 001，余数为010，实际是9位出错。101001 011 余数010 ，2位出错。</p>
</blockquote>
<h2 id="定点数的表示"><a href="#定点数的表示" class="headerlink" title="定点数的表示"></a>定点数的表示</h2><p>定点数：小数点的位置固定    996.007</p>
<p>浮点数：小数点的位置不固定    9.96007*10^3</p>
<h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><blockquote>
<p>无符号数通常只表示整数</p>
</blockquote>
<p>所有位数都是数值，没有符号位。N位无符号数表示范围：0-2^(n-1)</p>
<h3 id="有符号数的定点表示"><a href="#有符号数的定点表示" class="headerlink" title="有符号数的定点表示"></a>有符号数的定点表示</h3><blockquote>
<p>0有+0和-0</p>
</blockquote>
<p>正（0）负（1）</p>
<p>可用<strong>原码，补码，反码</strong>三种方式来表示定点整数和定点小数。还可用<strong>移码</strong>表示定点整数</p>
<p>若真值为x，则用[x]原，[x]反，[x]补，[x]移分别表示真值所对应的原码反码……</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018104904524.png" alt="image-20211018104904524"></p>
<p><strong>原码整数</strong>的表示范围：-(2^n-1) &lt;= x &lt;= 2^n-1</p>
<p><strong>原码小数</strong>的表示范围：-(1-2^-n) &lt;= x &lt;= 1-2^-n</p>
<h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><blockquote>
<p>0有+0和-0</p>
</blockquote>
<p>若符号位为0，则反码与原码相同</p>
<p>若符号位为1，则数值位全部取反</p>
<p>表示范围与原码的表示范围一致</p>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>补码：解决计算机中的减法操作。两个原码相减，将减数转为补码，就可以转为加法运算。</p>
<p>正数的补码=原码。负数的补码=反码末位+1（要考虑进位）</p>
<blockquote>
<p>补码的真值0只有一种表示形式</p>
<p><strong>原码补码相互转换方法一样</strong></p>
</blockquote>
<p>表示范围</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018110254156.png" alt="image-20211018110254156"></p>
<h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><p>补码的基础上将符号位取反。或者移码=真值+偏置值（计算机中的设定）<strong>移码只能用于整数</strong></p>
<p>表示范围与补码一致</p>
<p>移码作用：移码表示的整数很方便对比大小</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><p>通过改变各个数码位的小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法，除法</p>
<h5 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h5><p><strong>原码的算数移位</strong>—-符号位保持不变，仅对数值位进行移位</p>
<p>右移：高位补0，低位舍弃。若舍弃的位=0，相当于 /2 ；舍弃的位不为0，则会丢失精度</p>
<p>左移：低位补0，高位舍弃。舍弃的位=0，相当于*2。舍弃的位不为0，会出现<strong>严重误差</strong></p>
<p>反码算数移位</p>
<ul>
<li>正数高位为0，与原码移位一样。补0</li>
<li>负数高位为1，高位低位补1。</li>
</ul>
<p>补码算数移位</p>
<ul>
<li>正数与原码相同</li>
<li>负数：最右边的1的右边，用原码的规律。最右边的1的左边，用反码的规律<ul>
<li>右移（同反码）：高位补1，低位舍弃</li>
<li>左移（同原码）：低位补0，高位舍弃</li>
</ul>
</li>
</ul>
<h5 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h5><p>可以看作对无符号数的移位，右移,高位补0，低位舍弃。左移，低位补0，高位舍弃</p>
<h5 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h5><p>例如左移，会把移出去的那移位，放到最末位。右移类似</p>
<p>带  进位  位的循环左移：</p>
<p>例：有8bit位的数值，在前面再加一个位。当左移的时候，将最高位放到进位 位。将进位 位的数值放到末位。</p>
<h4 id="加减运算"><a href="#加减运算" class="headerlink" title="加减运算"></a>加减运算</h4><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018143143114.png" alt="image-20211018143143114"></p>
<p>原码进行加减需要太多机制，而且可能会出错。所以用补码进行加减运算。<strong>补码运算如下</strong></p>
<p>例：A=15,B=-24</p>
<p>[A+B]补=[A]补+[B]补=0,0001111+1,1101000=1,1110111（再转换为原码）</p>
<p>[A-B]补=[A]补+[-B]补=0,0001111+1,0011000=0,0100111（转换原码即可）</p>
<p>其中A-B 那里是将B进行按位取反再+1。也就是转为补码的补码（这里要连同符号位）</p>
<h4 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h4><blockquote>
<p>双符号位补码又称：模4补码</p>
<p>单符号位补码又称：模2补码</p>
</blockquote>
<p>正+正=负（上溢）</p>
<p>负+负=正（下溢）</p>
<p><strong>方法一</strong></p>
<p>采用一位符号位。设A的符号为As,B的符号为Bs，运算结果的符号为Ss,则溢出逻辑表达式为<img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018141531037.png" alt="image-20211018141531037"></p>
<p>若V=0，表示无溢出，反之溢出</p>
<p>例：A=15,C=124</p>
<p>A+C=0,0001111+0,1111100=1,0001011  等于-117 肯定溢出了</p>
<p>其中计算时   A的符号位0，C符号位0，S符号位1。进行计算。V=000+111=1(溢出)</p>
<p><strong>方法二</strong></p>
<p>采用一符号位，根据数据位进位情况判断溢出，符号位的进位Cs，最高数值位的进位C1</p>
<table>
<thead>
<tr>
<th></th>
<th>Cs</th>
<th>C1</th>
</tr>
</thead>
<tbody><tr>
<td>上溢</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>下溢</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018142104328.png" alt="image-20211018142104328"></p>
<p><strong>方法三</strong></p>
<blockquote>
<p>双符号位，实际存储只存储1个符号位，运算时会复制一个符号位</p>
</blockquote>
<p>采用双符号位，正数符号为00，负数符号为11</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018142256958.png" alt="image-20211018142256958"></p>
<h4 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a><strong>符号扩展</strong></h4><p>8位—》16位</p>
<p>整数在最高位前面补数字，原码补0反码补码补1。小数就是在后面补0/1，反码补1，原码补码补0</p>
<h4 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h4><p>直接上实例。其中X和MQ中存的是他们的<strong>绝对值</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018144552008.png" alt="image-20211018144552008"></p>
<p>这里已经是算完的状态，也就是已经都移位完了。如果没有算的状态，ACC里面是全0的状态，每次取灰色的位置，乘以X，放入ACC，然后MQ和ACC统一逻辑右移移位。移到最后一位就可以不用进行运算(灰色的0不参与)。然后进行异或符号，放入最高位的位置。</p>
<h4 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h4><p>进行n+1轮加法，移位。每次加法可能是 +0，+[x]补，+[-x]补。且每次移位是补码的<strong>算数右移</strong>，符号位参与运算（原码使用的是绝对值，符号位不参加运算）</p>
<p>红色的为辅助位，X位置的辅助位是双符号位。算法与原码类似。</p>
<p><strong>有一点不同的是，+0，+[x]补，+[-x]补。具体实现是，辅助位-最低位获得的数字。为0，1，-1来进行对应</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018145357424.png" alt="image-20211018145357424"></p>
<h4 id="原码除法"><a href="#原码除法" class="headerlink" title="原码除法"></a>原码除法</h4><p><strong>恢复余数法</strong></p>
<p>ACC初始存被除数，当计算开始后存相减之后的余数。</p>
<p>计算方法：<strong>因为计算机不会判断大小，他会先取1进MQ的位置，然后让 ACC-除数，如果算出来的数字出错（符号位为1），就会将减掉的数字再加上去，将MQ的低位换为0。然后进行逻辑左移右边补0，ACC移出去的数字丢弃。</strong>最后得到的商在MQ中，余数在ACC中，但是余数需要乘以 2^-n次方才是最终余数。然后符号位异或</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018150955305.png" alt="image-20211018150955305"></p>
<p><strong>加减交替法</strong></p>
<p>和恢复余数法很类似，但是优化了其中的过程。具体如下，<strong>但当最后余数为负，则需商0，并+[Y]补得到正确的余数</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211018152409858.png" alt="image-20211018152409858"></p>
<h4 id="补码除法"><a href="#补码除法" class="headerlink" title="补码除法"></a>补码除法</h4><p>符号位参与运算，被除数/余数，除数，采用双符号位</p>
<p>余数和除数<strong>同号</strong>，商<strong>1</strong>，<strong>余数左移一位减去除数</strong></p>
<p>余数和除数异号，商<strong>0</strong>，<strong>余数左移一位加上除数</strong></p>
<blockquote>
<p>最后结果，需要末位恒置为1。精度误差不超过2^(-n)</p>
</blockquote>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>无符号数与有符号数：不改变数据内容，改变解释方式</p>
<p>都是补码的形式。长整数变短整数，高位截断保留低位。</p>
<p>例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> x = <span class="number">-4321</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> y = (<span class="keyword">unsigned</span> <span class="keyword">short</span>)x;</span><br><span class="line"><span class="comment">// x=1110 1111 0001 1111（-4321）   y=1110 1111 0001 1111 （61215）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = x;</span><br><span class="line"><span class="comment">//m=1111 1111 1111 1111 1110 1111 0001 1111(-4321)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">165537</span>;</span><br><span class="line"><span class="keyword">short</span> c=(<span class="keyword">short</span>)a;</span><br><span class="line"><span class="comment">//a=0x000286a1(61215) , c=0x86a1(-31071)</span></span><br></pre></td></tr></table></figure>


<h3 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h3><p>大端，小端模式</p>
<p>大端：将数据最高位存在低位的位置（可以理解为从左往右，从大到小）</p>
<p>小端：将数据最低位存在低位的位置（从左往右，从左到大，主要是为了理解，实际并不一定是从左往右）</p>
<p><strong>边界模式</strong></p>
<p>现代计算机通常字节编址，每个字节对应一个地址。通常按字，半字，字节寻址。如下图</p>
<blockquote>
<p>注：其中填充是因为要边界对齐</p>
</blockquote>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019115407404.png" alt="image-20211019115407404"></p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点数的真值：N=r^e * M，r通常为2和2的倍数，M为尾数</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019130619281.png" alt="image-20211019130619281"></p>
<p>例：</p>
<p>a=0,01;1.1001     b=0,10;0.01001</p>
<p>a的表示为：00111001。但是b的表示 有9位，超出了8bit。所以需要进行规格化</p>
<p>b的尾数是0.01001，将小数点后面的0去掉，左移1。使小数点第一位是1。最后面补0（如果满了就不用管）。得到01001001。</p>
<p><strong>规格化</strong></p>
<p>规定<strong>尾数的最高数值位必须是一个有效值</strong></p>
<p><strong>左规：</strong>当浮点数运算的结果为非规格化时要进行规格化处理，将<strong>尾数算数左移移位，阶码减1</strong></p>
<p><strong>右规：</strong>当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将<strong>尾数算数右移一位，阶码加1</strong></p>
<blockquote>
<p>采用双符号位，当溢出发生时，可以挽救。更高的符号位是正确的符号位。</p>
<p>右规的情况，例如两个数字相加  出现了符号位两个数字不同。就是溢出，所以需要纠正</p>
</blockquote>
<p>用原码表示的尾数进行规格化</p>
<ul>
<li>正数为0.1xxxx（小数点后第一位需要为1，如果是0就丢弃然后左移，直到有1），则其最大值表示为0.11……1；最小值表示为0.10…….0。尾数的表示范围为  1/2 &lt;=M&lt;=(1-2^(-n))</li>
<li>负数为1.1xxx，其最大值为1.10….0；最小值为1.11…..1。尾数表示范围为  -(1-2^(-n)) &lt;=M&lt;= -1/2</li>
</ul>
<p>用补码表示的尾数进行规格化</p>
<ul>
<li>正数为0.1xxx，其最大值表示为0.1….1；最小值为0.10….0。尾数表示范围 1/2 &lt;=M&lt;=(1-2^(-n))</li>
<li>负数为1.0xxx，其最大值表示为1.01….1（这里小数点后面需要一个1，然后才是1）；最小值为1.0…0。尾数的表示范围 -1&lt;= M &lt;= -(1/2+2^(-n))</li>
</ul>
<h3 id="IEEE754"><a href="#IEEE754" class="headerlink" title="IEEE754"></a>IEEE754</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019142430106.png" alt="image-20211019142430106"></p>
<blockquote>
<p>阶码全0，全1用作特殊用途</p>
</blockquote>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019142524479.png" alt="image-20211019142524479"></p>
<p>由浮点数确定真值（阶码不是全0和全1）</p>
<ol>
<li>根据 “某浮点数” 确定数符，阶码，尾数的分布</li>
<li>确定尾数1.M（需要补充最高的隐含位1）</li>
<li>确定阶码的  真值 = 移码-偏置值</li>
<li>(-1)^s * 1.M = 2^(E-偏置值)</li>
</ol>
<p>最小绝对值：尾数全为0，阶码真值最小 -126，对应移码机器数0000 0001，整体的真值为 (1.0) * 2^(-126)</p>
<p>最大绝对值：尾数全为1，阶码真值最大127，对应移码机器数为1111 1110，整体真值为 (1.11….11) * 2^127</p>
<p>特殊的：</p>
<p>当<strong>阶码全为0</strong></p>
<ul>
<li>尾数不全为0时，表示<strong>非规格化小数</strong>  ±(0.xx.xxxx)+2^(-126)</li>
<li>尾数全为0时，表示<strong>真值 ±0</strong></li>
</ul>
<p><strong>当阶码全为1</strong></p>
<ul>
<li>尾数全为0，表示 <strong>±无穷</strong></li>
<li>尾数不全为0，表示<strong>非数值 “NaN”</strong></li>
</ul>
<h4 id="浮点数加减运算"><a href="#浮点数加减运算" class="headerlink" title="浮点数加减运算"></a>浮点数加减运算</h4><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019150600241.png" alt="image-20211019150600241"></p>
<p><strong>舍入</strong></p>
<p><strong>“0” 舍 “1” 入法：</strong>在尾数右移时，被移去的最高数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1.（但是可能会让尾数溢出，需要再做右规）</p>
<p><strong>恒置 ”1“ 法：</strong>尾数右移时，不论丢掉的最高数值位是 ”1“ 还是 “0” 都使右移后的尾数末位恒置 “1”，（可能会使尾数变大或变小）</p>
<h3 id="浮点数参与的强制类型转换"><a href="#浮点数参与的强制类型转换" class="headerlink" title="浮点数参与的强制类型转换"></a>浮点数参与的强制类型转换</h3><p>char-&gt; int -&gt; long -&gt; double（long32位时无精度丢失，但如果long是64位时转到double会有精度丢失）</p>
<p>32位</p>
<p>int：表示整数，范围是 -2^31—2^(31-1)，有效数字32位</p>
<p>float：表示整数及小数，范围 [ 2^(-126)—— 2^127(2-2^(-23)) ]</p>
<p>如果是int转float肯定会有精度丢失，因为int有31个数值位，float只有24个尾数位。float转int一样会有精度丢失，int会把小数点之后的数字丢失。</p>
<h2 id="算数逻辑单元ALU"><a href="#算数逻辑单元ALU" class="headerlink" title="算数逻辑单元ALU"></a>算数逻辑单元ALU</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019163305455.png" alt="image-20211019163305455"></p>
<h3 id="一位全加器"><a href="#一位全加器" class="headerlink" title="一位全加器"></a>一位全加器</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019172231738.png" alt="image-20211019172231738"></p>
<h3 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019172429386.png" alt="image-20211019172429386"></p>
<p>进位触发器存放进位的值，每次运算的时候将进位的值加进去运算（0/1）</p>
<p>只有一个全加器，数据逐位串行送入加法器中jji进行运算。进位触发器用来寄存进位信号，以便下一次运算（操作数为n，那么就要加n次）</p>
<h3 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211019172636212.png" alt="image-20211019172636212"></p>
<p><strong>串行进位的并行加法器</strong>：把n个全加器串接起来，就可以j进行两个n位数的相加。不过，虽然输入可以n个进行输入，但是还是要等低位的进行运算，然后将进位送到下一个运算器，才能进行下一次计算。</p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.xml"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
