<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一些我的计算机笔记，JAVA/Python/Linux/后端/计算机基础"><title>操作系统 第四章 | 懒人瑜恩</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + '2059a4484fb666484cf5e9fba7e20ce6';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">操作系统 第四章</h1><a id="logo" href="/.">懒人瑜恩</a><p class="description">sometimes code, sometimes English</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/history/"><i class="fa fa-book"> 历史</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">操作系统 第四章</h1><div class="post-meta">2021-12-05<span> | </span><span class="category"><a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0/#vcomment"><span class="valine-comment-count" data-xid="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">文件的逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">无结构文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.2.</span> <span class="toc-text">有结构文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">顺序文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">索引文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">索引顺序文件</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">文件的物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">文件的分配方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">链接分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">索引分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.1.3.1.</span> <span class="toc-text">链接方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.1.3.2.</span> <span class="toc-text">多层索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.1.3.3.</span> <span class="toc-text">混合索引</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84vs%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">物理结构vs逻辑结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">文件存储空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%9D%9E%E7%A9%BA%E9%97%B2%E7%A3%81%E7%9B%98%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">对非空闲磁盘块的管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%92%E5%88%86%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.5.2.</span> <span class="toc-text">存储空间的划分与初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A9%BA%E9%97%B2%E7%A3%81%E7%9B%98%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.3.</span> <span class="toc-text">对空闲磁盘块的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">空闲表法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">空闲链表法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%A4%BA%E5%9B%BE%E6%B3%95"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">位示图法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">成组链接法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%91%E4%B8%8A%E6%8F%90%E4%BE%9B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-number">1.6.</span> <span class="toc-text">操作系统向上提供的基本功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">1.7.</span> <span class="toc-text">文件共享</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%EF%BC%88%E7%A1%AC%E9%93%BE%E6%8E%A5%EF%BC%89"><span class="toc-number">1.7.1.</span> <span class="toc-text">基于索引结点的共享方式（硬链接）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%AC%A6%E5%8F%B7%E9%93%BE%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%EF%BC%88%E8%BD%AF%E9%93%BE%E6%8E%A5%EF%BC%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">基于符号链的共享方式（软链接）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.8.</span> <span class="toc-text">文件保护</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A3%E4%BB%A4%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.8.1.</span> <span class="toc-text">口令保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.8.2.</span> <span class="toc-text">加密保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">1.8.3.</span> <span class="toc-text">访问控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.</span> <span class="toc-text">文件系统的层次结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.10.</span> <span class="toc-text">磁盘的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">磁盘调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95%EF%BC%88FCFS%EF%BC%89"><span class="toc-number">1.11.1.</span> <span class="toc-text">先来先服务算法（FCFS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%AF%BB%E6%89%BE%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%EF%BC%88SSTF%EF%BC%89"><span class="toc-number">1.11.2.</span> <span class="toc-text">最短寻找时间优先（SSTF）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%88SCAN%EF%BC%89"><span class="toc-number">1.11.3.</span> <span class="toc-text">扫描算法（SCAN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LOOK%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.4.</span> <span class="toc-text">LOOK调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%88C-SCAN%EF%BC%89"><span class="toc-number">1.11.5.</span> <span class="toc-text">循环扫描算法（C-SCAN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-LOOK%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.6.</span> <span class="toc-text">C-LOOK调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4"><span class="toc-number">1.12.</span> <span class="toc-text">减少延迟时间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.12.1.</span> <span class="toc-text">磁盘地址结构的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%9B%BF%E7%BC%96%E5%8F%B7"><span class="toc-number">1.12.2.</span> <span class="toc-text">交替编号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E4%BD%8D%E5%91%BD%E5%90%8D"><span class="toc-number">1.12.3.</span> <span class="toc-text">错位命名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">1.13.</span> <span class="toc-text">磁盘的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.13.1.</span> <span class="toc-text">磁盘初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E5%9D%97"><span class="toc-number">1.13.2.</span> <span class="toc-text">引导块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%8F%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">1.13.3.</span> <span class="toc-text">坏块的管理</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><a id="more"></a>

<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211113105245107.png" alt="image-20211113105245107"></p>
<p><strong>文件名：</strong>由创建文件的用户决定文件名，主要是为了方便用户找到文件，**同一目录下不允许有重名文件</p>
<p><strong>标识符：</strong>一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称</p>
<p>类型：指明文件的类型</p>
<p><strong>位置</strong>：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，用户不可见）</p>
<p><strong>大小：</strong>指明文件大小</p>
<p><strong>创建时间、上次修改时间</strong></p>
<p><strong>文件所有者信息</strong></p>
<p><strong>保护信息：</strong>对文件进行保护的访问控制信息</p>
<p>—<strong>文件内部的数据组织</strong>—</p>
<ul>
<li><p>无结构文件，由一系列二进制或字符流组成</p>
<p>例如 txt 文件</p>
</li>
<li><p>有结构文件、多个记录，记录下面有数据项</p>
<p>例如 Excel 文件，一行是一个记录，一行里面的数据是数据项</p>
</li>
</ul>
<p>—<strong>操作系统向上提供的功能</strong>—</p>
<ul>
<li>创建文件（create系统调用）</li>
<li>删除文件（delete系统调用）</li>
<li>读文件（read系统调用）</li>
<li>写文件（write系统调用）</li>
<li>打开文件（open系统调用）</li>
<li>关闭文件（close系统调用）</li>
</ul>
<p>—<strong>从上往下看、文件应如何存放在外存</strong>—</p>
<p>操作系统以 “块” 为单位为文件分配存储空间，因此即使一个文件太小只有10B，但它依然需要占用1KB的磁盘块。外存中的数据读入内存时同样以块为单位。外存由一个个存储单元组成，每个对应一个地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211113103428653.png" alt="image-20211113103428653"></p>
<p>—-<strong>从下往上看</strong>—</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211113105159574.png" alt="image-20211113105159574"></p>
<p>文件共享：使多个用户可以共享使用一个文件</p>
<p>文件保护：保证不同的用户对文件有不同的权限</p>
<h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><h3 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h3><p>文件的内部数据就是一系列二进制流或字符流组成。又称 “<strong>流式文件</strong>“。如 txt 文件</p>
<p>所以无需讨论无结构文件的逻辑问题</p>
<h3 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h3><p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211114181527021.png" alt="image-20211114181527021"></p>
<p>由一组相似的记录组成，又称 ”<strong>记录式文件</strong>“。每条记录由若干条数据项组成，每条记录有一个数据项可作为<strong>关键字</strong>（作为识别不同记录的ID，类似sql的主键）。</p>
<p>根据各条记录的长度是否相等，可分为<strong>定长记录</strong>和<strong>可变长记录</strong>两种</p>
<blockquote>
<p>例如，学生表固定长度</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211113105949645.png" alt="image-20211113105949645"></p>
<p>不固定长度</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211113110007852.png" alt="image-20211113110007852"></p>
</blockquote>
<h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211113110514694.png" alt="image-20211113110514694"></p>
<p>文件中的记录一个接着一个的顺序排列（逻辑上），记录上可以是<strong>定长</strong>的或<strong>可变长</strong>的。各个记录在物理上可以<strong>顺序存储</strong>或<strong>链式存储</strong></p>
<ul>
<li><strong>顺序存储</strong>：逻辑上相邻的记录，物理上也相邻（类似顺序表）</li>
<li><strong>链式存储：</strong>逻辑上相邻的记录，物理上不一定相邻（链表）</li>
</ul>
<ul>
<li><strong>串结构：记录直接的顺序与关键字无关</strong></li>
<li><strong>顺序结构：记录直接的顺序按关键字顺序排列</strong></li>
</ul>
<h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><p><strong>索引表</strong>本身是<strong>定长记录的顺序文件</strong>。因此可以快速找到第i个记录对应的索引项。</p>
<p>可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此<strong>主要用于对信息处理的及时性要求比较高的场合</strong></p>
<p><strong>可以用不同的数据项建立多个索引表</strong>。如 可以用学号建立一张，姓名也可以建立一张。实现可以用学号或姓名检索</p>
<h5 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h5><p><strong>一组记录对应一个索引表项</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211114181147558.png" alt="image-20211114181147558"></p>
<p>文件检索快：</p>
<p>如果是<strong>顺序文件</strong>有10000个记录。只能从头开始顺序查找。平均须查找5000个记录</p>
<p>而<strong>索引顺序文件</strong>，可分为100组，每组100个记录，则<strong>平均查找只要50+50=100次</strong></p>
<p><strong>还可建立多级索引表</strong>，套娃</p>
<h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><p><strong>磁盘块大小与内存块、页面的大小相同</strong>，读取文件块（磁盘块）时，每次读入或写出 一块。</p>
<p><strong>文件的逻辑结构空间也被分为了一个一个的文件“块”</strong>，因此逻辑地址也可以表示为<strong>（逻辑块号，块内地址）</strong>的形式</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211114195901602.png" alt="image-20211114195901602"></p>
<h3 id="文件的分配方式"><a href="#文件的分配方式" class="headerlink" title="文件的分配方式"></a>文件的分配方式</h3><p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211114211428050.png" alt="image-20211114211428050"></p>
<h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p><strong>每个文件在磁盘上占有一组  连续  的块</strong>。文件目录中记录存放 起始块号和长度。</p>
<p><strong>物理块号 = 起始块号 + 逻辑块号</strong>，因此<strong>连续分配支持顺序访问和直接访问</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211114200242748.png" alt="image-20211114200242748"></p>
<p><strong>连续分配的文件在顺序 读/写 时速度最快</strong>，但因为是必须连续的状态，<strong>不容易扩展</strong>。假如目前拥有3个块，但是后面的块被人用了，则需要找其他连续的空闲块。且<strong>连续分配存储空间利用率低，会产生难以利用的磁盘碎片</strong>。虽然可以用<strong>紧凑</strong>来处理碎片，代价大。</p>
<p>简单来说</p>
<p><strong>优点：支持顺序访问和直接访问，顺序读写速度快</strong></p>
<p><strong>缺点：不方便文件扩展，存储空间利用率低，会产生磁盘碎片</strong></p>
<h4 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h4><p>采用离散分配的方式，为文件分配离散的磁盘块，分为 <strong>隐式链接</strong>和<strong>显式链接</strong></p>
<p><strong>—-隐式链接—-</strong></p>
<p>类似于链表的方式，但是每次只能顺序访问，不能随机访问。除文件的最后一个盘块之外，每个盘块都存有一个指向下一节点的指针。文件目录包括文件第一块的指针和最后一块的指针。</p>
<p><strong>优点：</strong>方便文件扩展，不会有碎片问题，外存利用率高</p>
<p><strong>缺点：</strong>只支持顺序访问，不支持随机访问，查找效率低，指向下一盘块的指针也需要h耗费少量的存储空间</p>
<p>—-<strong>显式链接</strong>—-</p>
<p>把用于链接各文件物理块的指针显示的存放在一张表中。文件分配表（FAT，File Allocation Table）</p>
<p><strong>一个磁盘仅设置一张 FAT。开机时，将FAT读入内存，并常驻内存</strong>。因为是常驻内存，<strong>逻辑块号转换成物理块号的过程不需要读磁盘操作</strong>。</p>
<p>则采用<strong>显式链接</strong>方式的文件，支持顺序访问，也<strong>支持随机访问（想访问i号逻辑块时，不需要依次访问之前的部分，直接访问i）</strong>。<strong>不会产生碎片</strong></p>
<p><strong>优点：</strong>方便文件拓展，不会有碎片问题，外存利用率高，并且<strong>支持随机访问</strong>，相比于隐式链接，<strong>地址转换时不需要访问磁盘，文件的访问效率更高</strong></p>
<p><strong>缺点：</strong>文件分配表需要占用一定的存储空间</p>
<p>例如 a文件依次存放2-&gt;5-&gt;0&gt;1 最后一个指针为-1，特殊值</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211114201508327.png" alt="image-20211114201508327"></p>
<h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><p>允许文件离散的分配在各个磁盘块中，系统会<strong>给每个文件建立一张索引表</strong>，索引表中<strong>记录文件的各个逻辑块对应的物理块</strong>。索引块一样存储在磁盘块中，称为索引块，其余称为数据块。</p>
<p><strong>索引分配可支持随机访问，文件拓展可很容易实现，但索引表需要占用一定的存储空间</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211114205529006.png" alt="image-20211114205529006"></p>
<p>注意一个问题，每个磁盘块是固定大小的。如果索引块需要存储的索引数据比块大。就没法存储</p>
<p>——解决方案如下——</p>
<h5 id="链接方案"><a href="#链接方案" class="headerlink" title="链接方案"></a>链接方案</h5><p>如果索引表太大，一个索引块放不下，可以将多个索引块链接起来存放。</p>
<p>但是有个问题是，如果有几百个索引块，我们要最后一个索引块，就需要一直顺序查到最后一个。效率低下</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211114205947135.png" alt="image-20211114205947135"></p>
<h5 id="多层索引"><a href="#多层索引" class="headerlink" title="多层索引"></a>多层索引</h5><p><strong>原理类似多级页表</strong>，第一层索引块指向第二层索引块…….</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211114210716940.png" alt="image-20211114210716940"></p>
<p>K+1次是读磁盘操作</p>
<h5 id="混合索引"><a href="#混合索引" class="headerlink" title="混合索引"></a>混合索引</h5><p>多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含<strong>直接地址索引（直接指向数据项）</strong>，又包含一级<strong>间接索引</strong>，还包含<strong>二级间接索引</strong>………..</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211114210958185.png" alt="image-20211114210958185"></p>
<p><strong>重点重点重点重点重点重点重点</strong></p>
<ol>
<li>要会根据多层索引，或者索引的结构计算出文件的最大长度（关键：各级索引表最大不能超过一个块（磁盘块））</li>
<li>要能自己分析访问某个数据块所需要的读磁盘次数（关键：FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外要<strong>注意题目条件–顶级索引块是否已调入内存</strong>）</li>
</ol>
<h2 id="物理结构vs逻辑结构"><a href="#物理结构vs逻辑结构" class="headerlink" title="物理结构vs逻辑结构"></a>物理结构vs逻辑结构</h2><p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115131608349.png" alt="image-20211115131608349"></p>
<p>逻辑结构是用户看到的样子，而物理结构是操作系统进行决定的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115131726077.png" alt="image-20211115131726077"></p>
<p>关于索引文件，链式存储，链接分配，索引分配的区别</p>
<p><strong>—- 顺序文件 采用 顺序存储/链式存储 —-</strong></p>
<p>顺序存储，各条记录相邻的存放。链式存储，用指针进行相连，实际也是顺序存储。</p>
<p><strong>—-链式存储 的 顺序文件 采用连续分配（物理结构）—-</strong></p>
<p>在连续的空间上，进行链式存储 存为连续分配 顺序文件的形式</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115132327188.png" alt="image-20211115132327188"></p>
<p><strong>—-链式存储 的 顺序文件 采用 链接分配（物理结构）—-</strong></p>
<p>采用链式存储 实现 链接分配的顺序文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115132517860.png" alt="image-20211115132517860"></p>
<p><strong>—-索引文件（物理）采用索引分配（逻辑）—-</strong></p>
<p>简单的说就是，采用索引文件的方式存储数据（用户决定），操作系统用索引分配方式存储。</p>
<p><strong>物理上</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115134038539.png" alt="image-20211115134038539"></p>
<p><strong>逻辑上</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115134101788.png" alt="image-20211115134101788"></p>
<h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115155034068.png" alt="image-20211115155034068"></p>
<h3 id="对非空闲磁盘块的管理"><a href="#对非空闲磁盘块的管理" class="headerlink" title="对非空闲磁盘块的管理"></a>对非空闲磁盘块的管理</h3><p>存放了文件数据的磁盘块。链接分配，连续分配，索引分配</p>
<h3 id="存储空间的划分与初始化"><a href="#存储空间的划分与初始化" class="headerlink" title="存储空间的划分与初始化"></a>存储空间的划分与初始化</h3><p>文件卷，C盘，D盘这样的。初始化就是将文件卷，分为文件区和目录区。</p>
<p>其中一个物理磁盘可以划分为多个文件卷，也可以多个物理磁盘分为一个文件卷</p>
<h3 id="对空闲磁盘块的管理"><a href="#对空闲磁盘块的管理" class="headerlink" title="对空闲磁盘块的管理"></a>对空闲磁盘块的管理</h3><h4 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h4><p>适用于 “连续分配方式”</p>
<p>分配磁盘块与内存管理中的动态分区分配类似，为一个文件 <strong>分配连续的存储空间</strong>。同样<strong>可采用首次适应，最佳适应，最坏适应等算法</strong>来决定为文件分配哪个区间。</p>
<p>回收磁盘块也与内存类似。</p>
<ol>
<li>回收区的前后都没有相邻空闲区。自己为一个空闲区</li>
<li>回收区前后都是空闲区，将前后和回收的组合成一个。</li>
<li>回收区前面是空闲区，合并到前面</li>
<li>回收区后面是空闲区，合并到后面的空闲区</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115150948560.png" alt="image-20211115150948560"></p>
<h4 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h4><ul>
<li><p>空闲盘块链：以盘块为单位组成一条空闲链</p>
<p>操作系统保存着 <strong>链头，链尾指针</strong>。</p>
<p>分配：若申请k个盘块，则从链头开始拿k个盘块分配，并修改链头指针</p>
<p>回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针</p>
</li>
<li><p>空闲盘区链：以盘区为单位组成一条空闲链，在一起的盘块组成盘区，一个个盘区指针链接</p>
<p>操作系统保存着 <strong>链头，链尾指针</strong>。</p>
<p>分配：申请k个盘块，可以通过 最佳适应，首次适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的分配给文件。</p>
<p>如果没有盘块满足需求，可以将不同盘区的盘块同时分配给一个文件（分配后需要修改相应的链指针等数据）</p>
<p>回收：盘区相邻，则将回收区合并到盘区，不相邻就自己为一个盘区</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115151507824.png" alt="image-20211115151507824"></p>
<h4 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h4><p>分配：若文件需要k个块</p>
<ol>
<li>顺序扫描位示图，找到k个相邻或不相邻的 “0” （若0代表未分配）</li>
<li>根据字号，位号算出对应的盘块号，将相应盘块分配给文件；</li>
<li>将相应位设置为1</li>
</ol>
<p>回收：</p>
<ol>
<li>根据回收的盘块号计算出对应的字号、位号</li>
<li>将相应的二进制位设为 “0”</li>
</ol>
<p>这里n为字长 i j 图中有说明</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115152626097.png" alt="image-20211115152626097"></p>
<h4 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h4><p>空闲表法，空闲链表法不适用于大型文件系统，可能使他们过大。UNIX采用成组链接法对磁盘进行管理</p>
<p><strong>文件卷的目录区中</strong>专门用一个磁盘块作为 “<strong>超级块</strong>”，当系统启动时需要将<strong>超级块读入内存</strong>。并且要保证内存外存中“<strong>超级块</strong>”数据一致</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115153535549.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115153638616.png" alt="image-20211115153638616"></p>
<p>—-分配—-</p>
<p>1.假设分配1个块，将超级块的100变为99，然后将头部201分配出去。表中201那一项去掉</p>
<p>2.假设分配100个块，<strong>因为是这里是以100块为一组，而我们头部300的位置，存了下一个组的链接。所以我们需要将300中的内容复制到 超级块中。这样保证不断组</strong>。</p>
<p>—-回收—-</p>
<p>1.假设超级块100个容量，有99个空闲块，现在需要回收一个块，则将其回收到超级块，并将99+1。</p>
<p>2.假设超级块100容量，100个空闲块都在。需要回收一个块，因为已经满了，所以可以将这个块变为超级块，指向原超级块的内容。因为只有一个分组所以超级快 第一个置为1。如下图，红色框起来的是原超级块的内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115154910684.png" alt="image-20211115154910684"></p>
<h2 id="操作系统向上提供的基本功能"><a href="#操作系统向上提供的基本功能" class="headerlink" title="操作系统向上提供的基本功能"></a>操作系统向上提供的基本功能</h2><p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115162610424.png" alt="image-20211115162610424"></p>
<p><strong>—-创建文件（create系统调用）—-</strong></p>
<p>需要提供的主要参数</p>
<ol>
<li>所需的外存空间大小（如：一个盘块（1KB））</li>
<li>文件存放路径</li>
<li>文件名</li>
</ol>
<p>操作系统处理Create系统调用，主要步骤</p>
<ol>
<li><strong>在外存中找到文件所需的空间</strong>（用上面学的空闲链表法等）</li>
<li>根据文件存放路径的信息找到该目录对应的目录文件，在目录中<strong>创建该文件对应的目录项</strong>。目录项中包含了文件名，文件在外存中的存放位置等信息。</li>
</ol>
<p><strong>—-删除文件（delete）—-</strong></p>
<p>主要参数</p>
<ol>
<li>文件存放路径</li>
<li>文件名</li>
</ol>
<p>主要步骤</p>
<ol>
<li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的目录项</strong></li>
<li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，<strong>回收文件占用的磁盘块</strong>（根据空闲表法，空闲链表法等，管理策略的不同，需要做不同的处理）</li>
<li>从目录表中<strong>删除文件对应的目录项</strong></li>
</ol>
<p><strong>—-打开文件—-</strong></p>
<p>主要参数</p>
<ol>
<li>文件存放路径</li>
<li>文件名</li>
<li>要对文件的操作类型（r,w,rw等)</li>
</ol>
<p>主要步骤</p>
<ol>
<li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的目录项</strong>，并检查该用户是否有指定的操作权限</li>
<li><strong>将目录项复制到内存中的 “打开文件表” 中</strong>。并将对应表目的编号返回给用户。之后<strong>用户使用打开文件表的编号来指明要操作的文件</strong></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115160723872.png" alt="image-20211115160723872"></p>
<p><strong>—-关闭文件—-</strong></p>
<p>与打开文件对应</p>
<ol>
<li>将进程的打开文件表对应表项删除</li>
<li>回收分配给该文件的内存空间等资源</li>
<li>系统打开文件表的打开计数器（count) 减 1，若count=0，则在系统打开文件表中删除表项</li>
</ol>
<p><strong>—-读文件—-</strong></p>
<p>进程使用read系统调用完成写操作。指明是哪个文件（在支持 “打开文件” 的操作系统中，只需要提供文件在打开文件表的索引号即可），还需要指明要读入多少数据（如 1kb），指明读入的数据要存放在内存中的什么位置</p>
<p>操作系统在处理read系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中</p>
<p><strong>—-写文件—-</strong></p>
<p>进程使用 write 系统调用完成写操作，需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要写出多少数据（如：写出 1KB）、写回外存的数据放在内存中的什么位置</p>
<p>操作系统在处理 write 系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115163637800.png" alt="image-20211115163637800"></p>
<h3 id="基于索引结点的共享方式（硬链接）"><a href="#基于索引结点的共享方式（硬链接）" class="headerlink" title="基于索引结点的共享方式（硬链接）"></a>基于索引结点的共享方式（硬链接）</h3><p>前面文件的物理结构那里有 混合链接方式，其中链接文件的方式就是硬链接。</p>
<p>索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名，索引结点指针地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115163204114.png" alt="image-20211115163204114"></p>
<p>索引结点中 count表示现在有几个用户正在使用这个文件。假设现在是2，如果其中一个用户删除文件，实际只是把用户目录中与该文件对应的目录项删除，count-1。要完全删除这个文件，需要当count=0时，才会在物理上真正删除此文件。</p>
<h3 id="基于符号链的共享方式（软链接）"><a href="#基于符号链的共享方式（软链接）" class="headerlink" title="基于符号链的共享方式（软链接）"></a>基于符号链的共享方式（软链接）</h3><p>软链接就类似于快捷方式。例如一个目录的快捷方式，一个应用的快捷方式。用一个link类型文件，记录存放另外一个文件的路径。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211115163608760.png" alt="image-20211115163608760"></p>
<h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117140603557.png" alt="image-20211117140603557"></p>
<h3 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h3><p>为文件设置一个 ”口令“，用户请求访问该文件时必须提供 ”口令“</p>
<p>优点：保存口令的空间开销不多，验证口令的时间开销也很小</p>
<p>缺点：正确的 ”口令“ 存放在系统内部，不够安全</p>
<h3 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h3><p>使用 ”密钥“ 对文件进行加密，在访问文件时需要提供正确的 ”密码“ 才能对文件进行正确的解密。</p>
<p>优点：保密性强，不需要在系统中存储 ”密码“</p>
<p>缺点： 编码/译码，或者说加密/解密要花费一定时间</p>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>在每个文件的FCB（或索引结点）中增加一个<strong>访问控制列表</strong>（Access-Control List，ACL），在该表中记录了各个用户可以对该文件执行哪些操作。</p>
<p>访问类型：</p>
<ul>
<li>读</li>
<li>写</li>
<li>执行</li>
<li>添加</li>
<li>删除</li>
<li>列表清单</li>
</ul>
<p>例如 Linux 中的用户组可以设置权限。单个用户也可以设置权限</p>
<h2 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h2><p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117140726004.png" alt="image-20211117140726004"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117140750006.png" alt="image-20211117140750006"></p>
<h2 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h2><p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117141900567.png" alt="image-20211117141900567"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117141047181.png" alt="image-20211117141047181"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117141141108.png" alt="image-20211117141141108"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117141254656.png" alt="image-20211117141254656"></p>
<p><strong>(柱面号，盘面号，扇区号)</strong> 来定位 任意一个 ”磁盘块”</p>
<p>可根据该地址读取一个“块”</p>
<p>①根据“柱面号”移动磁臂，让磁头指向指定柱面；</p>
<p>②激活指定盘面对应的磁头；</p>
<p>③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。</p>
<p>盘片可更换的为”<strong>可换盘磁盘</strong>“ 反之 ”<strong>固定盘磁盘</strong>“</p>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117143843571.png" alt="image-20211117143843571"></p>
<p><strong>一次磁盘读/写操作需要的时间</strong></p>
<ol>
<li><p><strong>寻找时间（寻道时间）</strong>：将磁头移动到指定磁道所花时间，<strong>启动磁头臂</strong>假设耗时为s，<strong>移动磁头</strong>每跨越一个磁道为m，需要n条磁道</p>
<p>*<em>寻道时间 Ts= s + m</em>n**</p>
</li>
<li><p>延迟时间 Tr：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r（转/秒，转/分）</p>
<p>*<em>平均所需延迟时间 Tr = (1/2) \</em> (1/e) = 1/(2r) **</p>
</li>
<li><p>传输时间Tt：从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读/写的字节数为 b ，每个磁道上的字节数为 N。则</p>
<p>*<em>传输时间 Tt = (1/r) * (b/N) = b/(rN)*</em></p>
</li>
</ol>
<p><strong>总得平均存取时间 Ta = Ts + 1/2r + b/(rN)</strong></p>
<p>操作系统的调度算法会直接影响寻道时间，另外两个跟硬盘自身有关</p>
<h3 id="先来先服务算法（FCFS）"><a href="#先来先服务算法（FCFS）" class="headerlink" title="先来先服务算法（FCFS）"></a>先来先服务算法（FCFS）</h3><p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117142811909.png" alt="image-20211117142811909"></p>
<h3 id="最短寻找时间优先（SSTF）"><a href="#最短寻找时间优先（SSTF）" class="headerlink" title="最短寻找时间优先（SSTF）"></a>最短寻找时间优先（SSTF）</h3><p>优先处理的是与当前磁头最近的磁道。可以保证每次寻道时间最短，但是并不能保证总的寻道时间最短。但如果左右一直有很近的磁道被请求，就会一直处理这两个，会导致其他饥饿</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117143016108.png" alt="image-20211117143016108"></p>
<h3 id="扫描算法（SCAN）"><a href="#扫描算法（SCAN）" class="headerlink" title="扫描算法（SCAN）"></a>扫描算法（SCAN）</h3><p>最短寻找时间优先的改良，<strong>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内测磁道的时候才能往外移动。</strong>也叫<strong>电梯算法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117143155180.png" alt="image-20211117143155180"></p>
<h3 id="LOOK调度算法"><a href="#LOOK调度算法" class="headerlink" title="LOOK调度算法"></a>LOOK调度算法</h3><p>在扫描算法基础上改良。<strong>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向（边移动边观察）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117143302333.png" alt="image-20211117143302333"></p>
<h3 id="循环扫描算法（C-SCAN）"><a href="#循环扫描算法（C-SCAN）" class="headerlink" title="循环扫描算法（C-SCAN）"></a>循环扫描算法（C-SCAN）</h3><p>SCAN算法对于各个位置磁道的响应不平均，<strong>C-SCAN</strong>规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而<strong>返回时直接快速移动至起始端而不处理任何请求</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117143518007.png" alt="image-20211117143518007"></p>
<h3 id="C-LOOK调度算法"><a href="#C-LOOK调度算法" class="headerlink" title="C-LOOK调度算法"></a>C-LOOK调度算法</h3><p>C-SCAN算法还是要到最后一个磁道，C-LOOK在后面没有磁道需要处理的时候，磁头直接返回。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117143824698.png" alt="image-20211117143824698"></p>
<h2 id="减少延迟时间"><a href="#减少延迟时间" class="headerlink" title="减少延迟时间"></a>减少延迟时间</h2><h3 id="磁盘地址结构的设计"><a href="#磁盘地址结构的设计" class="headerlink" title="磁盘地址结构的设计"></a><strong>磁盘地址结构的设计</strong></h3><p>为什么要用 （柱面，盘面，扇区），而不用（盘面，柱面，扇区）</p>
<p>原因：在读取连续地址的磁盘块时，前者不需要移动磁头</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117144633979.png" alt="image-20211117144633979"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117144608259.png" alt="image-20211117144608259"></p>
<h3 id="交替编号"><a href="#交替编号" class="headerlink" title="交替编号"></a>交替编号</h3><p>因为走完一个扇区的时候，不能马上处理下一个扇区，需要再转一圈才能处理下一个。</p>
<p>可以让 逻辑上相邻 物理上有一定的间隔，就可以不用转一圈就可以处理下一个。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117144031772.png" alt="image-20211117144031772"></p>
<h3 id="错位命名"><a href="#错位命名" class="headerlink" title="错位命名"></a>错位命名</h3><p>让相邻<strong>盘面</strong>的扇区编号 错位。原理与交替编号一样。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117145232837.png" alt="image-20211117145232837"></p>
<h2 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h2><p><img src="https://cdn.jsdelivr.net/gh/yvenxx/blog_img@main/images/image-20211117145343193.png" alt="image-20211117145343193"></p>
<h3 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h3><ol>
<li>进行<strong>低级格式化（物理格式化）</strong>，将磁盘的各个磁道<strong>划分为扇区</strong>。一个扇区通常可分为头，数据区域，尾三个部分。管理扇区所需要的各种数据结构一般存放在头尾。包括扇区校验码（校验码用于检验扇区中的数据是否发生错误）</li>
<li>将磁盘分区，每个分区由若干柱面组成（C盘，D盘..)</li>
<li>进行<strong>逻辑格式化</strong>，创建文件系统。包括创建文件系统的根目录，初始化存储空间管理所用数据结构</li>
</ol>
<h3 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h3><p>计算机开机的初始化需要通过执行<strong>初始化程序（自举程序）</strong></p>
<p>初始化程序可以放在ROM中，ROM中的数据出厂时就写入了。<strong>以后不能修改</strong></p>
<p>但一般都是 Rom中只存放很小的 自举装入程序，通过执行该程序就可以找到引导块，将完整的自举程序读入内存，完成初始化。</p>
<p>完整的自举程序放在磁盘的启动块（启动分区）。启动块位于磁盘的固定位置。拥有启动分区的磁盘称为<strong>启动磁盘 / 系统盘</strong></p>
<h3 id="坏块的管理"><a href="#坏块的管理" class="headerlink" title="坏块的管理"></a>坏块的管理</h3><p>对于简单磁盘，可以在逻辑格式化时，对整个磁盘进行坏块检查，标明哪些扇区是坏扇区。例如FAT表上标明（这种方式中，<strong>坏块对操作系统不透明</strong>）</p>
<p>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件）会维护一张坏块链表。</p>
<p>在磁盘出厂前进行低级格式化（物理格式化）时就将 坏块链表 进行初始化。会保留一些“备用扇区”，用于替换坏块。这种方案称为 <strong>扇区备用</strong> 。且这种处理方式中，坏块<strong>对操作系统透明</strong>。</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>操作系统 第四章</p><p><span>文章作者：</span>懒人瑜恩</p><p><span>发布时间：</span>2021-12-05</p><p><span>最后更新：</span>2022-04-09</p><p><span>原始链接：</span><a href="/2021/操作系统-第四章/">https://yvenxx.github.io/yvenxx/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://yvenxx.github.io/yvenxx/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"></i></span></p><p><span>版权声明：</span>版权所有，转载请注明出处。</p></div><br><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://yvenxx.github.io/yvenxx/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0/" data-id="cl1ra5brd001oycu3arob07ks" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADJUlEQVR42u3aQW7jMBAEQP//01lgscd13D2kAIkunQIBlljMYTQ9fL3i6+fvldxv7/yU17snvK64sLGxsR/Cbl+Tb0TCS9bTrjN6FzY2NvZx7ATw7hE5b+9G5MUMGxsbGztZelvG8uanfT42NjY2drLctvD8fmdv+cTGxsb+TnYb1tQhzsK2zu5sy9KwsbGxb89uB713/vvC+TY2Njb2Ldmz4zK/Bz1JGJSUwwsV2NjY2AexZ8dx2kHvbNiQNxKz0AobGxv7PHay3DxgSjZxtpJ2C96uBBsbG/todvLQdqF5e7M+qMDGxsb+TnZOzYOklSWujASifyQ2Njb2Qez6I37ESwpbu/TkXR/aGGxsbOyHs5MxQDsq2DWO3bUd2NjY2Gez2wM3yWA1H+XO6m1bSqNWBBsbG/vh7HysO2PMis2s8Si2FRsbG/sg9mzcmwT3behfh/ujSAsbGxv7PHYe68xagnYksHI8qBgbYGNjYx/ETg7BzKKlJKCfFc5ZycTGxsY+m92G+yvLzUfI7T+jHXVgY2NjP52dh/7rUX7+nLzlmJVSbGxs7JPYbdw//MQPhruzspcXQmxsbOxT2e2Rx5VYf31D18fD/+5jY2NjH8Re+fTftYh8bJAnZFGMhY2NjX0EO/+4T5qBGaNtadoWBRsbG/ts9iw/jz70RwWmXU9bUJemxNjY2NiPYrclYaWZyTGz8cO20oWNjY19e3Z+aKY94pMXp5WDREtTbmxsbOzHsvOx6ywYWt+4WaT14bfY2NjYh7LzAze77rShT9v8vH0LNjY29kHs/Ms8L0VJycljrNngIfoVNjY29hHstrTkTcWuke0s8PoQXWFjY2Mfx86j/FmDsRLxr5w5qich2NjY2I9lX3cEZxYnzcpSsaHY2NjYB7Hza3aMJt+a2VGhthGq8djY2NgPYbeFZ9dSVsYM7YGeuiHBxsbGfiA7j5B2DXrXW53ZEAIbGxv7m9mzYW1eeK4LsP6zBmxsbOwvZueNR1tsZoWzbkKwsbGxD2W3wX0e+syCpLa1SPDD8QA2Njb27dm7Br2zozPtk3f9ChsbG/sI9h+uAtSYlvHaOAAAAABJRU5ErkJggg==">分享</a><div class="tags"></div><div class="post-nav"><a class="pre" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/">操作系统 第五章</a><a class="next" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/">操作系统-第三章</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'N4VbzTDUCqw4JIrXrqmTYp1b-gzGzoHsz',
  appKey:'1sOcwRIiKguk8n88JwbgSrCV',
  placeholder:'Just so so',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://yvenxx.github.io/yvenxx"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%94%BF%E6%B2%BB/">政治</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">6</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/%E5%BE%90%E6%B6%9B-%E5%9F%BA%E7%A1%80%E7%8F%AD-%E6%80%9D%E4%BF%AE%E6%B3%95%E5%9F%BA/">徐涛-基础班-思修法基</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/%E5%BE%90%E6%B6%9B-%E5%9F%BA%E7%A1%80%E7%8F%AD-%E5%8F%B2%E7%BA%B2/">徐涛-基础班-史纲</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/%E5%BE%90%E6%B6%9B-%E5%9F%BA%E7%A1%80%E7%8F%AD-%E6%AF%9B%E4%B8%AD%E7%89%B9/">徐涛-基础班-毛中特</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/%E5%BE%90%E6%B6%9B-%E5%9F%BA%E7%A1%80%E7%8F%AD-%E9%A9%AC%E5%8E%9F/">徐涛-基础班-马原</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">数据库原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/Redis%E5%9F%BA%E7%A1%80/">Redis基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/">操作系统 第五章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0/">操作系统 第四章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/">操作系统-第三章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%8C%E7%AB%A0/">操作系统-第二章</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.yvenxx.cn/" title="懒人瑜恩" target="_blank">懒人瑜恩</a><ul></ul><a href="https://wjjhui.github.io/" title="兔哦鸡" target="_blank">兔哦鸡</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">懒人瑜恩.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>