<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一些我的计算机笔记，JAVA/Python/Linux/后端/计算机基础"><title>计算机组成原理-第五章 | 懒人瑜恩</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + '2059a4484fb666484cf5e9fba7e20ce6';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">计算机组成原理-第五章</h1><a id="logo" href="/.">懒人瑜恩</a><p class="description">sometimes code, sometimes English</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/history/"><i class="fa fa-book"> 历史</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">计算机组成原理-第五章</h1><div class="post-meta">2021-11-09<span> | </span><span class="category"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">中央处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E6%80%BB%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">CPU的功能和基本结构总述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">运算器的基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">控制器的基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">CPU的基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">指令执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">取指周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F"><span class="toc-number">1.5.2.</span> <span class="toc-text">间址周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F"><span class="toc-number">1.5.3.</span> <span class="toc-text">执行周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.5.4.</span> <span class="toc-text">中断周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%96%B9%E6%A1%88"><span class="toc-number">1.6.</span> <span class="toc-text">指令执行方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E5%92%8C%E4%B8%A4%E7%A7%8D%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.</span> <span class="toc-text">数据通路和两种结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.1.</span> <span class="toc-text">基本单总线结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%93%E7%94%A8%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.2.</span> <span class="toc-text">专用数据通路结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E9%83%A8%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.8.</span> <span class="toc-text">硬部件控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">1.8.1.</span> <span class="toc-text">设计思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.9.</span> <span class="toc-text">微程序控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.9.1.</span> <span class="toc-text">微指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.2.</span> <span class="toc-text">微指令编码方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81%EF%BC%88%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%EF%BC%89%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">直接编码（直接控制）方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E7%9B%B4%E6%8E%A5%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">字段直接编址方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E9%97%B4%E6%8E%A5%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">字段间接编码方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9C%B0%E5%9D%80%E5%BD%A2%E6%88%90%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.3.</span> <span class="toc-text">微指令的地址形成方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.9.4.</span> <span class="toc-text">微程序控制单元设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%88%86%E7%B1%BB"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">微程序设计分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E7%A1%AC%E5%B8%83%E7%BA%BF%E5%92%8C%E5%BE%AE%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.9.5.</span> <span class="toc-text">比较硬布线和微程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE"><span class="toc-number">1.9.6.</span> <span class="toc-text">思维导图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">1.10.</span> <span class="toc-text">指令流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.10.1.</span> <span class="toc-text">流水线的性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E7%8E%87"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">吞吐率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%80%9F%E6%AF%94"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">加速比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E7%8E%87"><span class="toc-number">1.10.1.3.</span> <span class="toc-text">效率</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0"><span class="toc-number">1.10.2.</span> <span class="toc-text">影响因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.10.3.</span> <span class="toc-text">流水线的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%A4%9A%E5%8F%91%E6%8A%80%E6%9C%AF"><span class="toc-number">1.10.4.</span> <span class="toc-text">流水线的多发技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE-1"><span class="toc-number">1.10.5.</span> <span class="toc-text">思维导图</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><a id="more"></a>

<h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><h2 id="CPU的功能和基本结构总述"><a href="#CPU的功能和基本结构总述" class="headerlink" title="CPU的功能和基本结构总述"></a>CPU的功能和基本结构总述</h2><p><strong>CPU的功能</strong></p>
<ul>
<li>指令控制，完成取指令，分析指令和执行指令的操作，即程序的顺序控制</li>
<li>操作控制，一条指令的功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的不见，从而控制这些部件按指令的要求进行动作</li>
<li>时间控制：对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号</li>
<li>数据加工：对数据进行算数和逻辑运算</li>
<li>中断处理：对计算机运行过程中出现的异常情况和特殊请求进行处理</li>
</ul>
<p>运算器和控制器的功能</p>
<p>运算器：对数据进行加工</p>
<p>控制器：协调并控制计算机各部件执行程序的指令序列，基本功能包括取指令，分析指令，执行指令</p>
<ul>
<li><p>取指令：自动形成指令地址，自动发出取指令的命令</p>
</li>
<li><p>分析指令：操作码译码（包括本条指令要完成什么操作）：产生操作数的有效地址</p>
</li>
<li><p>执行指令：根据分析指令得到的 ”操作命令“ 和 ”操作数地址“ 形成操作信号控制序列，控制运算器，存储器以及I/O设备完成相应的操作</p>
</li>
<li><p>中断处理：管理总线及输入输出：处理异常情况（如掉点）和特殊请求（如打印机请求打印一行字符）</p>
</li>
</ul>
<h2 id="运算器的基本结构"><a href="#运算器的基本结构" class="headerlink" title="运算器的基本结构"></a>运算器的基本结构</h2><p>算数逻辑单元：主要功能是进行算数/逻辑运算</p>
<p>通用寄存器组：如Ax，Bx，Cx，SP（堆栈）等，用于存放操作数（包括源操作数，目的操作数及中间结果）和各种地址信息等。SP是堆栈指针，用于指示栈顶的地址</p>
<ul>
<li><p>第一张图是直接用导线连接，相当于多个寄存器同时并且一直想ALU传输数据。（有问题）</p>
</li>
<li><p>解决方法一：图2，使用多路选择器根据控制信号选择一路输出（蓝色线路）</p>
<ul>
<li>性能较高，基本不存在数据冲突现象，但结构复杂，硬件量大，不易实现</li>
</ul>
</li>
<li><p>解决方法二：图3，使用三态门可以控制每一路是否输出。</p>
<p>如R0out为<strong>1时R0中的数据输出到A端</strong>，R0out为<strong>0时R0数据无法输出到B端</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211021165001610.png" alt="image-20211021165001610"></p>
<p>另一种总线结构</p>
<ul>
<li><p>暂存寄存器：用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容。</p>
</li>
<li><p>累加寄存器：是一个通用寄存器，用于暂时存放ALU运算的结果信息，用于实现加法运算</p>
</li>
<li><p>程序状态字寄存器（PSW）：保留由算数逻辑运算指令或测试指令的结果而简历的各种状态信息，如溢出标志(OP)，符号标志(SF)，零标志(ZF)，进位标志(CF)等。PSW中的这些位参与并决定微操作的形成</p>
</li>
<li><p>移位器：对运算结果进行移位操作</p>
</li>
<li><p>计数器：控制乘除运算的操作步数</p>
</li>
</ul>
<p>结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。</p>
<blockquote>
<p>其中移位寄存器，实际是暂存寄存器拥有移位寄存器的功能。图中不好画出</p>
</blockquote>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211021165904690.png" alt="image-20211021165904690"></p>
<h2 id="控制器的基本结构"><a href="#控制器的基本结构" class="headerlink" title="控制器的基本结构"></a>控制器的基本结构</h2><ul>
<li>程序计数器；用于指出下一条指令在主存中的存放地址。CPU就是根据PC的内容去主存中取指令的。因程序中指令（通常）是顺序执行的，所以PC有自增功能</li>
<li>指令寄存器：用于保存当前正在执行的那条指令</li>
<li>指令译码器：仅对操作码字段进行译码，向控制器提供特定的操作信号</li>
<li>微操作信号发生器：根据IR的内容（指令），PSW的内容（状态信息）及   时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种</li>
<li>时序系统：用于产生各种时序信号，他们都是由统一始终（CLOCK）分频得到</li>
<li>存储器地址寄存器：用于存放所要访问的主存单元的地址</li>
<li>存储器数据寄存器：用于存放向主存写入的信息或从主存中读出的信息</li>
</ul>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211021171245774.png" alt="image-20211021171245774"></p>
<h2 id="CPU的基本结构"><a href="#CPU的基本结构" class="headerlink" title="CPU的基本结构"></a>CPU的基本结构</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211021172021116.png" alt="image-20211021172021116"></p>
<p><strong>其中橙色的是，用户可见的寄存器（可编程）</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211021171901641.png" alt="image-20211021171901641"></p>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><p><strong>指令周期</strong>：CPU从主存中每取出并执行一条指令所需的全部时间。<strong>指令周期</strong>常常用若干<strong>机器周期</strong>来表示，机器周期又叫<strong>CPU周期</strong>，一个<strong>机器周期</strong>又包含若干<strong>时钟周期</strong>（<strong>节拍、T周期或CPU时钟周期</strong>，是CPU<strong>最基本单位</strong>）</p>
<blockquote>
<p>其中T0就是时钟周期，也就是节拍。</p>
<p>每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等，每个机器周期内的节拍数也可以不等</p>
</blockquote>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025125410605.png" alt="image-20211025125410605"></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025125824192.png" alt="image-20211025125824192"></p>
<p>FE，IND，EX，INT分别是取指，间址，执行和中断4个周期，以1状态表示有效</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025130334329.png" alt="image-20211025130334329"></p>
<h3 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025132451806.png" alt="image-20211025132451806"></p>
<h3 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025132601408.png" alt="image-20211025132601408"></p>
<h3 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h3><p>执行周期的任务是根据 <strong>IR</strong> 中的指令字的操作码和操作数通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向</p>
<h3 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025132740721.png" alt="image-20211025132740721"></p>
<p>暂停当前任务去完成其他任务。为了能够恢复当前任务，需要<strong>保存断点</strong>。一般使用堆栈来保存断点，这里用SP表示栈顶地址，假设<strong>SP指向栈顶元素</strong>，进栈操作是<strong>先修改指针，后存入数据</strong>。</p>
<p>CU控制将SP减1，修改后的地址送入MAR，记作：(SP)-1—&gt;SP，(SP)—&gt;MAR，本质上是将断点存入某个存储单元，假设其地址为a，可记作a—–&gt;MAR，然后3那里CU发出控制信号，启动主存<strong>写操作</strong></p>
<h2 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h2><ol>
<li><p><strong>单指令周期</strong></p>
<p>所有指令都选用相同的执行时间来完成，也就是一条一条的进行执行</p>
</li>
<li><p><strong>多指令周期</strong></p>
<p><strong>对不同类型的指令</strong>，用不同的执行步骤来完成，也还是串行执行，但可选用不同个数的时钟周期来完成不同指令的执行过程</p>
</li>
<li><p><strong>流水线</strong></p>
<p>在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中，指令之间<strong>并行</strong>执行</p>
</li>
</ol>
<h2 id="数据通路和两种结构"><a href="#数据通路和两种结构" class="headerlink" title="数据通路和两种结构"></a>数据通路和两种结构</h2><h3 id="基本单总线结构"><a href="#基本单总线结构" class="headerlink" title="基本单总线结构"></a>基本单总线结构</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211021172021116.png"></p>
<ul>
<li>内部总线：是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线</li>
<li>系统总线：是指同一台计算机系统的各部件，如CPU，内存，通道和各类I/O接口间互相连接的总线</li>
</ul>
<p>其中通过总线进行传输。必须两个线路中，一个为out，一个为in的线路打开。才能准确传输。例如</p>
<ul>
<li>寄存器之间数据传送：PCout，MARin，就可以把PC的东西送到MAR</li>
<li>主存与CPU之间的数据传送：<ul>
<li>(PC)—&gt;BUS—-&gt;MAR</li>
<li>1—&gt;R   这里是CU发控制信号，通过控制总线发出（图中未画）</li>
<li>MEM(MAR)—&gt;MDR   内存的数据送到MDR</li>
<li>MDR—-&gt;Bus—IR</li>
</ul>
</li>
<li>执行算数或逻辑运算<ul>
<li>Ad(IR)→Bus→MAR</li>
<li>1→R</li>
<li>MEM(MAR)→数据线→MDR</li>
<li>MDR→Bus→Y</li>
<li>(ACC)+(Y)→Z</li>
<li>Z→ACC</li>
<li><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025142328186.png" alt="image-20211025142328186"></li>
</ul>
</li>
</ul>
<h3 id="专用数据通路结构"><a href="#专用数据通路结构" class="headerlink" title="专用数据通路结构"></a>专用数据通路结构</h3><p>以取指周期为例</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025143833413.png" alt="image-20211025143833413"></p>
<h2 id="硬部件控制器"><a href="#硬部件控制器" class="headerlink" title="硬部件控制器"></a>硬部件控制器</h2><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025164006649.png" alt="image-20211025164006649"></p>
<p>紫色的那里是机器周期，绿色是机器状态条件。红色是发出的 “微命令”</p>
<p>电路是在CU内部。例如要进行一个取指PC—&gt;MAR，则将 FE*T0=C1（假设以便理解）</p>
<p>再一个简单的电路图</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025164721781.png" alt="image-20211025164721781"></p>
<p>公式的意思是，FE*T1代表的是所有公式都需要FE*T1这个操作。IND<em>T1(ADD+STA+LDA+JMP+BAN)是ADD STA这些要IND\</em>T1这个操作。且这些操作都是在T1实现的，这个电路就可以是前面CU里面的电路，当然实际的肯定更复杂，不会只有这么多功能。</p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ol>
<li>分析每个阶段的微操作序列（取指，间址，执行，中断四个阶段，也就是确定哪些指令的什么阶段，在什么条件下会使用到的微操作）</li>
<li>选择CPU的控制方式（采用定长还是不定长，每个机器周期有几个节拍）</li>
<li>安排微操作时序（假设我们有3个节拍，怎么在3个节拍完成所有微操作）</li>
<li>电路设计（确定每个微操作命令的逻辑表达式，并实现电路）</li>
</ol>
<p><strong>1</strong>.分析</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025165326869.png" alt="image-20211025165326869"></p>
<p><strong>2</strong>.假设只有3个节拍</p>
<p><strong>3</strong>.安排微操作时序</p>
<blockquote>
<p><strong>注：如果微操作数小于节拍数，就把操作放在后面，以实现不管怎么样都是3个节拍完成</strong></p>
</blockquote>
<p>三原则</p>
<ul>
<li>微操作的<strong>先后顺序不得</strong>随意<strong>更改</strong></li>
<li><strong>被控对象不同</strong>的微操作，尽量安排在<strong>一个节拍</strong>内完成</li>
<li>占用<strong>时间较短</strong>的微操作，尽量安排在<strong>一个节拍内</strong>完成，并<strong>允许有先后顺序</strong></li>
</ul>
<p>例：取指周期</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(1)</span>pc---&gt;MAR    <span class="number">1</span></span><br><span class="line"><span class="comment">(2)</span><span class="number">1</span>----&gt;R      <span class="number">2</span></span><br><span class="line"><span class="comment">(3)</span>M<span class="comment">(MAR)</span>--&gt;MDR <span class="number">3</span></span><br><span class="line"><span class="comment">(4)</span>MDR---&gt;IR    <span class="number">4</span></span><br><span class="line"><span class="comment">(5)</span>OP<span class="comment">(IR)</span>----ID <span class="number">5</span></span><br><span class="line"><span class="comment">(6)</span><span class="comment">(PC)</span><span class="number">+1</span>---&gt;PC <span class="number">6</span></span><br><span class="line"></span><br><span class="line">变为如下</span><br><span class="line">T<span class="number">0</span> <span class="comment">(1)</span>pc---&gt;MAR     <span class="number">1</span></span><br><span class="line">T<span class="number">0</span> <span class="comment">(2)</span><span class="number">1</span>----&gt;R       <span class="number">2</span></span><br><span class="line">T<span class="number">1</span> <span class="comment">(3)</span>M<span class="comment">(MAR)</span>--&gt;MDR  <span class="number">3</span></span><br><span class="line">T<span class="number">1</span> <span class="comment">(6)</span><span class="comment">(PC)</span><span class="number">+1</span>---&gt;PC  <span class="number">4</span></span><br><span class="line">T<span class="number">2</span> <span class="comment">(4)</span>MDR---&gt;IR     <span class="number">5</span></span><br><span class="line">T<span class="number">2</span> <span class="comment">(5)</span>OP<span class="comment">(IR)</span>----ID  <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>其中1，2因为一个是CPU内部寄存器的操作，2是主存的操作。而且相互不影响。所以可以放在一起操作</p>
<p>因为3必须1走完才能操作，所以放在位置3，其中6的操作不影响其他的操作，只要PC取完数据之后就能操作，所以放在4的位置也可以。因为4的操作需要等3完成，他们不能放在一个周期，所以让4在后面一个周期。而5又需要等4的结果，所以放在4后面。又因为45是在CPU内部，操作很快，因此可以在一个节拍内完成。</p>
<p>例2</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CLA，clear操作，进行ACC清零</span><br><span class="line"><span class="built_in">T0</span></span><br><span class="line"><span class="built_in">T1</span></span><br><span class="line"><span class="built_in">T2</span>   <span class="number">0</span>---&gt;AC</span><br></pre></td></tr></table></figure>
<p>只需要一次操作就可以完成，所以放在最后</p>
<p><strong>4</strong>这里可以分成三个步骤 </p>
<p>列出操作时间表，写出微操作命令的最简表达式，画出逻辑图</p>
<p><strong>操作时间表</strong></p>
<p>取指阶段</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025171526784.png" alt="image-20211025171526784"></p>
<p>间址阶段</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025171604766.png" alt="image-20211025171604766"></p>
<p>执行周期</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025171424908.png" alt="image-20211025171424908"></p>
<p><strong>微操作命令的最简表达式</strong></p>
<p>以M(MAR)—-&gt;MDR为例</p>
<p>取指阶段是所有都为1都有这个操作，间址阶段CLA到STP是没有的。执行阶段只有ADD,LDA有。且所有都在T1的节拍中。所以最后公式如下</p>
<p>FE*T1 + IND*T1(ADD+STA+LDA+JMP+BAN) + EX*T1(ADD+LDA)，这里还要化简省略了</p>
<p><strong>逻辑图如下</strong></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025172006381.png" alt="image-20211025172006381"></p>
<h2 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h2><p>设计思路：采用 ”存储程序“，将所有指令的 ”微程序“ 存入 ”控制器存储器“ 中</p>
<p>相当于，微程序包含多个微操作，微操作包含多个微命令。</p>
<p>指令是对<strong>程序</strong>执行步骤的描述</p>
<p>微指令是对<strong>指令</strong>执行步骤的描述</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">T0</span> (<span class="number">1</span>)pc---&gt;MAR     <span class="number">1</span></span><br><span class="line"><span class="attribute">T0</span> (<span class="number">2</span>)<span class="number">1</span>----&gt;R       <span class="number">2</span></span><br><span class="line"><span class="attribute">T1</span> (<span class="number">3</span>)M(MAR)--&gt;MDR  <span class="number">3</span></span><br><span class="line"><span class="attribute">T1</span> (<span class="number">6</span>)(PC)+<span class="number">1</span>---&gt;PC  <span class="number">4</span></span><br><span class="line"><span class="attribute">T2</span> (<span class="number">4</span>)MDR---&gt;IR     <span class="number">5</span></span><br><span class="line"><span class="attribute">T2</span> (<span class="number">5</span>)OP(IR)----微地址形成部件  <span class="number">6</span></span><br></pre></td></tr></table></figure>


<p><strong>这里和硬布线不同，硬布线最后一步进入ID指令译码器，微程序这里进入的是微地址形成部件</strong>，且其中还需要加入一些其它微命令，在微程序设计那里进行讨论</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025174009279.png" alt="image-20211025174009279"></p>
<p>其中<strong>下地址</strong>的存放的是下一个指令的地址。下地址左边的是现在的微指令</p>
<p>CM控制存储器</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211025174233544.png" alt="image-20211025174233544"></p>
<p><strong>存放了所有的指令</strong>，左边的数字是地址信息</p>
<p>补充：</p>
<p>因为是顺序逻辑来进行的操作。所以就这个图中，取指完了之后实际是间址，但是有的指令不需要进行间址。所以图中顺序逻辑的位置实际是有个标志位进行标识。 OP那里有带标志位。间址周期完成之后，就进入到执行周期（<strong>转执行周期</strong>）</p>
<p>还有就是 CLK判断中断信号。如果判断带了中断信号，就进行中断操作。中断操作之后，会回到原来的取指（<strong>转取指周期</strong>）</p>
<p>执行周期执行玩之后，最后的下地址是0，所以就会走回到取指周期</p>
<p><strong>取指周期：通常是公用的，如果某指令系统中有n条机器指令（LDA，ADD等），则CM中微程序的个数至少是n+1个。间址周期和中断周期不算在计算中。</strong>因为一些早期的CPU，物联网设备的CPU可以不提供间接寻址和中断功能，因此这类CPU可以不包含间址周期，中断周期的微程序段。</p>
<p>在物理上看，取指周期，执行周期是两个微程序，但逻辑上他们其实是一个整体。所以<strong>一条指令对应一个微程序</strong></p>
<h3 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026124551152.png" alt="image-20211026124551152"></p>
<h3 id="微指令编码方式"><a href="#微指令编码方式" class="headerlink" title="微指令编码方式"></a>微指令编码方式</h3><h4 id="直接编码（直接控制）方式"><a href="#直接编码（直接控制）方式" class="headerlink" title="直接编码（直接控制）方式"></a>直接编码（直接控制）方式</h4><p>在微指令的操作控制字段中，<strong>每一位代表一个微操作命令</strong>，某位的”1“ 表示该控制命令有效</p>
<p>优点：简单，直观，执行速度快，操作并行性好</p>
<p>缺点：微指令字长过长，n个微命令就要求微指令的操作字段有n位，造成控存容量极大</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026125036268.png" alt="image-20211026125036268"></p>
<h4 id="字段直接编址方式"><a href="#字段直接编址方式" class="headerlink" title="字段直接编址方式"></a>字段直接编址方式</h4><p>将微指令的控制字段分成若干 ”段“，<strong>每段经译码后发出控制信号</strong></p>
<p>原则：</p>
<ol>
<li><strong>互斥性</strong>的微命令分在<strong>同一段内，相容性</strong>的微命令分在<strong>不同段内</strong></li>
<li><strong>每个小段</strong>中包含的<strong>信息位不能太多</strong>，否则将增加译码线路的复杂性和译码时间</li>
<li>一般<strong>每个小段还要留出一个状态</strong>，表示本字段不发出任何微命令。相当于当某个字段长度3位时，最多只能表示7个互斥的微命令，<strong>通常用000表示不操作</strong></li>
</ol>
<p>优点：可以缩短微指令字长</p>
<p>缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢</p>
<p>如下图，其中分段进行划分，PC—&gt;MAR 和 (PC)+1—&gt;PC是互斥的，放在同一个段</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026125646325.png" alt="image-20211026125646325"></p>
<blockquote>
<p>例题</p>
<p>某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码法，共有33个微命令，构成5个互斥类，分别包含7，3，12，5和6个微命令，则操作控制字段至少有多少位？</p>
<p>解</p>
<p>第一个互斥类有7个微命令，要留出1个状态表示不操作，所以需要8种不同的状态，需要两个3个二进制位。其他几个一样的算法。然后3+2+4+3+3=15位。</p>
</blockquote>
<h4 id="字段间接编码方式"><a href="#字段间接编码方式" class="headerlink" title="字段间接编码方式"></a>字段间接编码方式</h4><p>一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，故称为字段间接编码，又称<strong>隐式编码</strong></p>
<p>优点：可进一步缩短微指令字长</p>
<p>缺点：削弱了微指令的并行控制能力，故通常作为字段直接的一种辅助手段</p>
<p>译码之后又进行了一次译码</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026130530514.png" alt="image-20211026130530514"></p>
<h3 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h3><ol>
<li><p>微指令的<strong>下地址字段</strong>指出：微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址，<strong>断定方式</strong></p>
</li>
<li><p>根据机器指令的<strong>操作码</strong>形成：当机器指令取至指令寄存器后，微指令的地址由操作码经<strong>微地址形成部件</strong>形成</p>
</li>
<li><p>增量计数器法 （CMAR)+1—-&gt;CMAR</p>
</li>
<li><p>分支转移   转移方式：指明判别条件；   转移地址指明转移成功后的去向</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026130959621.png" alt="image-20211026130959621"></p>
</li>
<li><p>通过测试网络   </p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026131229661.png" alt="image-20211026131229661"></p>
</li>
<li><p>由硬件产生微程序入口地址，<strong>第一条微指令地址</strong>由专门的<strong>硬件产生</strong>，中断周期也由<strong>硬件</strong>产生<strong>中断周期微程序首地址</strong></p>
</li>
</ol>
<blockquote>
<p>微指令的地址形成方式，出题例题</p>
<p>某计算机采用微程序控制器，共有32条指令，公共的取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成，采用断定法（下地址字段法）确定下条微指令地址，则微指令中下地址字段的位数至少是多少位</p>
<p>解</p>
<p>已知公共有2条微指令，还有32条指令，32条指令每一条包含4条微指令，则应该是</p>
<p>2+32*2=130条微指令。标注出130位不同的位置需要 2^8=256，则下地址字段的位数至少8位</p>
</blockquote>
<h3 id="微程序控制单元设计"><a href="#微程序控制单元设计" class="headerlink" title="微程序控制单元设计"></a>微程序控制单元设计</h3><p>设计步骤</p>
<ol>
<li><p>分析每个阶段的微操作序列（这里只进行取指的分析）</p>
</li>
<li><p>写出对应机器指令的微操作命令及节拍安排</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026132334342.png" alt="image-20211026132334342"></p>
</li>
<li><p>确定微指令格式</p>
<p>根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数。由微指令数确定微指令的控制字段的位数，最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长</p>
</li>
<li><p>编写微指令码点</p>
<p>根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点</p>
</li>
</ol>
<h4 id="微程序设计分类"><a href="#微程序设计分类" class="headerlink" title="微程序设计分类"></a>微程序设计分类</h4><ol>
<li><p>静态微程序设计和动态微程序设计</p>
<p>静态 微程序无需改变 采用ROM</p>
<p>动态 通过 改变微指令  和   微程序改变机器指令，有利于仿真，采用EPROM</p>
</li>
<li><p>毫微程序设计</p>
<p>毫微程序设计的基本概念</p>
<p>微程序设计 用 微程序解释机器指令</p>
<p>毫微程序设计 用 毫微程序解释微程序</p>
<p>毫微指令与微指令的关系好比微指令与机器指令的关系</p>
</li>
</ol>
<h3 id="比较硬布线和微程序"><a href="#比较硬布线和微程序" class="headerlink" title="比较硬布线和微程序"></a>比较硬布线和微程序</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026133143470.png" alt="image-20211026133143470"></p>
<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026133303687.png" alt="image-20211026133303687"></p>
<h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p>一条指令的执行过程可以分成多个阶段，根据计算机的不同，具体的分法也不同。假如是  取指，分析，执行。</p>
<p><strong>顺序执行方式</strong></p>
<p>优点：控制简单，硬件代价小</p>
<p>缺点：执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低</p>
<p>耗时：T=n*3t = 3nt</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026133641492.png" alt="image-20211026133641492"></p>
<p><strong>一次重叠执行方式</strong></p>
<p>耗时：T = 3t + (n-1)*2t = (1+2n)t)</p>
<p>优点：程序的执行时间缩短了1/3，各功能部件的利用率明显提高</p>
<p>缺点：需要付出硬件上较大开销的代价，控制过程也比顺序执行复杂了</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026133832790.png" alt="image-20211026133832790"></p>
<p><strong>二次重叠执行方式</strong></p>
<p>指令的执行时间缩短2/3。是一种理想的指令执行方式，正常情况下处理机中同时有3条指令在执行</p>
<p>耗时：T = 3t + (n-1)*t = (2+n)t</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026134005386.png" alt="image-20211026134005386"></p>
<p><strong>流水线的表示方法</strong></p>
<p>这里时空图是把执行分为5个阶段。但是这里是理想状态</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026134352713.png" alt="image-20211026134352713"></p>
<h3 id="流水线的性能指标"><a href="#流水线的性能指标" class="headerlink" title="流水线的性能指标"></a>流水线的性能指标</h3><h4 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h4><p>指在单位时间内流水线所完成的任务数量，或是输出结果的数量。</p>
<p>任务数为n，处理n个任务所用的时间为Tk，吞吐率为TP</p>
<p>TP=n/Tk</p>
<p>例，此图是理想情况的图</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026134910109.png" alt="image-20211026134910109"></p>
<p>Tk=(k+n-1) △t，则 TP= n/TK</p>
<h4 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h4><p>完成同样一批任务，<strong>不使用流水线所用的时间</strong>与<strong>使用流水线所用的时间</strong>之比。也就是T0/Tk</p>
<p>就上图来说，T0=kn△t</p>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>流水线的设备利用率称为流水线的效率，在时空图上，流水线的效率定义为<strong>完成n个任务占用的时空区有效面积</strong>与<strong>n个任务所用的时间与k个流水段所围成的时空区</strong>之比</p>
<p>流水线效率（E）的一般公式为  </p>
<p>E=n个任务占用k时空区有效面积 / n个任务所用的时间与k个流水段所围城的时空区总面积   </p>
<p>E=T0/kTk</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026135900185.png" alt="image-20211026135900185"></p>
<h3 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h3><p><strong>结构相关（资源冲突）</strong></p>
<p>问题</p>
<p>由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关</p>
<p>解决</p>
<ol>
<li>后一相关指令暂停一周期</li>
<li>资源重复配置：数据存储器+指令存储器</li>
</ol>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026141900701.png" alt="image-20211026141900701"></p>
<p><strong>数据相关（数据冲突）</strong></p>
<p>数据相关指在一个程序中，存在必须等前一条指令执行完才能执行h后一条指令的情况，则这两条指令为数据相关</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026142254023.png" alt="image-20211026142254023"></p>
<p>解决</p>
<ol>
<li><p>把遇到数据相关的指令极其后序指令都暂停 一至几个时钟周期，知道数据相关问题消失后再继续执行。可分为硬件阻塞（stall）和软件插入（NOP）</p>
<p>如下是NOP的图，硬件的图也差不多，把NOP变成stall就行</p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026142840478.png" alt="image-20211026142840478"></p>
</li>
<li><p>数据旁路技术</p>
<p>简单来说就是，下面的需要r1，需要第一条指令 执行完成，但是我们可以在他计算完之后，直接从ALU把数据就取过来。不需要经过内存</p>
</li>
<li><p>编译优化：通过编译器调整指令顺序来解决数据相关</p>
</li>
</ol>
<p><strong>控制相关（控制冲突）</strong></p>
<p>当流水线遇到转移指令和其他改变PC值的指令而造成断流时，会引起控制相关</p>
<p>解决</p>
<ol>
<li><p>尽早判别转移是否发生，尽早生成转移目标地址</p>
</li>
<li><p>预取转移成功和不成功两个控制流方向上的目标指令</p>
</li>
<li><p>加快和提前形成条件码</p>
<p>例如加法器那里的，提前把进位信息取出来给出去</p>
</li>
<li><p>提高转移方向的猜准率</p>
</li>
</ol>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026143403202.png" alt="image-20211026143403202"></p>
<h3 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h3><ol>
<li><strong>部件功能级，处理机级和处理机间的级流水线</strong><ol>
<li><strong>部件功能级流水</strong>就是将复杂的算数逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差，对阶，尾数相加以及结果规格化等4个过程</li>
<li><strong>处理机级流水</strong>是把一条指令解释过程分成多个子过程，如取指，译码，执行，访存及写回5个子过程</li>
<li><strong>处理机间流水</strong>是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中</li>
</ol>
</li>
<li>单功能流水线和多功能流水线<ol>
<li><strong>单功能流水线</strong>指只能实现一种固定的专门功能的流水线</li>
<li><strong>多功能流水线</strong>指通过各段间的不同连接方式可以同时或不同时的实现多种功能的流水线</li>
</ol>
</li>
<li>动态流水线和静态流水线<ol>
<li><strong>静态流水线</strong>指同一时间内，流水线的各段只能按同一种功能的连接方式工作</li>
<li><strong>动态流水线</strong>指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变的很复杂</li>
</ol>
</li>
<li>线性流水线和非线性流水线<ol>
<li><strong>线性流水线</strong>，从输入到输出，每个功能只允许经过一次，不存在反馈回路。（数据回路就是例如ALU的结果又取回进行使用）</li>
<li><strong>非线性流水线</strong>存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线。这种流水线适合进行线性递归运算</li>
</ol>
</li>
</ol>
<h3 id="流水线的多发技术"><a href="#流水线的多发技术" class="headerlink" title="流水线的多发技术"></a>流水线的多发技术</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026144829633.png" alt="image-20211026144829633"></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026144836354.png" alt="image-20211026144836354"></p>
<p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026144846396.png" alt="image-20211026144846396"></p>
<h3 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://gitee.com/yvenxx/git-book-image/raw/master/images/image-20211026144859586.png" alt="image-20211026144859586"></p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>计算机组成原理-第五章</p><p><span>文章作者：</span>懒人瑜恩</p><p><span>发布时间：</span>2021-11-09</p><p><span>最后更新：</span>2021-11-09</p><p><span>原始链接：</span><a href="/2021/计算机组成原理-第五章/">https://yvenxx.github.io/yvenxx/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%94%E7%AB%A0/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://yvenxx.github.io/yvenxx/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%94%E7%AB%A0/"></i></span></p><p><span>版权声明：</span>版权所有，转载请注明出处。</p></div><br><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://yvenxx.github.io/yvenxx/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%94%E7%AB%A0/" data-id="cl1p5jq9r0023owu32knt40in" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASYAAAEmCAAAAADqr2IGAAAElElEQVR42u3ay26kSBAF0P7/n/ZIs2vZVb43AqtJfFhZFIbksMh4/fkTHx//H5//Tq75+HR8Pv/qys/Per+Sj7fH+/VfcGDChAkTplsy5bfOF/1+cQl08hlmEMl9vrgDJkyYMGE6nCm/3fv/bTf4PcT79bchxcvzmDBhwoTpFzDl+WCSP7YfIH/uLEzBhAkTJkyYNv/VguZkSRLbJsmYMGHChOl5TPtUc9YZfN/yzH9tEX+wFo4JEyZMmG7G1G7JT/r74gMTJkyYMN2MaZYu5mXWTfNyH2Tkwcc3b40JEyZMmI5lStLC/PXaLfnnirybJxYVAkyYMGHCdHumfBxnv51vRn+SMdOcoL0zJkyYMGF6HtPsxdoR1VlBdtaMnEFjwoQJE6ZnMCXL2g/NRFl4yZGs4YKSMSZMmDBhOpZpw9E2DvOE+dqPsS8xY8KECROm05lmpd6cadaA3KfBs5T75RMxYcKECdPhTLNmZFQkXVzfbuqzZmp0f0yYMGHCdCzTLCV+fybZmPPCbh4i5EXhttCMCRMmTJiewTQrgOZl3FkDNS/ytu3Y9iNhwoQJE6azmPIh0fb1Zi+Qp8pFcXbdlMWECRMmTKczJWntplR6VWm1DS/2jdK/AgJMmDBhwnQs02wps7GeTXN0n363wUEUNWDChAkTphszzRqN7ea9ecn8BfZDPBc0MjFhwoQJ082Y8gRy1mJMGoqzAZrNmbyEHVUIMGHChAnTgUztFj5LRzdPuWqYNXo6JkyYMGF6BFMSCswywfzX/IXbknEeoERVAUyYMGHCdAjTbAvPH5MPBu3HT9vPvAoaMGHChAnTIUz5mOZPbKttQHDVGlo+TJgwYcJ0LtO+/JoPs7YtzD305v5f3AETJkyYMB3INEsO2w07Lyu34Uje8szXgwkTJkyYnso0W/RVEMkd2ue+B8p/xYQJEyZM5zIllyYpbp58ttx5+7Mu2pYlYEyYMGHCdCLTpvyaFFivgpu1M1vcl0/EhAkTJkyPYEqSxnbTbRPO/Pq8edkGH5gwYcKE6UlMeeLabqVtkDErNLeN2Fm7FBMmTJgwnc7Ulmvz9Hg/TNOO7OyDlaIKjgkTJkyYDmHKU9zN+EsbXuQBR925LcMFTJgwYcJ0OtNmWbPNu92MNy/cvgUmTJgwYfptTG16nJdcZyM7147v1Fk7JkyYMGF6BNNsG86vT7b/q4ZvZs/64ldMmDBhwnQg0+xVN+Xg/JPMCrWzJPkbREyYMGHC9Aim2eDO5vXyFuZ+U29X+9cZTJgwYcJ0LNOsPTnb/nPEthlZ5/pxU3M4GYQJEyZMmG7D9FEe7ThOO9aTtx7bsCBPv1/GTZgwYcKE6UCmdmplc7tZ+XV25ewzzwIRTJgwYcJ0f6Y8CNgUZ5NCbVtQboOSzZgRJkyYMGE6nWkWBOwbn3k40haI26jnm+QZEyZMmDD9AqZZ4rrh2BRtryr4YsKECROm38aUF3zzRbSjole1M4tSNSZMmDBhOpxpk8RuNuA2mMiv3xSmL25nYsKECROmf8q0KYDOHta2QmeDQZu7DQ9MmDBhwnQvpv8A5DuAEanXXKkAAAAASUVORK5CYII=">分享</a><div class="tags"></div><div class="post-nav"><a class="pre" href="/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E5%85%AD%E7%AB%A0/">计算机组成原理-第六章</a><a class="next" href="/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E5%9B%9B%E7%AB%A0/">计算机组成原理-第四章</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://yvenxx.github.io/yvenxx"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">6</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">数据库原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/Redis%E5%9F%BA%E7%A1%80/">Redis基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/">操作系统 第五章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0/">操作系统 第四章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/">操作系统-第三章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%8C%E7%AB%A0/">操作系统-第二章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%80%E7%AB%A0/">操作系统-第一章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%83%E7%AB%A0/">计算机组成原理-第七章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E5%85%AD%E7%AB%A0/">计算机组成原理-第六章</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%94%E7%AB%A0/">计算机组成原理-第五章</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.yvenxx.cn/" title="懒人瑜恩" target="_blank">懒人瑜恩</a><ul></ul><a href="https://wjjhui.github.io/" title="兔哦鸡" target="_blank">兔哦鸡</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">懒人瑜恩.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>